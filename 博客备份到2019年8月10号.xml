<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-菜鸟-传奇</title><link>https://www.cnblogs.com/cainiao-chuanqi/</link><description>愿路途漫长，以后莫失莫忘。 愿你不骄不躁，安稳顺心。</description><language>zh-cn</language><lastBuildDate>Sat, 10 Aug 2019 06:53:35 GMT</lastBuildDate><pubDate>Sat, 10 Aug 2019 06:53:35 GMT</pubDate><ttl>60</ttl><item><title>JavaIO学习：序列化流</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328503.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 09:17:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328503.html</guid><description><![CDATA[<h2 style="text-align: center;">对象流</h2>
<h3>1.涉及到的类</h3>
<p><strong>ObjectInputStream 和 ObjectOutputStream</strong></p>
<ul>
<li>用于存储和读取基本数据类型数据或对象的处理流。</li>
</ul>
<p>&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190810145048519-2062808273.jpg" alt="" width="729" height="373" /></p>
<p>&nbsp;</p>
<h3>2.作用</h3>
<ul>
<li><strong>ObjectOutputStream:</strong>内存中的对象 -----&gt;存储中的文件、通过网络传输出去 序列化过程</li>
<li><strong>ObjectInputStream：</strong>存储中的文件、通过网络接收过来 ----&gt;内存中的对象反序列化过程</li>
</ul>
<p>用于存储和读取基本数据类型数据或对象的处理流。可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p>
<p>&nbsp;</p>
<h2>3.对象的序列化机制</h2>
<p><strong>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，</strong>从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
<h4>示例代码如下：</h4>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去
使用ObjectOutputStream实现
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test(){
      ObjectOutputStream  oos </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
      </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
          oos </span>= <span style="color: #0000ff;">new</span> ObjectOutputStream(<span style="color: #0000ff;">new</span> FileOutputStream("object.dat"<span style="color: #000000;">));

          oos.writeObject(</span><span style="color: #0000ff;">new</span> String("你真是太帅了"<span style="color: #000000;">));
          oos.flush();</span><span style="color: #008000;">//</span><span style="color: #008000;">刷新操作</span>
<span style="color: #000000;">
          oos.writeObject(</span><span style="color: #0000ff;">new</span> Person("小子",21<span style="color: #000000;">));
          oos.flush();

          oos.writeObject(</span><span style="color: #0000ff;">new</span> Person("小妞",20,1001,<span style="color: #0000ff;">new</span> Account(500<span style="color: #000000;">)));
          oos.flush();


      } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
          e.printStackTrace();
      } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
          </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
              </span><span style="color: #0000ff;">if</span> (oos !=<span style="color: #0000ff;">null</span><span style="color: #000000;">){
                  oos.close();
              }
          } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
              e.printStackTrace();
          }
      }

  }<br /><br />
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
 反序列化：将磁盘文件中的对象还原为内存中的一个java对象
 使用ObjectInputStream来实现
  </span><span style="color: #008000;">*/</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test2(){
      ObjectInputStream ois </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
      </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
          ois </span>= <span style="color: #0000ff;">new</span> ObjectInputStream(<span style="color: #0000ff;">new</span> FileInputStream("object.dat"<span style="color: #000000;">));

          Object obj </span>=<span style="color: #000000;"> ois.readObject();
          String str </span>=<span style="color: #000000;"> (String) obj;

          Person p </span>=<span style="color: #000000;"> (Person) ois.readObject();
          Person p1 </span>=<span style="color: #000000;"> (Person) ois.readObject();

          System.out.println(str);
          System.out.println(p);
          System.out.println(p1);

      } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
          e.printStackTrace();
      } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (ClassNotFoundException e) {
          e.printStackTrace();
      } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
          </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
              </span><span style="color: #0000ff;">if</span> (ois !=<span style="color: #0000ff;">null</span><span style="color: #000000;">){
                  ois.close();
              }
          } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
              e.printStackTrace();
          }
      }

  }</span></pre>
</div>
<p>&nbsp;</p>
<h3>4.实现序列化的类需要满足</h3>
<p><strong>实现序列化时Javabean需要满足如下的要求，方可序列化：</strong></p>
<ol>
<li><strong>需要实现接口：Serializable</strong></li>
<li>当前类提供一个全局常量<strong>：serialVersionUID</strong></li>
<li>除了当前Person类需要实现Serializable接口之外，还必须保证其内部的所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li>
<li><strong>ObjectOutputStream和ObjectInputStream</strong>不能序列化<strong>static和transient</strong>修饰的成员变量。</li>
</ol>
<h4>示例代码如下：</h4>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Person <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Serializable {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span> serialVersionUID = 457987412388296L<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> age;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> id;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Account acct;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Person() {
    }

    </span><span style="color: #0000ff;">public</span> Person(String name, <span style="color: #0000ff;">int</span><span style="color: #000000;"> age) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }

    </span><span style="color: #0000ff;">public</span> Person(String name, <span style="color: #0000ff;">int</span> age, <span style="color: #0000ff;">int</span><span style="color: #000000;"> id) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
        </span><span style="color: #0000ff;">this</span>.id =<span style="color: #000000;"> id;
    }

    </span><span style="color: #0000ff;">public</span> Person(String name,<span style="color: #0000ff;">int</span> age,<span style="color: #0000ff;">int</span><span style="color: #000000;"> id,Account acct){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
        </span><span style="color: #0000ff;">this</span>.id =<span style="color: #000000;"> id;
        </span><span style="color: #0000ff;">this</span>.acct =<span style="color: #000000;"> acct;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setName(String name) {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getAge() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> age;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setAge(<span style="color: #0000ff;">int</span><span style="color: #000000;"> age) {
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getId() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> id;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setId(<span style="color: #0000ff;">int</span><span style="color: #000000;"> id) {
        </span><span style="color: #0000ff;">this</span>.id =<span style="color: #000000;"> id;
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Account getAcct() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> acct;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setAcct(Account acct) {
        </span><span style="color: #0000ff;">this</span>.acct =<span style="color: #000000;"> acct;
    }

    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
        </span><span style="color: #0000ff;">return</span> "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                ", acct=" + acct +
                '}'<span style="color: #000000;">;
    }
}
</span><span style="color: #0000ff;">class</span> Account <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Serializable{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span> serialVersionUID = 48446849848932L<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">double</span><span style="color: #000000;"> balance;

    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
        </span><span style="color: #0000ff;">return</span> "Account{" +
                "balance=" + balance +
                '}'<span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span><span style="color: #000000;"> getBalance() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> balance;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setBalance(<span style="color: #0000ff;">double</span><span style="color: #000000;"> balance) {
        </span><span style="color: #0000ff;">this</span>.balance =<span style="color: #000000;"> balance;
    }

    </span><span style="color: #0000ff;">public</span> Account(<span style="color: #0000ff;">double</span><span style="color: #000000;"> balance) {

        </span><span style="color: #0000ff;">this</span>.balance =<span style="color: #000000;"> balance;
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>JavaIO学习：转换流</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328422.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 09:09:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328422.html</guid><description><![CDATA[<h2 style="text-align: center;">转换流</h2>
<h3>1.涉及到的类</h3>
<ul>
<li><strong>InputStreamReader：</strong>将InputStream转换为Reader</li>
<li><strong>OutputStreamWriter：</strong>将Writer转换为OutputStream</li>
</ul>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190810145153008-2102216015.jpg" alt="" width="513" height="264" /></p>
<p>&nbsp;</p>
<h3>2.构造器</h3>
<ul>
<li><strong>public OutputStreamWriter(OutputStream out)</strong></li>
<li><strong>public OutputSreamWriter(OutputStream out,String charsetName)</strong></li>
</ul>
<h3>3.作用</h3>
<ul>
<li>提供字节流和字符流之间的转换</li>
</ul>
<h3>4.编码表：</h3>
<p><strong>常见的编码表：</strong></p>
<ul>
<li>ASCII：美国标准信息交换码。用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表 。用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符。</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li>
</ul>
<h3>示例：</h3>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test2(){
       </span><span style="color: #008000;">//</span><span style="color: #008000;">1.造文件</span>
       InputStreamReader isr = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
       OutputStreamWriter osw </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
       </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
           File file1 </span>= <span style="color: #0000ff;">new</span> File("dbcp.txt"<span style="color: #000000;">);
           File file2 </span>= <span style="color: #0000ff;">new</span> File("dbcp_gbk.txt"<span style="color: #000000;">);

           FileInputStream fis </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(file1);
           FileOutputStream fos </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(file2);

           isr </span>= <span style="color: #0000ff;">new</span> InputStreamReader(fis,"utf-8"<span style="color: #000000;">);
           osw </span>= <span style="color: #0000ff;">new</span> OutputStreamWriter(fos,"gbk"<span style="color: #000000;">);
            </span><span style="color: #008000;">//</span><span style="color: #008000;">2.读写过程</span>
           <span style="color: #0000ff;">char</span>[] cbuf = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">char</span>[20<span style="color: #000000;">];
           </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> len;
           </span><span style="color: #0000ff;">while</span> ((len = isr.read(cbuf)) != -1<span style="color: #000000;">){
               osw.write(cbuf,</span>0<span style="color: #000000;">,len);

           }
       } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
           e.printStackTrace();
       } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
           </span><span style="color: #008000;">//</span><span style="color: #008000;">3.关闭资源</span>
           <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
               </span><span style="color: #0000ff;">if</span> (isr != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
                   isr.close();
               }
           } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
               e.printStackTrace();
           }
           </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
               </span><span style="color: #0000ff;">if</span> (osw != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
                   osw.close();
               }
           } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
               e.printStackTrace();
           }
       }
}    </span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>JavaIO学习：打印流</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328383.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 09:05:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328383.html</guid><description><![CDATA[<h2 style="text-align: center;">打印流</h2>
<blockquote>
<p style="text-align: center;">打印流是输出信息最方便的类，注意包含字节<strong>打印流：PrintStream和字符打印流：PrintWriter。</strong></p>
<p style="text-align: center;">打印流提供了非常方便的打印功能，可以打印任何类型的数据信息，例如<strong>：小数，整数，字符串。</strong></p>
</blockquote>
<p><strong>回顾：</strong></p>
<p>之前打印信息需要使用OutputStream但是这样，所有数据输出会非常麻烦，String--&gt;byte[]，打印流中可以方便进行输出，</p>
<p>&nbsp;</p>
<h3>打印流好处</h3>
<blockquote>
<p style="text-align: center;">通过定义的构造方法可以发现，有一个构造方法可以<strong>直接接收OutputStream类的实例，</strong>与OutputStream相比起来，PrintStream可以更方便的输出数据，相当于把OutputStream类重新包装了一下，使之输出更方便。</p>
</blockquote>
<h3>格式化输出</h3>
<p>JAVA对PrintStream功能进行了扩充，增加了格式化输出功能。直接使用Print即可。但是输出的时候需要指定输出的数据类型。</p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190809165820353-1839509820.png" alt="" width="633" height="181" /></p>
<p>&nbsp;</p>
<h3>打印流：<strong>PrintStream 和PrintWriter</strong></h3>
<ul>
<li>实现将基本数据类型的数据格式转化为字符串输出。</li>
</ul>
<p><strong>说明：</strong></p>
<ol>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出。</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常。</li>
<li>PrintStream和PrintWriter有自动flush功能。</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。 在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</li>
<li>System.out返回的是PrintStream的实例。</li>
</ol>
<h4>示例代码：</h4>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test2() {<br />
 PrintStream ps </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;<br />
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        FileOutputStream fos </span>= <span style="color: #0000ff;">new</span> FileOutputStream(<span style="color: #0000ff;">new</span> File("D:\\cai\\a.txt"<span style="color: #000000;">));
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\n' 时都会刷新输出缓冲区)</span>
        ps = <span style="color: #0000ff;">new</span> PrintStream(fos, <span style="color: #0000ff;">true</span><span style="color: #000000;">);<br />
        </span><span style="color: #0000ff;">if</span> (ps != <span style="color: #0000ff;">null</span>) {<span style="color: #008000;">//</span><span style="color: #008000;"> 把标准输出流(控制台输出)改成文件</span>
<span style="color: #000000;">            System.setOut(ps);
        }<br />
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt;= 255; i++) { <span style="color: #008000;">//</span><span style="color: #008000;"> 输出ASCII字符</span>
            System.out.print((<span style="color: #0000ff;">char</span><span style="color: #000000;">) i);
            </span><span style="color: #0000ff;">if</span> (i % 50 == 0) { <span style="color: #008000;">//</span><span style="color: #008000;"> 每50个数据一行</span>
                System.out.println(); <span style="color: #008000;">//</span><span style="color: #008000;"> 换行</span>
<span style="color: #000000;">            }
        }<br />
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (FileNotFoundException e) {
        e.printStackTrace();<br />
    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
        </span><span style="color: #0000ff;">if</span> (ps != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            ps.close();
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>JavaIO学习：缓冲流</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328278.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 08:53:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328278.html</guid><description><![CDATA[<h2 style="text-align: center;">缓冲流</h2>
<h3>1.缓冲流涉及到的类</h3>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<h3>2.作用</h3>
<ul>
<li>提升流的读取、写入的速度。</li>
<li>原因：内部提供了一个缓冲区,默认情况下是8192，即8kb。</li>
</ul>
<h3>3.使用BufferedInputStream和BufferedOutputStream</h3>
<h4><strong>处理非文本文件</strong></h4>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">实现文件复制的方法</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> copyFileWithBuffered(String srcPath,String destPath) {
    FileInputStream fis </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    FileOutputStream fos </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    BufferedInputStream bis </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    BufferedOutputStream bos </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1.</span>
        File srcfile = <span style="color: #0000ff;">new</span><span style="color: #000000;"> File(srcPath);
        File destfile </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> File(destPath);

        </span><span style="color: #008000;">//</span><span style="color: #008000;">2.
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2.1造节点流</span>
        fis = <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileInputStream(srcfile);
        fos </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(destfile);

        </span><span style="color: #008000;">//</span><span style="color: #008000;">2.2造缓冲流</span>
        bis = <span style="color: #0000ff;">new</span><span style="color: #000000;"> BufferedInputStream(fis);
        bos </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> BufferedOutputStream(fos);

        </span><span style="color: #008000;">//</span><span style="color: #008000;">3.</span>
        <span style="color: #0000ff;">byte</span>[] buffer = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[1024<span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> len;
        </span><span style="color: #0000ff;">while</span> ((len = bis.read(buffer)) != -1<span style="color: #000000;">){
            bos.write(buffer,</span>0<span style="color: #000000;">,len);

　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;"> bos.flush();</span><span style="color: #008000;">//</span><span style="color: #008000;">刷新缓冲区</span>
<span style="color: #000000;">        }
        System.out.println(</span>"复制成功"<span style="color: #000000;">);
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
        e.printStackTrace();
    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4.</span><span style="color: #008000;">要求：先关闭外层的流，再关闭内层的流</span>
        <span style="color: #0000ff;">if</span> (bos != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                bos.close();
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
                e.printStackTrace();
            }
        }
        </span><span style="color: #0000ff;">if</span> (bis != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
            </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
                bis.close();
            } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
                e.printStackTrace();
            }
        }
    }

</span><span style="color: #008000;">//</span><span style="color: #008000;">说明：关闭外层流的同时，内层流也会自动的进行关闭，关于内层流的关闭，我们可以省略
</span><span style="color: #008000;">//</span><span style="color: #008000;">   fos.close();
</span><span style="color: #008000;">//</span><span style="color: #008000;">   fis.close();</span><span style="color: #000000;">
}</span></pre>
</div>
<h4>对上述方法进行测试：</h4>
<div class="cnblogs_code">
<pre><span style="color: #000000;">@Test
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> testCopyBuffererd(){
    </span><span style="color: #0000ff;">long</span> start =<span style="color: #000000;"> System.currentTimeMillis();
    String srcPath </span>= "1.jpg"<span style="color: #000000;">;
    String destPath </span>= "6.jpg"<span style="color: #000000;">;
    copyFileWithBuffered(srcPath,destPath);
    </span><span style="color: #0000ff;">long</span> end =<span style="color: #000000;"> System.currentTimeMillis();
    System.out.println(</span>"复制所需要的毫秒数为:"+ (end -<span style="color: #000000;"> start));
}</span></pre>
</div>
<h4>4.使用BufferedReader和BufferedWriter:处理文本文件</h4>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">使用BufferedReader和BufferedWriter实现文本文件的复制</span>
<span style="color: #000000;">
@Test
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> test6(){
    BufferedReader br </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    BufferedWriter bw </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">使用匿名方式，创建文件和相应的流</span>
        br = <span style="color: #0000ff;">new</span> BufferedReader(<span style="color: #0000ff;">new</span> FileReader(<span style="color: #0000ff;">new</span> File("dbcp.txt"<span style="color: #000000;">)));
        bw </span>= <span style="color: #0000ff;">new</span> BufferedWriter(<span style="color: #0000ff;">new</span> FileWriter(<span style="color: #0000ff;">new</span> File("dbcp1.txt"<span style="color: #000000;">)));

        </span><span style="color: #008000;">//</span><span style="color: #008000;">读写操作
        </span><span style="color: #008000;">//</span><span style="color: #008000;">方式一：使用char[]数组
</span><span style="color: #008000;">//</span><span style="color: #008000;">  char[] cbuf = new char[1024];
</span><span style="color: #008000;">//</span><span style="color: #008000;">   int len;
</span><span style="color: #008000;">//</span><span style="color: #008000;">   while ((len = br.read(cbuf)) != -1){
</span><span style="color: #008000;">//</span><span style="color: #008000;">   bw.write(cbuf,0,len);
</span><span style="color: #008000;">//</span><span style="color: #008000;">   bw.flush();</span><span style="color: #008000;">//</span><span style="color: #008000;">刷新操作
</span><span style="color: #008000;">//</span><span style="color: #008000;">   }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">方式二：使用String</span>
<span style="color: #000000;">        String data;
        </span><span style="color: #0000ff;">while</span> ((data = br.readLine()) != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
            bw.write(data);
            bw.newLine();</span><span style="color: #008000;">//</span><span style="color: #008000;">提供换行的操作</span>
<span style="color: #000000;">        }
        System.out.println(</span>"复制成功"<span style="color: #000000;">);
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
        e.printStackTrace();
    } </span><span style="color: #0000ff;">finally</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">关闭资源</span>
        <span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (bw != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
                bw.close();
            }
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
            e.printStackTrace();
        }
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (br != <span style="color: #0000ff;">null</span><span style="color: #000000;">){
                br.close();
            }
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
            e.printStackTrace();
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：Properties类</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328209.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 08:43:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328209.html</guid><description><![CDATA[<h2 style="text-align: center;">&nbsp;Java学习：Properties类</h2>
<h3>学习目标</h3>
<ol>
<li>认识properties文件，理解其含义，会正确创建properties文件。</li>
<li>会使用java.util.Properties类来操作properties文件。</li>
</ol>
<h4>一、认识properties文件</h4>
<ul>
<li>properties文件是一个文本文件</li>
<li>properties文件的语法有两种，一种是注释，一种属性配置。</li>
</ul>
<p><strong>注 释：</strong>前面加上#号</p>
<p><strong>属性配置：</strong>以<strong>&ldquo;键=值&rdquo;</strong>的方式书写一个属性的配置信息。</p>
<ul>
<li>properties文件的一个<strong>属性配置信息值可以换行，但键不可以换行。值换行用&ldquo;\&rdquo;表示。</strong></li>
<li>properties的<strong>属性配置键值前后的空格</strong>在解析时候会被忽略。</li>
<li>properties文件可以<strong>只有键而没有值</strong>。也可以仅有键和等号而没有值，但无论如何一个属性配置不能没有键。</li>
</ul>
<p>&nbsp;</p>
<h3>二、解读java.util.Properties类</h3>
<blockquote>
<p>在java.util 包下面有一个类 Properties，<strong>该类主要用于读取以项目的配置文件</strong>（以．properties结尾的文件和xml文件）。Properties类是Hashtable的子类。也就是说它具备Map集合的特点。Properties的构造函数有两个<strong>，一个不带参数，一个使用一个Properties对象作为参数。</strong></p>
</blockquote>
<h4>1、Properties类的层次结构</h4>
<div class="cnblogs_code">
<pre><span style="color: #000000;">java.lang.Object

    java.util.Dictionary</span>&lt;K,V&gt;<span style="color: #000000;">

        java.util.Hashtable</span>&lt;Object,Object&gt;<span style="color: #000000;">

            java.util.Properties   </span></pre>
</div>
<p>&nbsp;</p>
<ul>
<li>从层次机构看，<strong>Properties类实现了Map接口</strong>，因为HashTable实现了Map接口，因此Properties类本质上是一种简单的<strong>Map容器。</strong></li>
</ul>
<p><strong>实际上：</strong></p>
<ul>
<li>Properties类本身表示了对一种Map结构的操作。<strong>properties文件本身就表示了一个&ldquo;键值对&rdquo;的集合。</strong>因此，Properties类属于集合容器的家族，在使用前应该创建一个Properties的容器，实际上就是创建一个默认不带参数的Properties对象。<strong>以后通过别的方式给里面添加&ldquo;键值对&rdquo;。</strong></li>
</ul>
<h4>2、properties文件与Properties类的关系</h4>
<ul>
<li>通过properties文件可以填充Properties类。</li>
<li>也可以通过xml文件来填充Properties类。</li>
<li>可以通过绝对路径方式加载Properties文件信息，也可以使用相对路径加载。</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>JavaIO学习：字节流</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328140.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 08:33:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328140.html</guid><description><![CDATA[<h2 style="text-align: center;"><strong>JavaIO流之字节流</strong></h2>
<h2>字节流</h2>
<p>抽象基类:<strong>InputStream，OutputStream。</strong></p>
<ul>
<li>字节流可以操作任何数据。</li>
</ul>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190810145229495-1744728407.jpg" alt="" width="602" height="434" /></p>
<p>&nbsp;</p>
<p><strong>注意：</strong></p>
<ul>
<li>字符流使用的数组是字符数组，<strong>char[] chs ；</strong></li>
<li>字节流使用的数组是字节数组，<strong>byte[] bt ；</strong></li>
</ul>
<div class="cnblogs_code">
<pre>FileOutputStream fos=<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileOutputStream(&ldquo;a.txt&rdquo;)；

fos.write(</span>"abcde"); <span style="color: #008000;">//</span><span style="color: #008000;">直接将数据写入到了目的地。</span>
<span style="color: #000000;">
fos.close();</span><span style="color: #008000;">//</span><span style="color: #008000;">只关闭资源。</span>
<span style="color: #000000;">
FileInputSteam fls</span>=<span style="color: #0000ff;">new</span> FileInputStream("a.txt"<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;">fis.available();</span><span style="color: #008000;">//</span><span style="color: #008000;">获取关联的文件字节数。如果文件体积不大，可以这样操作。</span>

<span style="color: #0000ff;">byte</span>[]buf=<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[fis.available()];<span style="color: #008000;">//</span><span style="color: #008000;">创建一个刚刚好的缓冲区。</span><span style="color: #008000;">//</span><span style="color: #008000;">但是这有一个弊端，就是文件过大，大小超出Jvm的内容空间时，会内存溢出。</span>
<span style="color: #000000;">
fis.read(buf);

System.out.println(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> String(buf));

 </span></pre>
</div>
<p>&nbsp;</p>
<h3>例子:</h3>
<h4>需求:copy一个图片。</h4>
<div class="cnblogs_code">
<pre>BufferedInputStream bufis=<span style="color: #0000ff;">new</span> BufferedInputStream(<span style="color: #0000ff;">new</span> FileInputStream("1.jpg"<span style="color: #000000;">));

BufferedOutputStream bufos</span>=<span style="color: #0000ff;">new</span> BufferedOutputStream(<span style="color: #0000ff;">new</span> FileOutputStream("2.jpg"<span style="color: #000000;">));

</span><span style="color: #0000ff;">int</span> by=0<span style="color: #000000;">;

</span><span style="color: #0000ff;">while</span>(by=bufis.read()!=-1<span style="color: #000000;">){

　　bufos.write(by);

　　bufos.newLine();

}

bufis.close();

bufos.close();</span>&nbsp;</pre>
</div>
<h4><strong>小结:</strong></h4>
<p><strong>目前学习的流对象:</strong></p>
<ul>
<li><strong>字符流:</strong> FileReader FileWriter BuffereedReader BufferedWriter</li>
<li><strong>字节流:</strong>FileInputStream FileOutputStream BufferedInputStream BufferedOutputStream</li>
</ul>
<h3>补充：</h3>
<p><strong>1.</strong>字节流的read（）方法读取的是一个字节。为什么返回的不是byte类型，而是int类型呢？</p>
<ul>
<li>因为read方法读到末尾时返回的是-1，而在所操作的数据中很容易出现连续多个1的情况，而连续读到8个1，就是-1，导致读取会提前停止。所以将读到的一个字节提升为一个int类型的数值，但是只保留原字节，并在剩余二进制位补0。</li>
</ul>
<p><strong>具体操作是：</strong>byte&amp;255 or byte&amp;0xff</p>
<p>&nbsp;</p>
<ul>
<li>对于write方法，可以一次写入一个字节，但接收的是一个int类型数值。只写入该int类型的数值的最低一个字节（8位）。</li>
<li>简单说：read方法对读到的数据进行提升，write对操作的数据进行转换。</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>JavaIO学习：字符流</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328070.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 08:24:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11328070.html</guid><description><![CDATA[<h2 style="text-align: center;">JavaIO流之字符流</h2>
<h2>字符流</h2>
<h4><strong>Reader </strong></h4>
<p><strong>InputStreamReader </strong></p>
<ul>
<li>FileReader:专门用于处理文件的字符读取流对象。</li>
</ul>
<h4>Writer</h4>
<p><strong>OutputStreamWriter </strong></p>
<ul>
<li>FileWriter:专门用于处理文件的字符写入流对象</li>
</ul>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190810145307874-943798652.jpg" alt="" width="654" height="471" /></p>
<p>&nbsp;</p>
<h3>Reader中的常见的方法</h3>
<p><strong>1. int read()： </strong></p>
<ul>
<li>读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回-1.</li>
</ul>
<p><strong>2. int read(char[])： </strong></p>
<ul>
<li>将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回-1.</li>
</ul>
<p><strong>3. close(): </strong></p>
<ul>
<li>读取字符其实用的是window系统的功能，就希望使用完毕后，进行资源的释放。</li>
</ul>
<p>&nbsp;</p>
<h3>Writer中的常见的方法</h3>
<ol>
<li>write(ch): 将一个字符写入到流中。</li>
<li>write(char[]): 将一个字符数组写入到流中。</li>
<li>write(String): 将一个字符串写入到流中。</li>
<li>flush():刷新流，将流中的数据刷新到目的地中，流还存在。</li>
<li>close():关闭资源：在关闭前会先调用flush()，刷新流中的数据去目的地。然流关闭。</li>
</ol>
<p>&nbsp;</p>
<h2>FileWriter</h2>
<p>该类没有特有的方法。只有自己的构造函数。</p>
<p>该类特点在于：</p>
<ol>
<li>用于处理文本文件。</li>
<li>该类中有默认的编码表，</li>
<li>该类中有临时缓冲。</li>
</ol>
<h3>构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地。</h3>
<p><strong> FileWriter(String filename):</strong> 该构造函数做了什么事情呢？</p>
<ol>
<li>调用系统资源。</li>
<li>在指定位置，创建一个文件。</li>
</ol>
<p><strong> 注意：</strong>如果该文件已存在，将会被覆盖。</p>
<p><strong>FileWriter(String filename,boolean append): </strong></p>
<ul>
<li><strong>该构造函数：</strong>当传入的boolean类型值为true时，会在指定文件末尾处进行数据的续写。</li>
</ul>
<p>&nbsp;</p>
<h2>FileReader</h2>
<ol>
<li>用于读取文本文件的流对象。</li>
<li>用于关联文本文件。</li>
</ol>
<h3><strong> 构造函数：</strong>在读取流对象初始化的时候，必须要指定一个被读取的文件。</h3>
<ul>
<li>如果该文件不存在会发生<strong>FileNotFoundException. </strong></li>
</ul>
<p><strong>FileReader(String filename);</strong></p>
<ul>
<li>对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出<strong>IOException</strong>或其子类。</li>
<li>所以都要进行处理，或者<strong>throws</strong>抛出，或者<strong>try、catch</strong>处理。</li>
</ul>
<h2>&nbsp;例子</h2>
<h4><strong>将文本数据存储到一个文件：</strong></h4>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span> java.io.*<span style="color: #000000;">;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TestFileWriter1 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        FileWriter fw</span>=<span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
            fw</span>=<span style="color: #0000ff;">new</span> FileWriter("D:\\JAVA练习代码\\123.txt"<span style="color: #000000;">);
            fw.write(</span>"abcdec"<span style="color: #000000;">);
            fw.flush();
            fw.write(</span>"kkkk"<span style="color: #000000;">);
        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(IOException e){
            System.out.println(e.toString());
        }
        </span><span style="color: #0000ff;">finally</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">if</span>(fw!=<span style="color: #0000ff;">null</span><span style="color: #000000;">)
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
                    fw.close();
                }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
                    System.out.println(</span>"close"+<span style="color: #000000;">e.toString());
                }
        }
    }
}</span></pre>
</div>
<p><strong>另一个小细节： </strong></p>
<p>当指定绝对路径时，定义目录分隔符有两种方式：</p>
<ol>
<li>反斜线 但是一定要写两个。\\ new FileWriter("c:\\cai.txt");</li>
<li>斜线 / 写一个即可。 new FileWriter("c:/cai.txt");</li>
</ol>
<p>&nbsp;</p>
<h4><strong>读一个字符就存入字符数组里，读完1Kb再打印。</strong></h4>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span> java.io.*<span style="color: #000000;">;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TestFileReader1 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        FileReader fr</span>=<span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
            fr</span>=<span style="color: #0000ff;">new</span> FileReader("D:\\JAVA练习代码\\abc.txt"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">char</span>[]buf=<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">char</span>[1024];    <span style="color: #008000;">//</span><span style="color: #008000;">该长度通常都是1024的整数倍</span>
            <span style="color: #0000ff;">int</span> len=0<span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span>((len=fr.read(buf))!=-1<span style="color: #000000;">){
                System.out.println(</span><span style="color: #0000ff;">new</span> String(buf,0<span style="color: #000000;">,len));
            }
        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(IOException e){
            System.out.println(e);
        }
        </span><span style="color: #0000ff;">finally</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">if</span>(fr!=<span style="color: #0000ff;">null</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
                    fr.close();
                }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(IOException e){
                    System.out.println(</span>"close"+<span style="color: #000000;">e);
                }
            }
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>字符流的缓冲区：</h2>
<ul>
<li><strong>缓冲区的出现提高了对流的操作效率。</strong></li>
</ul>
<p><strong>原理</strong>：其实就是将数组进行封装。</p>
<h3>对应的对象：</h3>
<p><strong>BufferedWriter：</strong></p>
<p>　　特有方法：</p>
<p>　　　<strong>　newLine（）</strong>：跨平台的换行符。</p>
<p><strong>BufferedReader：</strong></p>
<p>　　特有方法：</p>
<p>　　　　<strong>readLine（）</strong>：一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回。当读到末尾时，返回null。</p>
<p>&nbsp;</p>
<ul>
<li>使用缓冲区对象时，要明确缓冲的存在是为了增强流的功能而存在，所以在简历缓冲区对象时，要现有流对象存在。</li>
<li>其实缓冲内部就是在使用流对象的方法，只不过加入了数组对数据进行了临时存储，为了提高操作数据的效率。</li>
</ul>
<h3><strong>代码上的体现:</strong></h3>
<h4><strong>写入缓冲区对象：</strong></h4>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数。</span>
<span style="color: #000000;">
BufferedWriter bw</span>=<span style="color: #0000ff;">new</span> BufferedWriter（<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileWriter（&ldquo;abc.txt&rdquo;））；

bw.write(</span>"abce");<span style="color: #008000;">//</span><span style="color: #008000;">将数据写入到了缓冲区。</span>
<span style="color: #000000;">
bw.flush();</span><span style="color: #008000;">//</span><span style="color: #008000;">对缓冲区的数据进行刷新。将数据刷到目的地中。</span>
<span style="color: #000000;">
bw.close();</span><span style="color: #008000;">//</span><span style="color: #008000;">关闭缓冲区，其实关闭的是被包装在内部的流对象。</span>
<span style="color: #000000;">
读取缓冲区对象：

BufferedReader br</span>=<span style="color: #0000ff;">new</span> BufferedReader(<span style="color: #0000ff;">new</span> FileReader("abc.txt"<span style="color: #000000;">));

String s</span>=<span style="color: #0000ff;">null</span>;</pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span> java.io.*<span style="color: #000000;">;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> TestBufferStream {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
            BufferedWriter bw</span>=<span style="color: #0000ff;">new</span> BufferedWriter(<span style="color: #0000ff;">new</span> FileWriter("D:\\Java练习代码\\abc.txt"<span style="color: #000000;">));
            BufferedReader br</span>=<span style="color: #0000ff;">new</span> BufferedReader(<span style="color: #0000ff;">new</span> FileReader("D:\\Java练习代码\\abc.txt"<span style="color: #000000;">));
            String s</span>=<span style="color: #0000ff;">null</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=1;i&lt;=100;i++<span style="color: #000000;">){
                s</span>=<span style="color: #000000;">String.valueOf(Math.random());
                bw.write(s);
                bw.newLine();
            }
            bw.flush();
            </span><span style="color: #0000ff;">while</span>((s=br.readLine())!=<span style="color: #0000ff;">null</span><span style="color: #000000;">){
                System.out.println(s);
            }
            bw.close();
            br.close();
        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e){
            e.printStackTrace();
        }    
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br /> </p>]]></description></item><item><title>Java学习：IO流</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11327934.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 08:11:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11327934.html</guid><description><![CDATA[<h2 style="text-align: center;">IO流</h2>
<h3>1.IO流</h3>
<ul>
<li><strong>用于处理设备上的数据</strong>。</li>
<li>设备：硬盘，内存，键盘录入。</li>
</ul>
<h3>2. IO有具体的分类：</h3>
<ol>
<li>根据处理的数据类型不同：字节流和字符流。</li>
<li>根据流向不同：输入流和输出流。</li>
</ol>
<h4>字符流的由来：</h4>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190810144938445-792239521.jpg" alt="" width="606" height="428" /></p>
<p>&nbsp;</p>
<p>因为文件编码的不同，而有了对字符进行高效操作的字符流对象。</p>
<p><strong>原理：</strong>其实就是基于字节流读取字节时，去查了指定的码表。</p>
<h4>字节流和字符流的区别：</h4>
<p><strong>（1）</strong>字节流读取的时候，读到一个字节就返回一个字节。</p>
<ul>
<li>字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在UTF-8码表中是3个字节）时，先去查指定的编码表，将查到的字符返回。</li>
</ul>
<p><strong>（2）</strong>字节流可以处理所有类型数据，如MP3，图片，avi。而字符流只能处理字符数据。</p>
<ul>
<li>结论：只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都要用字节流。</li>
</ul>
<p>&nbsp;</p>
<p>IO的体系，所具备的基本功能就有两个：<strong>读和写。</strong></p>
<ol>
<li>字节流：InputStream(读)，OutputStream（写）。</li>
<li>字符流：Reader（读），Writer（写）。</li>
</ol>
<p>&nbsp;</p>]]></description></item><item><title>Java中的Filter过滤器</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11326793.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 06:02:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11326793.html</guid><description><![CDATA[<h2 style="text-align: center;">Java中的Filter过滤器</h2>
<h2>Filter简介</h2>
<hr />
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190809135320083-426474192.png" alt="" width="664" height="138" /></p>
<p>Filter也称之为过滤器，它是Servlet技术中最实用的技术，Web开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p>
<p>它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理。使用Filter的完整流程：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。</p>
<h2>Filter功能</h2>
<hr />
<p>在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest 。根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据。</p>
<p>在HttpServletResponse到达客户端之前，拦截HttpServletResponse 。根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。</p>
<h2><strong>如何借助Filter实现拦截功能</strong></h2>
<hr />
<p>&nbsp;</p>
<p>Filter接口中有一个doFilter方法，当开发人员编写好Filter，并配置对哪个web资源进行拦截后，Web服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">调用目标资源之前，让一段代码执行。
是否调用目标资源（即是否让用户访问web资源）。
web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个doFilter方法，<br />开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。</span></pre>
</div>
<h2>Filter开发两步走</h2>
<hr />
<p>&nbsp;</p>
<p>编写java类实现Filter接口，并实现其doFilter方法。<br />在web.xml文件中对编写的filter类进行注册，并设置它所能拦截的资源。</p>
<p><strong>web.xml配置各节点介绍：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">指定一个过滤器。
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">用于为过滤器指定一个名字，该元素的内容不能为空。
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-class</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">元素用于指定过滤器的完整的限定类名。
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>元素用于为过滤器指定初始化参数，它的子元素<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>指定参数的名字，<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">指定参数的值。
在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-mapping</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>子元素用于设置filter的注册名称。该值必须是在<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">元素中声明过的过滤器的名字
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">url-pattern</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">设置 filter 所拦截的请求路径(过滤器关联的URL样式)
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">servlet-name</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">指定过滤器所拦截的Servlet名称。
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dispatcher</span><span style="color: #0000ff;">&gt;</span>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dispatcher</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">子元素用来指定 Filter 对资源的多种调用方式进行拦截。
</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">dispatcher</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">子元素可以设置的值及其意义
REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。
INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。
FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。
ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</span></pre>
</div>
<h2>Filter链</h2>
<hr />
<p>&nbsp;</p>
<p>在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。</p>
<p>web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。</p>
<h2>Filter的生命周期</h2>
<hr />
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> init(FilterConfig filterConfig) <span style="color: #0000ff;">throws</span> ServletException;<span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
<span style="color: #000000;">和我们编写的Servlet程序一样，Filter的创建和销毁由WEB服务器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <span style="color: #0000ff;">throws</span> IOException, ServletException;<span style="color: #008000;">//</span><span style="color: #008000;">拦截请求</span>
<span style="color: #000000;">这个方法完成实际的过滤操作。当客户请求访问与过滤器关联的URL的时候，Servlet过滤器将先执行doFilter方法。FilterChain参数用于访问后续过滤器。

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> destroy();<span style="color: #008000;">//</span><span style="color: #008000;">销毁</span>
Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</pre>
</div>
<h2>FilterConfig接口</h2>
<hr />
<p>&nbsp;</p>
<p>用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得以下内容：</p>
<div class="cnblogs_code">
<pre>String getFilterName();<span style="color: #008000;">//</span><span style="color: #008000;">得到filter的名称。 </span>
String getInitParameter(String name);<span style="color: #008000;">//</span><span style="color: #008000;">返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. </span>
Enumeration getInitParameterNames();<span style="color: #008000;">//</span><span style="color: #008000;">返回过滤器的所有初始化参数的名字的枚举集合。 </span>
<span style="color: #0000ff;">public</span> ServletContext getServletContext();<span style="color: #008000;">//</span><span style="color: #008000;">返回Servlet上下文对象的引用。</span></pre>
</div>
<h2>Filter使用案例</h2>
<hr />
<p>&nbsp;</p>
<h3><strong>使用Filter验证用户登录安全控制</strong></h3>
<p>前段时间参与维护一个项目，用户退出系统后，再去地址栏访问历史，根据url，仍然能够进入系统响应页面。我去检查一下发现对请求未进行过滤验证用户登录。添加一个filter搞定问题！</p>
<h4>先在web.xml配置</h4>
<div class="cnblogs_code">
<pre>&lt;filter&gt;
&lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;
&lt;filter-<span style="color: #0000ff;">class</span>&gt;com.action.login.SessionFilter&lt;/filter-<span style="color: #0000ff;">class</span>&gt;
&lt;init-param&gt;
&lt;param-name&gt;logonStrings&lt;/param-name&gt;&lt;!-- 对登录页面不进行过滤 --&gt;
&lt;param-value&gt;/project/index.jsp;login.<span style="color: #0000ff;">do</span>&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
&lt;param-name&gt;includeStrings&lt;/param-name&gt;&lt;!-- 只对指定过滤参数后缀进行过滤 --&gt;
&lt;param-value&gt;.<span style="color: #0000ff;">do</span>;.jsp&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
&lt;param-name&gt;redirectPath&lt;/param-name&gt;&lt;!-- 未通过跳转到登录界面 --&gt;
&lt;param-value&gt;/index.jsp&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
&lt;param-name&gt;disabletestfilter&lt;/param-name&gt;&lt;!-- Y:过滤无效 --&gt;
&lt;param-value&gt;N&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;SessionFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;<span style="color: #008000;">/*</span><span style="color: #008000;">&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</span></pre>
</div>
<h4>接着编写FilterServlet</h4>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.action.login;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.IOException;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.Filter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.FilterChain;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.FilterConfig;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.ServletException;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.ServletRequest;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.ServletResponse;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.http.HttpServletRequest;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.http.HttpServletResponse;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> javax.servlet.http.HttpServletResponseWrapper;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
* 判断用户是否登录,未登录则退出系统
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> SessionFilter <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Filter {

</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> FilterConfig config;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> destroy() {
</span><span style="color: #0000ff;">this</span>.config = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isContains(String container, String[] regx) {
</span><span style="color: #0000ff;">boolean</span> result = <span style="color: #0000ff;">false</span><span style="color: #000000;">;

</span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; regx.length; i++<span style="color: #000000;">) {
</span><span style="color: #0000ff;">if</span> (container.indexOf(regx[i]) != -1<span style="color: #000000;">) {
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}
}
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException, ServletException {
HttpServletRequest hrequest </span>=<span style="color: #000000;"> (HttpServletRequest)request;
HttpServletResponseWrapper wrapper </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> HttpServletResponseWrapper((HttpServletResponse) response);

String logonStrings </span>= config.getInitParameter("logonStrings"); <span style="color: #008000;">//</span><span style="color: #008000;"> 登录登陆页面</span>
String includeStrings = config.getInitParameter("includeStrings"); <span style="color: #008000;">//</span><span style="color: #008000;"> 过滤资源后缀参数</span>
String redirectPath = hrequest.getContextPath() + config.getInitParameter("redirectPath");<span style="color: #008000;">//</span><span style="color: #008000;"> 没有登陆转向页面</span>
String disabletestfilter = config.getInitParameter("disabletestfilter");<span style="color: #008000;">//</span><span style="color: #008000;"> 过滤器是否有效</span>

<span style="color: #0000ff;">if</span> (disabletestfilter.toUpperCase().equals("Y")) { <span style="color: #008000;">//</span><span style="color: #008000;"> 过滤无效</span>
<span style="color: #000000;">chain.doFilter(request, response);
</span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}
String[] logonList </span>= logonStrings.split(";"<span style="color: #000000;">);
String[] includeList </span>= includeStrings.split(";"<span style="color: #000000;">);

</span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">this</span>.isContains(hrequest.getRequestURI(), includeList)) {<span style="color: #008000;">//</span><span style="color: #008000;"> 只对指定过滤参数后缀进行过滤</span>
<span style="color: #000000;">chain.doFilter(request, response);
</span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.isContains(hrequest.getRequestURI(), logonList)) {<span style="color: #008000;">//</span><span style="color: #008000;"> 对登录页面不进行过滤</span>
<span style="color: #000000;">chain.doFilter(request, response);
</span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}

String user </span>= ( String ) hrequest.getSession().getAttribute("useronly");<span style="color: #008000;">//</span><span style="color: #008000;">判断用户是否登录</span>
<span style="color: #0000ff;">if</span> (user == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
wrapper.sendRedirect(redirectPath);
</span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
chain.doFilter(request, response);
</span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
}
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> init(FilterConfig filterConfig) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> ServletException {
config </span>=<span style="color: #000000;"> filterConfig;
}
}</span></pre>
</div>
<p>这样既可完成对用户所有请求，均要经过这个Filter进行验证用户登录。</p>
<h3><strong>防止中文乱码过滤器</strong></h3>
<p>项目使用spring框架时。当前台JSP页面和Java代码中使用了不同的字符集进行编码的时候就会出现表单提交的数据或者上传/下载中文名称文件出现乱码的问题，那就可以使用这个过滤器。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>encoding<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-class</span><span style="color: #0000ff;">&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-class</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>encoding<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span><span style="color: #008000;">&lt;!--</span><span style="color: #008000;">用来指定一个具体的字符集</span><span style="color: #008000;">--&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>UTF-8<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>forceEncoding<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span><span style="color: #008000;">&lt;!--</span><span style="color: #008000;">true：无论request是否指定了字符集，都是用encoding；false：如果request已指定一个字符集，则不使用encoding</span><span style="color: #008000;">--&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>false<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-mapping</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>encoding<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">url-pattern</span><span style="color: #0000ff;">&gt;</span>/*<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">url-pattern</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-mapping</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：File类中的过滤器接口</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11326729.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 05:49:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11326729.html</guid><description><![CDATA[<h2>javaIO类的File类应用:过滤器接口</h2>
<p><strong>FilenameFilter和FileFilter都是用来过滤文件的</strong></p>
<p><strong>例如：</strong></p>
<p>过滤以.jpg或者.java结尾的文件。</p>
<p>通过看他们的源码：</p>
<blockquote>
<p>通过<strong>使用File类</strong>中String[] list(FilenameFilter filter)或者public File[] listFiles(FileFilter filter)方法，把FilenameFilter或者FileFilter<strong>接口对象作为参数传入</strong>，通过实现接口里面的 boolean accept(File dir, String name) 或者boolean accept(File pathname)方法来<strong>过滤出满足条件的文件。</strong></p>
</blockquote>
<p><strong>区别：</strong>FilenameFilter的性能比FileFilter的好。</p>
<h2>File类</h2>
<ul>
<li>使用 String[] list(FilenameFilter filter)遍历指定目录下面，<strong>指定的后缀的文件。</strong></li>
</ul>
<h3>底层怎么实现过滤的？</h3>
<p><strong> String[] list(FilenameFilter filter)</strong><br />    原理：</p>
<ul>
<li>先把目录下面的文件调用list()方法全部存放到一个String[]数组里面，然后遍历数组</li>
<li>    把符合filter.accept(this, names[i])条件的放到一个ArrayList里面，然后把List转化为String[]数组</li>

</ul>
<p><strong> 底层源码解析：</strong></p>
<div class="cnblogs_code">
<pre>   <span style="color: #0000ff;">public</span><span style="color: #000000;"> String[] list(FilenameFilter filter) {
        String names[] </span>= list();<span style="color: #008000;">//</span><span style="color: #008000;">把所有目录文件列出来</span>
        <span style="color: #0000ff;">if</span> ((names == <span style="color: #0000ff;">null</span>) || (filter == <span style="color: #0000ff;">null</span>)) {<span style="color: #008000;">//</span><span style="color: #008000;">如果没有目录或者文件，返回null</span>
            <span style="color: #0000ff;">return</span><span style="color: #000000;"> names;
        }
        ArrayList v </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0 ; i &lt; names.length ; i++) {<span style="color: #008000;">//</span><span style="color: #008000;">找到文件，遍历</span>
            <span style="color: #0000ff;">if</span> (filter.accept(<span style="color: #0000ff;">this</span><span style="color: #000000;">, names[i])) {
            v.add(names[i]);</span>/<span style="color: #000000;">把满足条件的放到List集合中
            }
        }
        </span><span style="color: #0000ff;">return</span> (String[])(v.toArray(<span style="color: #0000ff;">new</span><span style="color: #000000;"> String[v.size()]));
    }</span></pre>
</div>
<p>&nbsp;</p>
<h2>&nbsp;FilenameFilter 接口</h2>
<p><strong>接口方法：</strong></p>
<ul>
<li>boolean accept(File dir,String name) 可以使用此方法列出指定目录下面的带有某些后缀的文件。</li>
</ul>
<p><strong> 参数：</strong></p>
<ul>
<li>dir - 被找到的文件所在的目录。</li>
<li>name - 文件的名称。</li>
</ul>
<p><strong> 返回：</strong></p>
<ul>
<li>当且仅当该名称应该包含在文件列表中时返回 true；否则返回 false。</li>
</ul>
<h3>代码：</h3>
<ul>
<li>需求找出某个路径下面以.java结尾的文件。</li>
</ul>
<p><strong>实现：</strong>FilenameFilter 接口</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.File;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FilenameFilter;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> FileterByJava <span style="color: #0000ff;">implements</span><span style="color: #000000;"> FilenameFilter {
    
    </span><span style="color: #0000ff;">private</span> String caiName;<span style="color: #008000;">//</span><span style="color: #008000;">传入过滤的名称</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> FileterByJava(String caiName){
        </span><span style="color: #0000ff;">this</span>.caiName =<span style="color: #000000;"> caiName;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> accept(File dir, String name) {
        </span><span style="color: #008000;">System.out.println("dir"+dir+"_____"+"name"+name);</span><span style="color: #008000;">//</span><span style="color: #008000;">返回dir：D:\cai\Test_____name：a.txt</span>
<span style="color: #000000;">    }

}<br /></span></pre>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.File;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FilenameFilter;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FileListFilter {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        ListFileFileterByjava();
    }
 
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     使用实现FilenameFilter接口的方法，
     过滤String[] list(FilenameFilter filter)
     文件名过滤
     </span><span style="color: #008000;">*/</span>
     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> ListFileFileterByjava(){
         File f </span>= <span style="color: #0000ff;">new</span> File("D:"+File.separator+"cai"+File.separator+"Test"<span style="color: #000000;">);
         String[] fileNames </span>= f.list(<span style="color: #0000ff;">new</span> FileterByJava(".java"));<span style="color: #008000;">//</span><span style="color: #008000;">使用具体对象，把过滤后的以.java文件的文件放到数组当中</span>
         System.out.println(fileNames.length);<span style="color: #008000;">//</span><span style="color: #008000;">含有.java文件数组的长度</span>
         <span style="color: #0000ff;">for</span>(String name:fileNames){<span style="color: #008000;">//</span><span style="color: #008000;">遍历找到的.java文件</span>
<span style="color: #000000;">             System.out.println(name);
         }
            
     }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
      列出指定目录下，后缀为.java的文件，使用方法String[] list(FilenameFilter filter)使用匿名内部类的方法
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> ListFileNameFileter(){
        File f </span>= <span style="color: #0000ff;">new</span> File("D:"+File.separator+"cai"+File.separator+"Test"<span style="color: #000000;">);
        String[] files </span>= f.list(<span style="color: #0000ff;">new</span> FilenameFilter() {<span style="color: #008000;">//</span><span style="color: #008000;">使用匿名内部类的方法</span>
<span style="color: #000000;">            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> accept(File dir, String name) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub
                </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println("dir:"+dir+"name....."+name);</span><span style="color: #008000;">//</span><span style="color: #008000;">测试说明dir表示指定目录,name表示指定目录的名称</span>
                <span style="color: #0000ff;">return</span> name.endsWith(".java");<span style="color: #008000;">//</span><span style="color: #008000;">通过匿名内部类的返回值来控制指定目录下面的文件和文件夹的显示，只显示.java文件</span>
<span style="color: #000000;">            }
        });
        System.out.println(files.length);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历指定目录下面的文件和目录</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;">(String file:files){
            System.out.println(file);
        }
    }
}</span>&nbsp;</pre>
</div>
</div>
<p>&nbsp;</p>
<h2>FileFilter接口</h2>
<p><strong>接口方法：</strong></p>
<ul>
<li>&nbsp;boolean accept(File dir,String name) 可以使用此方法列出指定目录下面的带有某些后缀的文件。</li>
</ul>
<p><strong> 参数：</strong></p>
<ul>
<li>dir - 被找到的文件所在的目录。</li>
<li>name - 文件的名称。</li>
</ul>
<p><strong> 返回：</strong><br />    当且仅当该名称应该包含在文件列表中时返回 true；否则返回 false。</p>
<h3>代码</h3>
<p><strong>需求：</strong>现在要求输入一个文件的目录，之后将里面所有的备份文件删除，备份文件都是以&ldquo;.bak&rdquo;或".BAK"结尾，也就是说过滤文件类型为.bak或者.BAK文件后进行删除.</p>
<p>使用FileFilter内部类的方法，进行操作：</p>
<p><strong>代码：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.File;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FileFilter;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        File dir </span>= <span style="color: #0000ff;">new</span> File("D:\\caidir"<span style="color: #000000;">);
        ListFileFileter(dir);
    }
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
     　现在要求输入一个文件的目录，之后将里面所有的备份文件删除，备份文件都是以&ldquo;.bak&rdquo;或".BAK"结尾，过滤文件类型为.bak文件
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> ListFileFileter(File dir){
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(dir.exists()){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名内部类，把FileFilter接口对象作为参数</span>
            File[] files = dir.listFiles(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FileFilter() {
                @Override
                </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> accept(File pathname) {
                    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(pathname.isDirectory()){
                        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    }
                    String name </span>= pathname.getName();<span style="color: #008000;">//</span><span style="color: #008000;">获取文件的名称D:\caidir\a.bak</span>
                    System.out.println("****************"+<span style="color: #000000;">pathname);
                    </span><span style="color: #0000ff;">return</span> name.endsWith(".bak")|| name.endsWith(".BAK");<span style="color: #008000;">//</span><span style="color: #008000;">过滤文件类型为.bak或者.BAK文件，而不包含.BAK或者.bak的文件</span>
<span style="color: #000000;">                }
            });
           </span><span style="color: #008000;">//</span><span style="color: #008000;">深度遍历文件，递归</span>
            <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;files.length;i++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(files[i].isFile()){<span style="color: #008000;">//</span><span style="color: #008000;">如果遍历到的是文件，直接删除</span>
<span style="color: #000000;">                    files[i].delete();
                }</span><span style="color: #0000ff;">else</span>{<span style="color: #008000;">//</span><span style="color: #008000;">还是目录，继续遍历，直到是文件，再删除</span>
<span style="color: #000000;">                    ListFileFileter(files[i]);
                }
            }
        }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RuntimeException("操作的文件或者目录不存在！"<span style="color: #000000;">);
        }
    }
}<br /></span></pre>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
第二中方法实现接口，使用真实类的对象:
</span><span style="color: #008000;">*/</span>

<span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.File;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FileFilter;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FilenameFilter;
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 
 * 需求：输入一个文件目录，之后将里面所有备份的文件删除，备份文件都是以".bak" 和".BAK"结尾
 *
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> FileterByFile <span style="color: #0000ff;">implements</span><span style="color: #000000;"> FileFilter {

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> accept(File pathname) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(pathname.isDirectory()){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        String name </span>=<span style="color: #000000;"> pathname.getName();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub</span>
        System.out.println("****************"+<span style="color: #000000;">pathname);
        </span><span style="color: #0000ff;">return</span> name.endsWith(".bak")|| name.endsWith(".BAK"<span style="color: #000000;">);
    }
    
}</span></pre>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.File;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.io.FileFilter;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FileFilterDemo {

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        File dir </span>= <span style="color: #0000ff;">new</span> File("E:\\复件 demodir"<span style="color: #000000;">);
        ListFileFileterBak(dir);
    }
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 删除满足条件的文件
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> dir
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> ListFileFileterBak(File dir){
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(dir.exists()){
            File[] files </span>= dir.listFiles(<span style="color: #0000ff;">new</span> FileterByFile());<span style="color: #008000;">//</span><span style="color: #008000;">使用过滤</span>
            <span style="color: #0000ff;">for</span><span style="color: #000000;">(File file:files){
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(file.isDirectory()){
                    ListFileFileterBak(file);
                }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
                    file.delete();
                }
            }
        }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RuntimeException("操作的文件或者目录不存在！"<span style="color: #000000;">);
        }
    }
}</span></pre>
</div>
</div>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：File类</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11326624.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 09 Aug 2019 05:22:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/09/11326624.html</guid><description><![CDATA[<h1 style="text-align: center;">Java学习：File类</h1>
<ul>
<li>File类的概述</li>
<li>重点：记住这三个单词</li>
<li>绝对路径和相对路径</li>
<li>File类的构造方法</li>
<li>File类判断功能的方法</li>
<li>File类创建删除功能的方法</li>
<li>File类获取（文件夹）目录和文件夹相关功能</li>
</ul>
<h2>File类的概述</h2>
<p>Java语言定义了许多类专门负责各种方式的输入或者输出，这些类都被放在<strong>java.io包</strong>中。<br /><strong>其中：</strong></p>
<ol>
<li>所有<strong>输入流</strong>类都是抽象类<strong>InputStream(字节输入流)</strong>，或者抽象类<strong>Reader(字符输入流)</strong>的子类；</li>
<li>而所有<strong>输出流</strong>都是抽象类<strong>OutputStream(字节输出流)</strong>或者<strong>Writer(字符输出流)的子类</strong>。</li>


</ol>
<h3>首先需要明白的是：<strong>流是干什么的？</strong></h3>
<ul>
<li>为了永久性的保存数据</li>
<li>根据数据流向的不同分为输入流和输出流；</li>
<li>根据处理数据类型的不同分为字符流和字节流；</li>


</ul>
<h3>然后需要明白的是输入模式和输出模式是谁流向谁：</h3>
<ol>
<li><strong>InputStream(字节输入流)</strong>和Reader(字符输入流)通俗的理解都是读（read）的。</li>
<li><strong>OutputStream(字节输出流)</strong>和Writer(字符输出流)通俗的理解都是写(writer)的。</li>


</ol>
<p>&nbsp;</p>
<h2>重点：记住这三个单词</h2>
<ul>
<li><strong>file:文件</strong></li>
<li><strong>directory：文件夹/目录</strong></li>
<li><strong>path：路径</strong></li>


</ul>
<p>&nbsp;</p>
<h2>绝对路径和相对路径</h2>
<p><strong>路径：</strong></p>
<ul>
<li><strong>	绝对路径：是一个完整的路径</strong></li>


</ul>
<ol>
<li>		以盘符（c:,D:)开始的路径</li>
<li>		D:\\Users\\cai\\a.txt</li>


</ol>
<ul>
<li><strong>	相对路径:是一个简化的路径</strong></li>


</ul>
<ol>
<li>		相对指的是相对于当前项目的根目录，路径可以简化书写</li>
<li>		D:\\Users\\cai\\a.txt--&gt;简化为：a.txt</li>


</ol>
<p><strong>注意：</strong></p>
<ol>
<li>路径是<strong>不区分大小写的</strong></li>
<li>路径中的文件名称分隔符windows使用反斜杠，<strong>反斜杠是转义字符，两反斜杠代表一个普通的反斜杠</strong></li>


</ol>
<h2><br />File类的构造方法</h2>
<p><strong>File类</strong></p>
<p><strong>位于java.io包</strong></p>
<h3>构造方法：</h3>
<div class="cnblogs_code">
<pre>File(String parent, String child)<span style="color: #008000;">//</span><span style="color: #008000;">根据一个目录和一个子文件/目录得到File对象</span>
<span style="color: #0000ff;">new</span> file("d:\\","a.txt"<span style="color: #000000;">);

File(String pathname) </span><span style="color: #008000;">//</span><span style="color: #008000;">根据一个路径得到File对象</span>
<span style="color: #0000ff;">new</span> file("d:\\a.txt"<span style="color: #000000;">);

File(File parent, String child)</span><span style="color: #008000;">//</span><span style="color: #008000;">根据一个父File对象和一个子文件/目录得到File对象</span>
File f = <span style="color: #0000ff;">new</span> File("d:\\"<span style="color: #000000;">);
File f1</span>=<span style="color: #0000ff;">new</span> File(f,"a.txt");&nbsp;</pre>
</div>
<p>&nbsp;</p>
<h2>File类判断功能的方法</h2>
<h3>File类(File类的判断功能)</h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">　　A:判断功能
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isDirectory():判断是否是目录
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isFile():判断是否是文件
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> exists():判断是否存在
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> canRead():判断是否可读
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> canWrite():判断是否可写
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> isHidden():判断是否隐藏</pre>
</div>
<h2>File类创建删除功能的方法</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">A:创建功能
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> createNewFile():创建文件 如果存在这样的文件，就不创建了
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> mkdir():创建文件夹 如果存在这样的文件夹，就不创建了
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来</pre>
</div>
<ul>
<li>使用createNewFile()文件创建的时候不加.txt或者其他后缀也是文件，不是文件夹；使用mkdir()创建文件夹的时候，如果起的名字是比如aaa.txt也是文件夹不是文件；</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。</li>
</ul>
<h3><br />File类(File类的重命名和删除功能)</h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    A:重命名和删除功能
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> renameTo(File dest):把文件重命名为指定的文件路径
　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> delete():删除文件或者文件夹
　　B:重命名注意事项
　　　　如果路径名相同，就是改名。
　　　　如果路径名不同，就是改名并剪切。
　　C:删除注意事项：
　　　　Java中的删除不走回收站。
　　　　要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹    </span></pre>
</div>
<h2>File类获取（文件夹）目录和文件夹相关功能</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">获取功能:
  getName() 获取文件或文件夹的名称，不包含上级路径。
  getAbsolutePath()获取文件的绝对路径，与文件是否存在没关系
  length() 获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。
  getParent() 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。
  lastModified()获取最后一次被修改的时间。</span></pre>
</div>
<h2>文件夹相关功能</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">static</span><span style="color: #000000;"> File[] listRoots()列出所有的根目录（Window中就是所有系统的盘符）
list() 返回目录下的文件或者目录名，包含隐藏文件。对于文件这样操作会返回null。
listFiles() 返回目录下的文件或者目录对象（File类实例），包含隐藏文件。对于文件这样操作会返回null。
list(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。
listFiles(FilenameFilter filter)返回指定当前目录中符合过滤条件的子文件或子目录。对于文件这样操作会返回null。<br /></span></pre>
</div>
<h2>测试代码</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">createFileMethod();</span>
<span style="color: #000000;">        listRoots();
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建文件</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> createFileMethod(){
        File file </span>= <span style="color: #0000ff;">new</span> File("file.txt"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">boolean</span> b =<span style="color: #000000;"> file.createNewFile();
            System.out.print(b);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建临时文件</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> createTempFileMethod(){
        File dir </span>= <span style="color: #0000ff;">new</span> File("D:\\"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            File b </span>= File.createTempFile("test", ".tmp",dir);<span style="color: #008000;">//</span><span style="color: #008000;">使用指定目录的方法</span>
<span style="color: #000000;">            System.out.print(b.getAbsolutePath());
            File b1 </span>= File.createTempFile("tmp2", <span style="color: #0000ff;">null</span>);<span style="color: #008000;">//</span><span style="color: #008000;">使用不指定目录的构造方法</span>
<span style="color: #000000;">            System.out.print(b1.getAbsolutePath());
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建目录</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> createDirMethod(){
        File dir </span>= <span style="color: #0000ff;">new</span> File("d:"+File.separator+"dfr"+File.separator+"ddd"<span style="color: #000000;">);
        File dir1 </span>= <span style="color: #0000ff;">new</span> File("d:"+File.separator+"dff"+File.separator+"ddd"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">boolean</span> b = dir.mkdirs();<span style="color: #008000;">//</span><span style="color: #008000;">可以递归的创建不存在的目录</span>
        <span style="color: #0000ff;">boolean</span> b1 = dir1.mkdir();<span style="color: #008000;">//</span><span style="color: #008000;">创建目录，不能递归，只能创建一级目录</span>
<span style="color: #000000;">        System.out.println(b);
        System.out.println(b1);
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">删除文件</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> deleteFileMethod(){
        File file </span>= <span style="color: #0000ff;">new</span> File("file.txt"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">boolean</span> b =<span style="color: #000000;"> file.createNewFile();
            System.out.print(b);
            file.deleteOnExit();
            file.delete();
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (IOException e) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated catch block</span>
<span style="color: #000000;">            e.printStackTrace();
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">判断文件对象或者目录是否是文件或者目录时候，必须判断该文件是否存在</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> IsDirOrFileMethod() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException{
        File file  </span>= <span style="color: #0000ff;">new</span> File("a.txt"<span style="color: #000000;">);
        File file1  </span>= <span style="color: #0000ff;">new</span> File("d:"+File.separator+"hhh"<span style="color: #000000;">);
        file.createNewFile();
        file1.mkdir();
        System.out.println(</span>"是否存在"+<span style="color: #000000;">file.exists());
        System.out.println(</span>"是否是文件"+<span style="color: #000000;">file.isFile());
        System.out.println(</span>"是否是目录"+<span style="color: #000000;">file.isDirectory());
        System.out.println(</span>"是否是隐藏"+<span style="color: #000000;">file.isHidden());
        System.out.println(</span>"目录是否为绝对目录名"+<span style="color: #000000;">file1.isAbsolute());
        System.out.println(</span>"file对象对应的文件目录是否可write: "+<span style="color: #000000;">file1.canWrite());
        System.out.println(</span>"file对象对应的文件目录是否可read: "+<span style="color: #000000;">file1.canRead());
        System.out.println(</span>"file对象对应的文件目录是否可Execute: "+<span style="color: #000000;">file1.canExecute());
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">获取的方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> getMehtod(){
        File file </span>= <span style="color: #0000ff;">new</span> File("E:\\file2.txt"<span style="color: #000000;">);
        File dir </span>= <span style="color: #0000ff;">new</span> File("abc"<span style="color: #000000;">);
        System.out.println(</span>"获取抽象路径名转化为路径名字字符串："+file.getPath());<span style="color: #008000;">//</span><span style="color: #008000;">E:\file2.txt</span>
        System.out.println("获取此File对象对应的绝对路径名："+file.getAbsolutePath());<span style="color: #008000;">//</span><span style="color: #008000;">E:\file2.txt</span>
        System.out.println("获取此File对象的所对应目录（最后一级子目录（绝对路径））的父目录名："+file.getParent());<span style="color: #008000;">//</span><span style="color: #008000;">E:\</span>
        System.out.println("获取此File对象最后修改时间："+file.lastModified());<span style="color: #008000;">//</span><span style="color: #008000;">1405853667765,修改日期的毫秒数</span>
<span style="color: #000000;">    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">相当于重命名剪切</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> renameFile() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> IOException{
        File f1 </span>= <span style="color: #0000ff;">new</span> File("D:\\file.txt"<span style="color: #000000;">);
        File f2 </span>= <span style="color: #0000ff;">new</span> File("E:\\file2.txt"<span style="color: #000000;">);
        System.out.println(</span>"f1重命名为f2的名字"+<span style="color: #000000;">f1.renameTo(f2));
        </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println("f2重命名为f1的名字"+f2.renameTo(f1));</span>
<span style="color: #000000;">    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">列出根目录的全部内容</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> listRoots(){
        File[] files </span>=<span style="color: #000000;"> File.listRoots();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(File file:files){
            System.out.println(</span>"列出根目录："+<span style="color: #000000;">file);
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">列出指定的目录的全部内容,包括隐藏文件，文件夹的名字和文件的名字</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> listDemo(){
        File f </span>= <span style="color: #0000ff;">new</span> File("d:\\"<span style="color: #000000;">);
        System.out.println(</span>"获取D盘的可用空间"+<span style="color: #000000;">f.getFreeSpace());
        System.out.println(</span>"获取D盘的可用于虚拟机的空间"+<span style="color: #000000;">f.getUsableSpace());
        System.out.println(</span>"获取D盘的总容量"+<span style="color: #000000;">f.getTotalSpace());
        String[] files </span>=<span style="color: #000000;"> f.list();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(String file:files){
            System.out.println(</span>"列出根目录："+<span style="color: #000000;">file);
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">列出指定的目录的全部内容,包括隐藏文件，文件夹的名字和文件的名字</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> listFileterDemo(){
        File f </span>= <span style="color: #0000ff;">new</span> File("d:\\"<span style="color: #000000;">);
        String[] files </span>=<span style="color: #000000;"> f.list();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(String file:files){
            System.out.println(</span>"列出根目录："+<span style="color: #000000;">file);
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">列出指定的目录的全部内容,包括隐藏文件，文件夹的名字和文件的名字,使用 File[] listFiles() 
    </span><span style="color: #008000;">//</span><span style="color: #008000;">返回值为一个File对象</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> listFileDemo(){
        File f </span>= <span style="color: #0000ff;">new</span> File("d:\\"<span style="color: #000000;">);
        File[] files </span>=<span style="color: #000000;"> f.listFiles();
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;">(File file:files){
            System.out.println(</span>"列出根目录："+<span style="color: #000000;">file.getName());
        }
    }
    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 列出指定目录下，后缀为.java的文件，使用方法String[] list(FilenameFilter filter)
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> ListFileFileter(){
        File f </span>= <span style="color: #0000ff;">new</span> File("E:"+File.separator+"workspace"+File.separator+"IOTest"<span style="color: #000000;">);
        String[] files </span>= f.list(<span style="color: #0000ff;">new</span><span style="color: #000000;"> FilenameFilter() {
            
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> accept(File dir, String name) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> TODO Auto-generated method stub
                </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println("dir:"+dir+"name....."+name);</span><span style="color: #008000;">//</span><span style="color: #008000;">说明dir表示指定目录,name表示指定目录的名称</span>
                <span style="color: #0000ff;">return</span> name.endsWith(".java");<span style="color: #008000;">//</span><span style="color: #008000;">通过匿名内部类的返回值来控制指定目录下面的文件和文件夹的显示</span>
<span style="color: #000000;">            }
        });
        System.out.println(files.length);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历指定目录下面的文件和目录</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;">(String file:files){
            System.out.println(file);
        }
    }
     
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：递归</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/08/11320972.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 08 Aug 2019 06:34:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/08/11320972.html</guid><description><![CDATA[<h2>递归的思想</h2>
<p><strong>以此类推是递归的基本思想。</strong></p>
<blockquote>
<p>具体来讲就是把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况。另外这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况了。</p>
</blockquote>
<h3>递归的两个条件</h3>
<ol>
<li>可以通过递归调用来缩小问题规模，且新问题与原问题有着相同的形式。（自身调用）</li>
<li>存在一种简单情境，可以使递归在简单情境下退出。（递归出口）</li>
</ol>
<h3>递归三要素：</h3>
<ol>
<li>一定有一种可以退出程序的情况；</li>
<li>总是在尝试将一个问题化简到更小的规模</li>
<li>父问题与子问题不能有重叠的部分</li>
</ol>
<h3>递归：自已（方法）调用自已</h3>
<p><strong>例子：</strong>用递归把目录下所有的目录及文件全部显示出来</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> B {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        File file </span>= <span style="color: #0000ff;">new</span> File("f:\\123"<span style="color: #000000;">);
        listAllFile(file);
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> listAllFile(File file) {
        File[] strs </span>=<span style="color: #000000;"> file.listFiles();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; strs.length; i++<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 判断strs[i]是不是目录</span>
            <span style="color: #0000ff;">if</span><span style="color: #000000;"> (strs[i].isDirectory()) {
                listAllFile(strs[i]);</span><span style="color: #008000;">//</span><span style="color: #008000;">递归调用自己</span>
                System.out.println("目录="+<span style="color: #000000;">strs[i].getName());
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                System.out.println(</span>"文件名="+<span style="color: #000000;">strs[i].getName());
            }
        }    
    }
}</span></pre>
</div>
<h3>递归算法的一般形式：</h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">func( mode){
    </span><span style="color: #0000ff;">if</span>(endCondition){      <span style="color: #008000;">//</span><span style="color: #008000;">递归出口</span>
<span style="color: #000000;">          end;
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
         func(mode_small)  </span><span style="color: #008000;">//</span><span style="color: #008000;">调用本身，递归</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<h3>例子</h3>
<p>求一个数的阶乘是练习简单而典型的例子，阶乘的递推公式为：factorial(n)=n*factorial(n-1)，其中n为非负整数,且0!=1,1!=1</p>
<p>我们根据<strong>递推公式</strong>可以轻松的写出其递归函数：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">long</span> factorial(<span style="color: #0000ff;">int</span> n) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
    </span><span style="color: #0000ff;">if</span> (n &lt; 0<span style="color: #000000;">)
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Exception("参数不能为负！"<span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (n == 1 || n == 0<span style="color: #000000;">)
        </span><span style="color: #0000ff;">return</span> 1<span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span>
        <span style="color: #0000ff;">return</span> n * factorial(n - 1<span style="color: #000000;">);
}</span></pre>
</div>
<h2>递归的过程</h2>
<p>在求解6的阶乘时，递归过程如下所示。</p>
<p><a href="http://images2015.cnblogs.com/blog/776887/201605/776887-20160505194608060-952305852.png"><img style="display: block; margin-left: auto; margin-right: auto;" title="clip_image001" src="https://images2015.cnblogs.com/blog/776887/201605/776887-20160505194608810-1299826416.png" alt="clip_image001" width="465" height="302" border="0" /></a></p>
<p>我们会惊奇的发现这个过程和栈的工作原理一致对，递归调用就是通过栈这种数据结构完成的。整个过程实际上就是一个栈的入栈和出栈问题。然而我们并不需要关心这个栈的实现，这个过程是由系统来完成的。</p>
<p><strong>那么递归中的&ldquo;递&rdquo;就是入栈，递进；&ldquo;归&rdquo;就是出栈，回归。</strong></p>
<p>我们可以通过一个更简单的程序来模拟递进和回归的过程：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
 关于 递归中 递进和回归的理解</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> recursion_display(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
    </span><span style="color: #0000ff;">int</span> temp=n;<span style="color: #008000;">//</span><span style="color: #008000;">保证前后打印的值一样</span>
     System.out.println("递进:" +<span style="color: #000000;"> temp);
    </span><span style="color: #0000ff;">if</span> (n &gt; 0<span style="color: #000000;">) {
        recursion_display(</span>--<span style="color: #000000;">n);
    }
    System.out.println(</span>"回归:" +<span style="color: #000000;"> temp);
}</span></pre>
</div>
<h2>递归的例子</h2>
<p><strong><span style="font-size: small;">斐波那契数列</span></strong></p>
<p>斐波那契数列的递推公式:Fib(n)=Fib(n-1)+Fib(n-2)，指的是如下所示的数列：</p>
<p>1、1、2、3、5、8、13、21.....</p>
<p>按照其递推公式写出的递归函数如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> fib(<span style="color: #0000ff;">int</span> n) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
    </span><span style="color: #0000ff;">if</span> (n &lt; 0<span style="color: #000000;">)
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Exception("参数不能为负！"<span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (n == 0 || n == 1<span style="color: #000000;">)
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
    </span><span style="color: #0000ff;">else</span>
        <span style="color: #0000ff;">return</span> fib(n - 1) + fib(n - 2<span style="color: #000000;">);
}</span></pre>
</div>
<p>&nbsp;递归调用的过程像树一样，通过观察会发现有很多重复的调用。</p>
<p>&nbsp;</p>
<p><a href="http://images2015.cnblogs.com/blog/776887/201605/776887-20160505194833732-748763325.png"><img style="display: block; margin-left: auto; margin-right: auto;" title="image" src="https://images2015.cnblogs.com/blog/776887/201605/776887-20160505194834732-395025199.png" alt="image" width="573" height="397" border="0" /></a></p>
<h2>归并排序</h2>
<p>归并排序也是递归的典型应用，其思想：将序列分为若干有序序列（开始为单个记录），两个相邻有序的序列合并成一个有序的序列，以此类推，直到整个序列有序。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">递归过程是：在递进的过程中拆分数组，在回归的过程合并数组</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> mergeSort(<span style="color: #0000ff;">int</span>[] source, <span style="color: #0000ff;">int</span>[] temp, <span style="color: #0000ff;">int</span> first, <span style="color: #0000ff;">int</span><span style="color: #000000;"> last) {
    </span><span style="color: #0000ff;">if</span> (first &lt;<span style="color: #000000;"> last) {
        </span><span style="color: #0000ff;">int</span> mid = (first + last) / 2<span style="color: #000000;">;
        mergeSort(source, temp, first, mid);    </span><span style="color: #008000;">//</span><span style="color: #008000;">归并排序前半个子序列</span>
        mergeSort(source, temp, mid + 1, last); <span style="color: #008000;">//</span><span style="color: #008000;">归并排序后半个子序列</span>
        merge(source, temp, first, mid, last);    <span style="color: #008000;">//</span><span style="color: #008000;">在回归过程中合并</span>
    } <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (first == last) {                    <span style="color: #008000;">//</span><span style="color: #008000;">待排序列只有一个，递归结束</span>
        temp[first] =<span style="color: #000000;"> source[first];
    }
}</span></pre>
</div>
<p>同样调用过程向树一样，但是它并没有重复调用的问题。在递进的过程中拆分数组，在回归的过程合并数组 。通过递归来实现归并排序，程序结构和条理非常清晰。</p>
<p><a href="http://images2015.cnblogs.com/blog/776887/201605/776887-20160505194835841-942659554.png"><img style="display: block; margin-left: auto; margin-right: auto;" title="clip_image002" src="https://images2015.cnblogs.com/blog/776887/201605/776887-20160505194836638-640594128.png" alt="clip_image002" width="469" height="434" border="0" /></a></p>
<p>&nbsp;</p>]]></description></item><item><title>关于颜色的十六进制对照表</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/05/11301471.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 05 Aug 2019 02:26:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/05/11301471.html</guid><description><![CDATA[<h1 style="text-align: center;">关于颜色的十六进制对照表</h1>
<p><strong>便于查找&nbsp; &nbsp; ctrl+F</strong></p>
<h2 style="text-align: center;">图片查找</h2>
<p><img style="display: block; margin-left: auto; margin-right: auto;" title="颜色对照表" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190805103542475-790843235.jpg" alt="https://www.cnblogs.com/cainiao-chuanqi/p/11301471.html" width="666" height="751" /></p>
<h3 style="text-align: center;">查找颜色</h3>
<table cellspacing="1" cellpadding="1" align="center">
<tbody>
<tr>
<td>
<table style="height: 1425px; width: 163px;" border="0" cellspacing="2" cellpadding="2">
<tbody>
<tr>
<td style="text-align: center;" bgcolor="#336699"><span style="background-color: #ffffff; color: #000000;"><strong>16位进制代码</strong></span></td>
<td style="text-align: center;" bgcolor="#336699"><span style="background-color: #ffffff; color: #000000;"><strong>颜色效果</strong></span></td>
</tr>
<tr>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFFFFF</td>
<td style="text-align: center;" bgcolor="#ffffff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFFFCC</td>
<td style="text-align: center;" bgcolor="#ffffcc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFFF99</td>
<td style="text-align: center;" bgcolor="#ffff99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFFF66</td>
<td style="text-align: center;" bgcolor="#ffff66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFFF33</td>
<td style="text-align: center;" bgcolor="#ffff33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFFF00</td>
<td style="text-align: center;" bgcolor="#ffff00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFCCFF</td>
<td style="text-align: center;" bgcolor="#ffccff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFCCCC</td>
<td style="text-align: center;" bgcolor="#ffcccc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFCC99</td>
<td style="text-align: center;" bgcolor="#ffcc99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFCC66</td>
<td style="text-align: center;" bgcolor="#ffcc66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFCC33</td>
<td style="text-align: center;" bgcolor="#ffcc33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FFCC00</td>
<td style="text-align: center;" bgcolor="#ffcc00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF99FF</td>
<td style="text-align: center;" bgcolor="#ff99ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF99CC</td>
<td style="text-align: center;" bgcolor="#ff99cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF9999</td>
<td style="text-align: center;" bgcolor="#ff9999">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF9966</td>
<td style="text-align: center;" bgcolor="#ff9966">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF9933</td>
<td style="text-align: center;" bgcolor="#ff9933">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF9900</td>
<td style="text-align: center;" bgcolor="#ff9900">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF66FF</td>
<td style="text-align: center;" bgcolor="#ff66ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF66CC</td>
<td style="text-align: center;" bgcolor="#ff66cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF6699</td>
<td style="text-align: center;" bgcolor="#ff6699">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF6666</td>
<td style="text-align: center;" bgcolor="#ff6666">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF6633</td>
<td style="text-align: center;" bgcolor="#ff6633">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF6600</td>
<td style="text-align: center;" bgcolor="#ff6600">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF33FF</td>
<td style="text-align: center;" bgcolor="#ff33ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF33CC</td>
<td style="text-align: center;" bgcolor="#ff33cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF3399</td>
<td style="text-align: center;" bgcolor="#ff3399">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF3366</td>
<td style="text-align: center;" bgcolor="#ff3366">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF3333</td>
<td style="text-align: center;" bgcolor="#ff3333">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF3300</td>
<td style="text-align: center;" bgcolor="#ff3300">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF00FF</td>
<td style="text-align: center;" bgcolor="#ff00ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF00CC</td>
<td style="text-align: center;" bgcolor="#ff00cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF0099</td>
<td style="text-align: center;" bgcolor="#ff0099">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF0066</td>
<td style="text-align: center;" bgcolor="#ff0066">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF0033</td>
<td style="text-align: center;" bgcolor="#ff0033">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#FF0000</td>
<td style="text-align: center;" bgcolor="#ff0000">&nbsp;</td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;" bgcolor="#336699"><span style="background-color: #c0c0c0;"><strong>Hex Code</strong></span></td>
<td style="text-align: center;" bgcolor="#336699"><span style="background-color: #c0c0c0;"><strong>Color</strong></span></td>
</tr>
<tr>
<td style="text-align: center;">#66FFFF</td>
<td style="text-align: center;" bgcolor="#66ffff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66FFCC</td>
<td style="text-align: center;" bgcolor="#66ffcc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66FF99</td>
<td style="text-align: center;" bgcolor="#66ff99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66FF66</td>
<td style="text-align: center;" bgcolor="#66ff66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66FF33</td>
<td style="text-align: center;" bgcolor="#66ff33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66FF00</td>
<td style="text-align: center;" bgcolor="#66ff00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66CCFF</td>
<td style="text-align: center;" bgcolor="#66ccff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66CCCC</td>
<td style="text-align: center;" bgcolor="#66cccc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66CC99</td>
<td style="text-align: center;" bgcolor="#66cc99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66CC66</td>
<td style="text-align: center;" bgcolor="#66cc66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66CC33</td>
<td style="text-align: center;" bgcolor="#66cc33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#66CC00</td>
<td style="text-align: center;" bgcolor="#66cc00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6699FF</td>
<td style="text-align: center;" bgcolor="#6699ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6699CC</td>
<td style="text-align: center;" bgcolor="#6699cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#669999</td>
<td style="text-align: center;" bgcolor="#669999">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#669966</td>
<td style="text-align: center;" bgcolor="#669966">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#669933</td>
<td style="text-align: center;" bgcolor="#669933">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#669900</td>
<td style="text-align: center;" bgcolor="#669900">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6666FF</td>
<td style="text-align: center;" bgcolor="#6666ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6666CC</td>
<td style="text-align: center;" bgcolor="#6666cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#666699</td>
<td style="text-align: center;" bgcolor="#666699">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#666666</td>
<td style="text-align: center;" bgcolor="#666666">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#666633</td>
<td style="text-align: center;" bgcolor="#666633">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#666600</td>
<td style="text-align: center;" bgcolor="#666600">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6633FF</td>
<td style="text-align: center;" bgcolor="#6633ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6633CC</td>
<td style="text-align: center;" bgcolor="#6633cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#663399</td>
<td style="text-align: center;" bgcolor="#663399">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#663366</td>
<td style="text-align: center;" bgcolor="#663366">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#663333</td>
<td style="text-align: center;" bgcolor="#663333">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#663300</td>
<td style="text-align: center;" bgcolor="#663300">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6600FF</td>
<td style="text-align: center;" bgcolor="#6600ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#6600CC</td>
<td style="text-align: center;" bgcolor="#6600cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#660099</td>
<td style="text-align: center;" bgcolor="#660099">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#660066</td>
<td style="text-align: center;" bgcolor="#660066">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#660033</td>
<td style="text-align: center;" bgcolor="#660033">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#660000</td>
<td style="text-align: center;" bgcolor="#660000">&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
</td>
<td>&nbsp;</td>
<td valign="top">
<table style="height: 1416px; width: 163px;" border="0" cellspacing="2" cellpadding="2">
<tbody>
<tr>
<td style="text-align: center;" bgcolor="#336699"><span style="background-color: #ffffff; color: #000000;"><strong>16位进制代码</strong></span></td>
<td style="text-align: center;" bgcolor="#336699"><span style="background-color: #ffffff; color: #000000;"><strong>颜色效果</strong></span></td>
</tr>
<tr>
<td style="text-align: center;">&nbsp;</td>
<td style="text-align: center;">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCFFFF</td>
<td style="text-align: center;" bgcolor="#ccffff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCFFCC</td>
<td style="text-align: center;" bgcolor="#ccffcc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCFF99</td>
<td style="text-align: center;" bgcolor="#ccff99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCFF66</td>
<td style="text-align: center;" bgcolor="#ccff66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCFF33</td>
<td style="text-align: center;" bgcolor="#ccff33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCFF00</td>
<td style="text-align: center;" bgcolor="#ccff00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCCCFF</td>
<td style="text-align: center;" bgcolor="#ccccff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCCCCC</td>
<td style="text-align: center;" bgcolor="#cccccc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCCC99</td>
<td style="text-align: center;" bgcolor="#cccc99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCCC66</td>
<td style="text-align: center;" bgcolor="#cccc66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCCC33</td>
<td style="text-align: center;" bgcolor="#cccc33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CCCC00</td>
<td style="text-align: center;" bgcolor="#cccc00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC99FF</td>
<td style="text-align: center;" bgcolor="#cc99ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC99CC</td>
<td style="text-align: center;" bgcolor="#cc99cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC9999</td>
<td style="text-align: center;" bgcolor="#cc9999">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC9966</td>
<td style="text-align: center;" bgcolor="#cc9966">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC9933</td>
<td style="text-align: center;" bgcolor="#cc9933">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC9900</td>
<td style="text-align: center;" bgcolor="#cc9900">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC66FF</td>
<td style="text-align: center;" bgcolor="#cc66ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC66CC</td>
<td style="text-align: center;" bgcolor="#cc66cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC6699</td>
<td style="text-align: center;" bgcolor="#cc6699">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC6666</td>
<td style="text-align: center;" bgcolor="#cc6666">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC6633</td>
<td style="text-align: center;" bgcolor="#cc6633">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC6600</td>
<td style="text-align: center;" bgcolor="#cc6600">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC33FF</td>
<td style="text-align: center;" bgcolor="#cc33ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC33CC</td>
<td style="text-align: center;" bgcolor="#cc33cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC3399</td>
<td style="text-align: center;" bgcolor="#cc3399">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC3366</td>
<td style="text-align: center;" bgcolor="#cc3366">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC3333</td>
<td style="text-align: center;" bgcolor="#cc3333">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC3300</td>
<td style="text-align: center;" bgcolor="#cc3300">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC00FF</td>
<td style="text-align: center;" bgcolor="#cc00ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC00CC</td>
<td style="text-align: center;" bgcolor="#cc00cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC0099</td>
<td style="text-align: center;" bgcolor="#cc0099">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC0066</td>
<td style="text-align: center;" bgcolor="#cc0066">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC0033</td>
<td style="text-align: center;" bgcolor="#cc0033">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#CC0000</td>
<td style="text-align: center;" bgcolor="#cc0000">&nbsp;</td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr>
<td bgcolor="#336699"><span style="background-color: #c0c0c0;"><strong>Hex Code</strong></span></td>
<td bgcolor="#336699"><span style="background-color: #c0c0c0;"><strong>Color</strong></span></td>
</tr>
<tr>
<td style="text-align: center;">#33FFFF</td>
<td style="text-align: center;" bgcolor="#33ffff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33FFCC</td>
<td style="text-align: center;" bgcolor="#33ffcc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33FF99</td>
<td style="text-align: center;" bgcolor="#33ff99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33FF66</td>
<td style="text-align: center;" bgcolor="#33ff66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33FF33</td>
<td style="text-align: center;" bgcolor="#33ff33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33FF00</td>
<td style="text-align: center;" bgcolor="#33ff00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33CCFF</td>
<td style="text-align: center;" bgcolor="#33ccff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33CCCC</td>
<td style="text-align: center;" bgcolor="#33cccc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33CC99</td>
<td style="text-align: center;" bgcolor="#33cc99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33CC66</td>
<td style="text-align: center;" bgcolor="#33cc66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33CC33</td>
<td style="text-align: center;" bgcolor="#33cc33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#33CC00</td>
<td style="text-align: center;" bgcolor="#33cc00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3399FF</td>
<td style="text-align: center;" bgcolor="#3399ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3399CC</td>
<td style="text-align: center;" bgcolor="#3399cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#339999</td>
<td style="text-align: center;" bgcolor="#339999">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#339966</td>
<td style="text-align: center;" bgcolor="#339966">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#339933</td>
<td style="text-align: center;" bgcolor="#339933">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#339900</td>
<td style="text-align: center;" bgcolor="#339900">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3366FF</td>
<td style="text-align: center;" bgcolor="#3366ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3366CC</td>
<td style="text-align: center;" bgcolor="#3366cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#336699</td>
<td style="text-align: center;" bgcolor="#336699">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#336666</td>
<td style="text-align: center;" bgcolor="#336666">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#336633</td>
<td style="text-align: center;" bgcolor="#336633">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#336600</td>
<td style="text-align: center;" bgcolor="#336600">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3333FF</td>
<td style="text-align: center;" bgcolor="#3333ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3333CC</td>
<td style="text-align: center;" bgcolor="#3333cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#333399</td>
<td style="text-align: center;" bgcolor="#333399">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#333366</td>
<td style="text-align: center;" bgcolor="#333366">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#333333</td>
<td style="text-align: center;" bgcolor="#333333">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#333300</td>
<td style="text-align: center;" bgcolor="#333300">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3300FF</td>
<td style="text-align: center;" bgcolor="#3300ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#3300CC</td>
<td style="text-align: center;" bgcolor="#3300cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#330099</td>
<td style="text-align: center;" bgcolor="#330099">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#330066</td>
<td style="text-align: center;" bgcolor="#330066">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#330033</td>
<td style="text-align: center;" bgcolor="#330033">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#330000</td>
<td style="text-align: center;" bgcolor="#330000">&nbsp;</td>
</tr>
</tbody>
</table>
</td>
<td>&nbsp;</td>
<td valign="top">
<table style="height: 1416px; width: 175px;" border="0" cellspacing="2" cellpadding="2">
<tbody>
<tr>
<td bgcolor="#336699"><span style="background-color: #ffffff; color: #000000;"><strong>16位进制代码</strong></span></td>
<td bgcolor="#336699"><span style="background-color: #ffffff; color: #000000;"><strong>颜色效果</strong></span></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99FFFF</td>
<td style="text-align: center;" bgcolor="#99ffff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99FFCC</td>
<td style="text-align: center;" bgcolor="#99ffcc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99FF99</td>
<td style="text-align: center;" bgcolor="#99ff99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99FF66</td>
<td style="text-align: center;" bgcolor="#99ff66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99FF33</td>
<td style="text-align: center;" bgcolor="#99ff33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99FF00</td>
<td style="text-align: center;" bgcolor="#99ff00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99CCFF</td>
<td style="text-align: center;" bgcolor="#99ccff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99CCCC</td>
<td style="text-align: center;" bgcolor="#99cccc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99CC99</td>
<td style="text-align: center;" bgcolor="#99cc99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99CC66</td>
<td style="text-align: center;" bgcolor="#99cc66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99CC33</td>
<td style="text-align: center;" bgcolor="#99cc33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#99CC00</td>
<td style="text-align: center;" bgcolor="#99cc00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9999FF</td>
<td style="text-align: center;" bgcolor="#9999ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9999CC</td>
<td style="text-align: center;" bgcolor="#9999cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#999999</td>
<td style="text-align: center;" bgcolor="#999999">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#999966</td>
<td style="text-align: center;" bgcolor="#999966">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#999933</td>
<td style="text-align: center;" bgcolor="#999933">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#999900</td>
<td style="text-align: center;" bgcolor="#999900">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9966FF</td>
<td style="text-align: center;" bgcolor="#9966ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9966CC</td>
<td style="text-align: center;" bgcolor="#9966cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#996699</td>
<td style="text-align: center;" bgcolor="#996699">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#996666</td>
<td style="text-align: center;" bgcolor="#996666">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#996633</td>
<td style="text-align: center;" bgcolor="#996633">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#996600</td>
<td style="text-align: center;" bgcolor="#996600">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9933FF</td>
<td style="text-align: center;" bgcolor="#9933ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9933CC</td>
<td style="text-align: center;" bgcolor="#9933cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#993399</td>
<td style="text-align: center;" bgcolor="#993399">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#993366</td>
<td style="text-align: center;" bgcolor="#993366">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#993333</td>
<td style="text-align: center;" bgcolor="#993333">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#993300</td>
<td style="text-align: center;" bgcolor="#993300">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9900FF</td>
<td style="text-align: center;" bgcolor="#9900ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#9900CC</td>
<td style="text-align: center;" bgcolor="#9900cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#990099</td>
<td style="text-align: center;" bgcolor="#990099">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#990066</td>
<td style="text-align: center;" bgcolor="#990066">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#990033</td>
<td style="text-align: center;" bgcolor="#990033">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#990000</td>
<td style="text-align: center;" bgcolor="#990000">&nbsp;</td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;" bgcolor="#336699"><span style="background-color: #c0c0c0;"><strong>Hex Code</strong></span></td>
<td bgcolor="#336699"><span style="background-color: #c0c0c0;"><strong>Color</strong></span></td>
</tr>
<tr>
<td style="text-align: center;">#00FFFF</td>
<td bgcolor="#00ffff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00FFCC</td>
<td bgcolor="#00ffcc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00FF99</td>
<td bgcolor="#00ff99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00FF66</td>
<td bgcolor="#00ff66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00FF33</td>
<td bgcolor="#00ff33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00FF00</td>
<td bgcolor="#00ff00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00CCFF</td>
<td bgcolor="#00ccff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00CCCC</td>
<td bgcolor="#00cccc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00CC99</td>
<td bgcolor="#00cc99">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00CC66</td>
<td bgcolor="#00cc66">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00CC33</td>
<td bgcolor="#00cc33">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#00CC00</td>
<td bgcolor="#00cc00">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0099FF</td>
<td bgcolor="#0099ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0099CC</td>
<td bgcolor="#0099cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#009999</td>
<td bgcolor="#009999">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#009966</td>
<td bgcolor="#009966">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#009933</td>
<td bgcolor="#009933">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#009900</td>
<td bgcolor="#009900">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0066FF</td>
<td bgcolor="#0066ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0066CC</td>
<td bgcolor="#0066cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#006699</td>
<td bgcolor="#006699">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#006666</td>
<td bgcolor="#006666">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#006633</td>
<td bgcolor="#006633">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#006600</td>
<td bgcolor="#006600">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0033FF</td>
<td bgcolor="#0033ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0033CC</td>
<td bgcolor="#0033cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#003399</td>
<td bgcolor="#003399">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#003366</td>
<td bgcolor="#003366">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#003333</td>
<td bgcolor="#003333">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#003300</td>
<td bgcolor="#003300">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0000FF</td>
<td bgcolor="#0000ff">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#0000CC</td>
<td bgcolor="#0000cc">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#000099</td>
<td bgcolor="#000099">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#000066</td>
<td bgcolor="#000066">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#000033</td>
<td bgcolor="#000033">&nbsp;</td>
</tr>
<tr>
<td style="text-align: center;">#000000</td>
<td bgcolor="#000000">&nbsp;</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<h3 style="text-align: center;">颜色细分</h3>
<table cellspacing="0" cellpadding="3">
<tbody>
<tr>
<td>&nbsp;</td>
<td align="right">&nbsp;</td>
</tr>
<tr bgcolor="#ffffff">
<td colspan="2">
<table style="height: 767px; width: 608px;" border="1" cellspacing="1">
<tbody>
<tr>
<td colspan="10" width="100%" height="19">
<p style="text-align: left;" align="center"><strong>红色和粉红色，以及它们的16进制代码。</strong></p>
</td>
</tr>
<tr>
<td align="middle" bgcolor="#990033" width="12" height="25"><span style="color: #ffffff;">#990033</span></td>
<td align="middle" bgcolor="#cc6699" width="12" height="25"><span style="color: #ffffff;">#CC6699</span></td>
<td align="middle" bgcolor="#ff6699" width="12" height="25"><span style="color: #ffffff;">#FF6699</span></td>
<td align="middle" bgcolor="#ff3366" width="12" height="25"><span style="color: #ffffff;">#FF3366</span></td>
<td align="middle" bgcolor="#993366" width="12" height="25"><span style="color: #ffffff;">#993366</span></td>
<td align="middle" bgcolor="#cc0066" width="12" height="25"><span style="color: #ffffff;">#CC0066</span></td>
<td align="middle" bgcolor="#cc0033" width="12" height="25"><span style="color: #ffffff;">#CC0033</span></td>
<td align="middle" bgcolor="#ff0066" width="12" height="25"><span style="color: #ffffff;">#FF0066</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#ff3399" width="12" height="25"><span style="color: #ffffff;">#FF3399</span></td>
<td align="middle" bgcolor="#ff9999" width="12" height="25"><span style="color: #ffffff;">#FF9999</span></td>
<td align="middle" bgcolor="#ff99cc" width="12" height="25"><span style="color: #ffffff;">#FF99CC</span></td>
<td align="middle" bgcolor="#ff0099" width="12" height="25"><span style="color: #ffffff;">#FF0099</span></td>
<td align="middle" bgcolor="#cc3366" width="12" height="25"><span style="color: #ffffff;">#CC3366</span></td>
<td align="middle" bgcolor="#ff66cc" width="12" height="25"><span style="color: #ffffff;">#FF66CC</span></td>
<td align="middle" bgcolor="#ff33cc" width="12" height="25"><span style="color: #ffffff;">#FF33CC</span></td>
<td align="middle" bgcolor="#ffccff" width="12" height="25"><span style="color: #ffffff;">#FFCCFF</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#ff0033" width="12" height="25"><span style="color: #ffffff;">#FF0033</span></td>
<td align="middle" bgcolor="#ff00cc" width="12" height="25"><span style="color: #ffffff;">#FF00CC</span></td>
<td valign="center" bgcolor="#cc3399" width="12" height="25"><span style="color: #ffffff;">#CC3399</span></td>
<td align="middle" bgcolor="#ff99ff" width="12" height="25"><span style="color: #ffffff;">#FF99FF</span></td>
</tr>
<tr>
<td colspan="10" align="middle" width="100%" height="19">
<p style="text-align: left;" align="center"><strong>紫红色，以及它们的16进制代码</strong>。</p>
</td>
</tr>
<tr>
<td align="middle" bgcolor="#ff66ff" width="12" height="19"><span style="color: #ffffff;">#FF66FF</span></td>
<td align="middle" bgcolor="#cc33cc" width="12" height="19"><span style="color: #ffffff;">#CC33CC</span></td>
<td align="middle" bgcolor="#cc00ff" width="12" height="19"><span style="color: #ffffff;">#CC00FF</span></td>
<td align="middle" bgcolor="#ff33ff" width="12" height="19"><span style="color: #ffffff;">#FF33FF</span></td>
<td align="middle" bgcolor="#cc99ff" width="12" height="19"><span style="color: #ffffff;">#CC99FF</span></td>
<td align="middle" bgcolor="#9900cc" width="12" height="19"><span style="color: #ffffff;">#9900CC</span></td>
<td align="middle" bgcolor="#ff00ff" width="12" height="19"><span style="color: #ffffff;">#FF00FF</span></td>
<td align="middle" bgcolor="#cc66ff" width="12" height="19"><span style="color: #ffffff;">#CC66FF</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#cc33ff" width="12" height="19"><span style="color: #ffffff;">#CC33FF</span></td>
<td align="middle" bgcolor="#cc99cc" width="12" height="19"><span style="color: #ffffff;">#CC99CC</span></td>
<td align="middle" bgcolor="#990066" width="12" height="19"><span style="color: #ffffff;">#990066</span></td>
<td align="middle" bgcolor="#993399" width="12" height="19"><span style="color: #ffffff;">#993399</span></td>
<td align="middle" bgcolor="#cc66cc" width="12" height="19"><span style="color: #ffffff;">#CC66CC</span></td>
<td align="middle" bgcolor="#cc00cc" width="12" height="19"><span style="color: #ffffff;">#CC00CC</span></td>
<td align="middle" bgcolor="#663366" width="12" height="19"><span style="color: #ffffff;">#663366</span></td>
<td align="middle" bgcolor="#cc0099" width="12" height="19"><span style="color: #ffffff;">#CC0099</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#990099" width="12" height="19"><span style="color: #ffffff;">#990099</span></td>
</tr>
<tr>
<td style="text-align: left;" colspan="10" align="middle" width="100%" height="16"><strong>蓝色，以及它们的16进制代码。</strong></td>
</tr>
<tr>
<td align="middle" bgcolor="#660099" width="12" height="16"><span style="color: #ffffff;">#660099</span></td>
<td align="middle" bgcolor="#666ff0" width="12" height="16"><span style="color: #ffffff;">#666FF</span></td>
<td align="middle" bgcolor="#000cc0" width="12" height="16"><span style="color: #ffffff;">#000CC</span></td>
<td align="middle" bgcolor="#9933cc" width="12" height="16">#9933CC</td>
<td align="middle" bgcolor="#666699" width="12" height="16"><span style="color: #ffffff;">#666699</span></td>
<td align="middle" bgcolor="#660066" width="12" height="16"><span style="color: #ffffff;">#660066</span></td>
<td align="middle" bgcolor="#333366" width="12" height="16"><span style="color: #ffffff;">#333366</span></td>
<td align="middle" bgcolor="#0066cc" width="12" height="16"><span style="color: #ffffff;">#0066CC</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#99ccff" width="12" height="16"><span style="color: #ffffff;">#99CCFF</span></td>
<td align="middle" bgcolor="#9933ff" width="12" height="16"><span style="color: #ffffff;">#9933FF</span></td>
<td align="middle" bgcolor="#330099" width="12" height="16"><span style="color: #ffffff;">#330099</span></td>
<td align="middle" bgcolor="#6699ff" width="12" height="16">#6699FF</td>
<td align="middle" bgcolor="#9966cc" width="12" height="16"><span style="color: #ffffff;">#9966CC</span></td>
<td align="middle" bgcolor="#3300cc" width="12" height="16"><span style="color: #ffffff;">#3300CC</span></td>
<td align="middle" bgcolor="#003366" width="12" height="16"><span style="color: #ffffff;">#003366</span></td>
<td align="middle" bgcolor="#330033" width="12" height="16"><span style="color: #ffffff;">#330033</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#663399" width="12" height="16"><span style="color: #ffffff;">#663399</span></td>
<td align="middle" bgcolor="#3333ff" width="12" height="16"><span style="color: #ffffff;">#3333FF</span></td>
<td align="middle" bgcolor="#006699" width="12" height="16"><span style="color: #ffffff;">#006699</span></td>
<td align="middle" bgcolor="#6633cc" width="12" height="16"><span style="color: #ffffff;">#6633CC</span></td>
<td align="middle" bgcolor="#3333cc" width="12" height="16"><span style="color: #ffffff;">#3333CC</span></td>
<td align="middle" bgcolor="#3399cc" width="12" height="16"><span style="color: #ffffff;">#3399CC</span></td>
<td align="middle" bgcolor="#6600cc" width="12" height="16"><span style="color: #ffffff;">#6600CC</span></td>
<td align="middle" bgcolor="#0066ff" width="12" height="16"><span style="color: #ffffff;">#0066FF</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#0033ff" width="12" height="16"><span style="color: #ffffff;">#0033FF</span></td>
<td align="middle" bgcolor="#66ccff" width="12" height="16"><span style="color: #ffffff;">#66CCFF</span></td>
<td align="middle" bgcolor="#330066" width="12" height="16"><span style="color: #ffffff;">#330066</span></td>
<td align="middle" bgcolor="#3366ff" width="12" height="16"><span style="color: #ffffff;">#3366FF</span></td>
<td align="middle" bgcolor="#3399ff" width="12" height="16"><span style="color: #ffffff;">#3399FF</span></td>
<td align="middle" bgcolor="#6600ff" width="12" height="16"><span style="color: #ffffff;">#6600FF</span></td>
<td align="middle" bgcolor="#3366cc" width="12" height="16"><span style="color: #ffffff;">#3366CC</span></td>
<td align="middle" bgcolor="#6699cc" width="12" height="16"><span style="color: #ffffff;">#6699CC</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#0099ff" width="12" height="16"><span style="color: #ffffff;">#0099FF</span></td>
<td align="middle" bgcolor="#ccccff" width="12" height="16"><span style="color: #000000;">#CCCCFF</span></td>
<td align="middle" bgcolor="#000033" width="12" height="16"><span style="color: #ffffff;">#000033</span></td>
<td align="middle" bgcolor="#33ccff" width="12" height="16"><span style="color: #000000;">#33CCFF</span></td>
<td align="middle" bgcolor="#9999ff" width="12" height="16"><span style="color: #ffffff;">#9999FF</span></td>
<td align="middle" bgcolor="#0000ff" width="12" height="16"><span style="color: #ffffff;">#0000FF</span></td>
<td align="middle" bgcolor="#00ccff" width="12" height="16"><span style="color: #000000;">#00CCFF</span></td>
<td align="middle" bgcolor="#9999cc" width="12" height="16"><span style="color: #ffffff;">#9999CC</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#0033cc" width="12" height="16"><span style="color: #ffffff;">#0033CC</span></td>
<td align="middle" bgcolor="#3300ff" width="12" height="16"><span style="color: #ffffff;">#3300FF</span></td>
<td align="middle" bgcolor="#333399" width="12" height="16"><span style="color: #ffffff;">#333399</span></td>
<td align="middle" bgcolor="#000099" width="12" height="16"><span style="color: #ffffff;">#000099</span></td>
<td align="middle" bgcolor="#000066" width="12" height="16"><span style="color: #ffffff;">#000066</span></td>
<td align="middle" bgcolor="#6633ff" width="12" height="16"><span style="color: #ffffff;">#6633FF</span></td>
<td align="middle" bgcolor="#003399" width="12" height="16"><span style="color: #ffffff;">#003399</span></td>
<td align="middle" bgcolor="#6666cc" width="12" height="16"><span style="color: #ffffff;">#6666CC</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#0099cc" width="12" height="16"><span style="color: #ffffff;">#0099CC</span></td>
<td align="middle" bgcolor="#9900ff" width="12" height="16"><span style="color: #ffffff;">#9900FF</span></td>
<td align="middle" bgcolor="#9966ff" width="12" height="16"><span style="color: #ffffff;">#9966FF</span></td>
</tr>
<tr>
<td style="text-align: left;" colspan="10" align="middle" width="100%" height="14"><strong>黄色、褐色、玫瑰色和橙色，以及它们的16进制代码。</strong></td>
</tr>
<tr>
<td align="middle" bgcolor="#ffffcc" width="12" height="16">#FFFFCC</td>
<td align="middle" bgcolor="#ffcc00" width="12" height="16"><span style="color: #ffffff;">#FFCC00</span></td>
<td align="middle" bgcolor="#cc9000" width="12" height="16"><span style="color: #ffffff;">#CC99090</span></td>
<td align="middle" bgcolor="#663300" width="12" height="16"><span style="color: #ffffff;">#663300</span></td>
<td align="middle" bgcolor="#ff6600" width="12" height="16"><span style="color: #ffffff;">#FF6600</span></td>
<td align="middle" bgcolor="#663333" width="12" height="16"><span style="color: #ffffff;">#663333</span></td>
<td align="middle" bgcolor="#cc6666" width="12" height="16"><span style="color: #ffffff;">#CC6666</span></td>
<td align="middle" bgcolor="#ff6666" width="12" height="16"><span style="color: #ffffff;">#FF6666</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#ffcc66" width="12" height="16">#FFCC66</td>
<td align="middle" bgcolor="#ff9900" width="12" height="16"><span style="color: #ffffff;">#FF9900</span></td>
<td align="middle" bgcolor="#ff9966" width="12" height="16"><span style="color: #ffffff;">#FF9966</span></td>
<td align="middle" bgcolor="#cc3300" width="12" height="16"><span style="color: #ffffff;">#CC3300</span></td>
<td align="middle" bgcolor="#996666" width="12" height="16"><span style="color: #ffffff;">#996666</span></td>
<td align="middle" bgcolor="#ffcccc" width="12" height="16"><span style="color: #000000;">#FFCCCC</span></td>
<td align="middle" bgcolor="#660000" width="12" height="16"><span style="color: #ffffff;">#660000</span></td>
<td align="middle" bgcolor="#ff3300" width="12" height="16"><span style="color: #ffffff;">#FF3300</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#cc6600" width="12" height="16"><span style="color: #ffffff;">#CC6600</span></td>
<td align="middle" bgcolor="#ff6633" width="12" height="16"><span style="color: #ffffff;">#FF6633</span></td>
<td align="middle" bgcolor="#996633" width="12" height="16"><span style="color: #ffffff;">#996633</span></td>
<td align="middle" bgcolor="#cc9999" width="12" height="16"><span style="color: #ffffff;">#CC9999</span></td>
<td align="middle" bgcolor="#ff3333" width="12" height="16"><span style="color: #ffffff;">#FF3333</span></td>
<td align="middle" bgcolor="#990000" width="12" height="16"><span style="color: #ffffff;">#990000</span></td>
<td align="middle" bgcolor="#cc9966" width="12" height="16"><span style="color: #ffffff;">#CC9966</span></td>
<td align="middle" bgcolor="#ffff33" width="12" height="16">#FFFF33</td>
</tr>
<tr>
<td align="middle" bgcolor="#ff9933" width="12" height="16"><span style="color: #ffffff;">#FF9933</span></td>
<td align="middle" bgcolor="#330000" width="12" height="16"><span style="color: #ffffff;">#330000</span></td>
<td align="middle" bgcolor="#993333" width="12" height="16"><span style="color: #ffffff;">#993333</span></td>
<td align="middle" bgcolor="#cc3333" width="12" height="16">#CC3333</td>
<td align="middle" bgcolor="#cc0000" width="12" height="16">#CC0000</td>
<td align="middle" bgcolor="#ffcc99" width="12" height="16">#FFCC99</td>
<td align="middle" bgcolor="#ffff00" width="12" height="16">#FFFF00</td>
<td align="middle" bgcolor="#996600" width="12" height="16">#996600</td>
</tr>
<tr>
<td align="middle" bgcolor="#993300" width="12" height="16"><span style="color: #ffffff;">#993300</span></td>
<td align="middle" bgcolor="#ff0000" width="12" height="16"><span style="color: #ffffff;">#FF0000</span></td>
<td align="middle" bgcolor="#cc6633" width="12" height="16"><span style="color: #ffffff;">#CC6633</span></td>
<td align="middle" bgcolor="#cc9933" width="12" height="16">#CC9933</td>
<td align="middle" bgcolor="#ffcc33" width="12" height="16">#FFCC33</td>
<td align="middle" bgcolor="#ffff99" width="12" height="16">#FFFF99</td>
</tr>
<tr>
<td style="text-align: left;" colspan="10" align="middle" width="100%" height="14"><strong>绿色，以及它们的16进制代码。</strong></td>
</tr>
<tr>
<td align="middle" bgcolor="#99ffff" width="12" height="16"><span style="color: #000000;">#99FFFF</span></td>
<td align="middle" bgcolor="#33cccc" width="12" height="16"><span style="color: #000000;">#33CCCC</span></td>
<td align="middle" bgcolor="#00cc99" width="12" height="16"><span style="color: #000000;">#00CC99</span></td>
<td align="middle" bgcolor="#99ff99" width="12" height="16"><span style="color: #ffffff;">#99FF99</span></td>
<td align="middle" bgcolor="#009966" width="12" height="16"><span style="color: #ffffff;">#009966</span></td>
<td align="middle" bgcolor="#33ff33" width="12" height="16"><span style="color: #000000;">#33FF33</span></td>
<td align="middle" bgcolor="#33ff00" width="12" height="16"><span style="color: #000000;">#33FF00</span></td>
<td align="middle" bgcolor="#99cc33" width="12" height="16"><span style="color: #000000;">#99CC33</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#66cccc" width="12" height="16"><span style="color: #000000;">#66CCCC</span></td>
<td align="middle" bgcolor="#66ffcc" width="12" height="16"><span style="color: #000000;">#66FFCC</span></td>
<td align="middle" bgcolor="#66ff66" width="12" height="16"><span style="color: #000000;">#66FF66</span></td>
<td align="middle" bgcolor="#009933" width="12" height="16"><span style="color: #ffffff;">#009933</span></td>
<td align="middle" bgcolor="#00cc33" width="12" height="16"><span style="color: #ffffff;">#00CC33</span></td>
<td align="middle" bgcolor="#66ff00" width="12" height="16"><span style="color: #000000;">#66FF00</span></td>
<td align="middle" bgcolor="#336600" width="12" height="16"><span style="color: #ffffff;">#336600</span></td>
<td align="middle" bgcolor="#333000" width="12" height="16"><span style="color: #ffffff;">#33300</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#99ffcc" width="12" height="16"><span style="color: #000000;">#99FFCC</span></td>
<td align="middle" bgcolor="#339933" width="12" height="16"><span style="color: #ffffff;">#339933</span></td>
<td align="middle" bgcolor="#33ff66" width="12" height="16"><span style="color: #ffffff;">#33FF66</span></td>
<td align="middle" bgcolor="#33cc33" width="12" height="16"><span style="color: #ffffff;">#33CC33</span></td>
<td align="middle" bgcolor="#99ff00" width="12" height="16"><span style="color: #ffffff;">#99FF00</span></td>
<td align="middle" bgcolor="#669900" width="12" height="16"><span style="color: #ffffff;">#669900</span></td>
<td align="middle" bgcolor="#666600" width="12" height="16"><span style="color: #ffffff;">#666600</span></td>
<td align="middle" bgcolor="#00ffff" width="12" height="16"><span style="color: #000000;">#00FFFF</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#99cc99" width="12" height="16"><span style="color: #000000;">#99CC99</span></td>
<td align="middle" bgcolor="#00ff66" width="12" height="16"><span style="color: #ffffff;">#00FF66</span></td>
<td align="middle" bgcolor="#66ff33" width="12" height="16"><span style="color: #ffffff;">#66FF33</span></td>
<td align="middle" bgcolor="#66cc00" width="12" height="16"><span style="color: #ffffff;">#66CC00</span></td>
<td align="middle" bgcolor="#99cc00" width="12" height="16"><span style="color: #ffffff;">#99CC00</span></td>
<td align="middle" bgcolor="#999933" width="12" height="16"><span style="color: #ffffff;">#999933</span></td>
<td align="middle" bgcolor="#00cccc" width="12" height="16"><span style="color: #ffffff;">#00CCCC</span></td>
<td align="middle" bgcolor="#006666" width="12" height="16"><span style="color: #ffffff;">#006666</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#ccffcc" width="12" height="16"><span style="color: #000000;">#CCFFCC</span></td>
<td align="middle" bgcolor="#00ff00" width="12" height="16"><span style="color: #ffffff;">#00FF00</span></td>
<td align="middle" bgcolor="#00cc00" width="12" height="16"><span style="color: #ffffff;">#00CC00</span></td>
<td align="middle" bgcolor="#ccff66" width="12" height="16"><span style="color: #000000;">#CCFF66</span></td>
<td align="middle" bgcolor="#cccc66" width="12" height="16"><span style="color: #000000;">#CCCC66</span></td>
<td align="middle" bgcolor="#009999" width="12" height="16"><span style="color: #ffffff;">#009999</span></td>
<td align="middle" bgcolor="#003333" width="12" height="16"><span style="color: #ffffff;">#003333</span></td>
<td align="middle" bgcolor="#006633" width="12" height="16"><span style="color: #ffffff;">#006633</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#66cc33" width="12" height="16"><span style="color: #ffffff;">#66CC33</span></td>
<td align="middle" bgcolor="#33cc00" width="12" height="16"><span style="color: #ffffff;">#33CC00</span></td>
<td style="text-align: center;" align="middle" bgcolor="#ccff33" width="12" height="16"><span style="color: #ffffff;">#CCFF33</span></td>
<td align="middle" bgcolor="#666633" width="12" height="16"><span style="color: #ffffff;">#666633</span></td>
<td align="middle" bgcolor="#669999" width="12" height="16"><span style="color: #ffffff;">#669999</span></td>
<td align="middle" bgcolor="#00ffcc" width="12" height="16"><span style="color: #000000;">#00FFCC</span></td>
<td align="middle" bgcolor="#336633" width="12" height="16"><span style="color: #ffffff;">#336633</span></td>
<td align="middle" bgcolor="#33cc66" width="12" height="16"><span style="color: #ffffff;">#33CC66</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#339900" width="12" height="16"><span style="color: #ffffff;">#339900</span></td>
<td align="middle" bgcolor="#ccff00" width="12" height="16"><span style="color: #ffffff;">#CCFF00</span></td>
<td align="middle" bgcolor="#999966" width="12" height="16"><span style="color: #ffffff;">#999966</span></td>
<td align="middle" bgcolor="#99cccc" width="12" height="16"><span style="color: #ffffff;">#99CCCC</span></td>
<td align="middle" bgcolor="#33ffcc" width="12" height="16"><span style="color: #000000;">#33FFCC</span></td>
<td align="middle" bgcolor="#669966" width="12" height="16"><span style="color: #ffffff;">#669966</span></td>
<td align="middle" bgcolor="#00cc66" width="12" height="16"><span style="color: #ffffff;">#00CC66</span></td>
<td align="middle" bgcolor="#99ff33" width="12" height="16"><span style="color: #ffffff;">#99FF33</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#999900" width="12" height="16"><span style="color: #ffffff;">#999900</span></td>
<td align="middle" bgcolor="#cccc99" width="12" height="16"><span style="color: #ffffff;">#CCCC99</span></td>
<td align="middle" bgcolor="#ccffff" width="12" height="16"><span style="color: #000000;">#CCFFFF</span></td>
<td align="middle" bgcolor="#33cc99" width="12" height="16"><span style="color: #ffffff;">#33CC99</span></td>
<td align="middle" bgcolor="#66cc66" width="12" height="16"><span style="color: #ffffff;">#66CC66</span></td>
<td align="middle" bgcolor="#66cc99" width="12" height="16"><span style="color: #ffffff;">#66CC99</span></td>
<td align="middle" bgcolor="#00ff33" width="12" height="16"><span style="color: #ffffff;">#00FF33</span></td>
<td align="middle" bgcolor="#009900" width="12" height="16"><span style="color: #ffffff;">#009900</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#cccc00" width="12" height="16"><span style="color: #ffffff;">#CCCC00</span></td>
<td align="middle" bgcolor="#ccc330" width="12" height="16"><span style="color: #ffffff;">#CCC33</span></td>
<td align="middle" bgcolor="#336666" width="12" height="16"><span style="color: #ffffff;">#336666</span></td>
<td align="middle" bgcolor="#006600" width="12" height="16"><span style="color: #ffffff;">#006600</span></td>
<td align="middle" bgcolor="#003300" width="12" height="16"><span style="color: #ffffff;">#003300</span></td>
<td align="middle" bgcolor="#669933" width="12" height="16"><span style="color: #ffffff;">#669933</span></td>
<td align="middle" bgcolor="#339966" width="12" height="16"><span style="color: #ffffff;">#339966</span></td>
<td align="middle" bgcolor="#339999" width="12" height="16"><span style="color: #ffffff;">#339999</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#669900" width="12" height="16"><span style="color: #ffffff;">#669900</span></td>
<td align="middle" bgcolor="#99cc66" width="12" height="16"><span style="color: #ffffff;">#99CC66</span></td>
<td align="middle" bgcolor="#99ff66" width="12" height="16"><span style="color: #000000;">#99FF66</span></td>
<td align="middle" bgcolor="#00ff99" width="12" height="16"><span style="color: #000000;">#00FF99</span></td>
<td align="middle" bgcolor="#33ff99" width="12" height="16"><span style="color: #000000;">#33FF99</span></td>
<td align="middle" bgcolor="#66ff99" width="12" height="16"><span style="color: #000000;">#66FF99</span></td>
<td align="middle" bgcolor="#ccff99" width="12" height="16"><span style="color: #000000;">#CCFF99</span></td>
<td align="middle" bgcolor="#33ffff" width="12" height="16"><span style="color: #000000;">#33FFFF</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#66ffff" width="12" height="16">#66FFFF</td>
</tr>
<tr>
<td style="text-align: left;" colspan="10" align="middle" width="100%" height="16"><strong>白色、灰色和黑色，以及它们的16进制代码。</strong></td>
</tr>
<tr>
<td style="text-align: left;" align="middle" bgcolor="#fffff0" width="12" height="16"><span style="color: #003300;">#FFFFF</span></td>
<td style="text-align: left;" align="middle" bgcolor="#cccccc" width="12" height="16"><span style="color: #003300;">#CCCCCC</span></td>
<td style="text-align: left;" align="middle" bgcolor="#999999" width="12" height="16"><span style="color: #003300;">#999999</span></td>
<td style="text-align: left;" align="middle" bgcolor="#666666" width="12" height="16"><span style="color: #ffffff;">#666666</span></td>
<td style="text-align: left;" align="middle" bgcolor="#333333" width="12" height="16"><span style="color: #ffffff;">#333333</span></td>
<td style="text-align: left;" align="middle" bgcolor="#000000" width="12" height="16"><span style="color: #ffffff;">#000000</span></td>
</tr>
<tr>
<td style="text-align: left;" colspan="10" align="middle" width="100%" height="16"><span style="color: #ffffff;"><strong>16色和它们的16进制代码。</strong></span></td>
</tr>
<tr>
<td align="middle" bgcolor="#00ffff" width="12" height="16">Aqua</td>
<td align="middle" bgcolor="#000000" width="12" height="16"><span style="color: #ffffff;">Black</span></td>
<td align="middle" bgcolor="#ff00ff" width="12" height="16">Fuchsia</td>
<td align="middle" bgcolor="#800000" width="12" height="16"><span style="color: #ffffff;">Gray</span></td>
<td align="middle" bgcolor="#008000" width="12" height="16"><span style="color: #ffffff;">Gree</span></td>
<td align="middle" bgcolor="#00ff00" width="12" height="16"><span style="color: #ffffff;">Lime</span></td>
<td align="middle" bgcolor="#800000" width="12" height="16"><span style="color: #ffffff;">Maroon</span></td>
<td align="middle" bgcolor="#000080" width="12" height="16"><span style="color: #ffffff;">Navy</span></td>
</tr>
<tr>
<td align="middle" bgcolor="#ff0000" width="12" height="18">Red</td>
<td align="middle" bgcolor="#c0c0c0" width="12" height="18">Silver</td>
<td align="middle" bgcolor="#008080" width="12" height="18"><span style="color: #ffffff;">Teal</span></td>
<td align="middle" bgcolor="#ffffff" width="12" height="18">White</td>
<td align="middle" bgcolor="#ffff00" width="12" height="18">Yellow</td>
<td align="middle" bgcolor="#0000ff" width="12" height="18"><span style="color: #ffffff;">Blue</span></td>
<td align="middle" bgcolor="#808000" width="12" height="16"><span style="color: #ffffff;">Olive</span></td>
<td align="middle" bgcolor="#800080" width="12" height="16"><span style="color: #ffffff;">Purple</span></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<h2 style="text-align: center;"><strong>文字查找</strong></h2>
<table style="margin-right: 0px; margin-left: 0px; border-color: silver; font-family: Verdana, Arial, Helvetica, sans-serif; padding: 0px; word-break: break-word; width: 629px; height: 5788px;" border="1" cellspacing="0" cellpadding="0">
<tbody id="color" style="margin: 0px; padding: 0px;">
<tr style="margin: 0px; padding: 0px;" align="center">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;"><a href="https://www.cnblogs.com/cainiao-chuanqi/" target="_blank"><strong style="margin: 0px; padding: 0px;">颜 色</strong></a></td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;"><strong style="margin: 0px; padding: 0px;">英文代码</strong></td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;"><strong style="margin: 0px; padding: 0px;">形象描述</strong></td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;"><strong style="margin: 0px; padding: 0px;">十六进制</strong></td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;"><strong style="margin: 0px; padding: 0px;">RGB</strong></td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffb6c1">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightPink</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">浅粉红</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFB6C1</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,182,193</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffc0cb">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Pink</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">粉红</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFC0CB</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,192,203</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#dc143c">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Crimson</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">猩红</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#DC143C</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">220,20,60</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fff0f5">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LavenderBlush</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">脸红的淡紫色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFF0F5</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,240,245</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#db7093">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">PaleVioletRed</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">苍白的紫罗兰红色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#DB7093</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">219,112,147</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff69b4">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">HotPink</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">热情的粉红</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF69B4</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,105,180</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff1493">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DeepPink</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深粉色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF1493</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,20,147</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#c71585">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumVioletRed</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的紫罗兰红色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#C71585</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">199,21,133</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#da70d6">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Orchid</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">兰花的紫色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#DA70D6</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">218,112,214</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#d8bfd8">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Thistle</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">蓟</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#D8BFD8</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">216,191,216</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#dda0dd">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">plum</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">李子</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#DDA0DD</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">221,160,221</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ee82ee">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Violet</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">紫罗兰</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#EE82EE</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">238,130,238</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff00ff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Magenta</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">洋红</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF00FF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,0,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff00ff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Fuchsia</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">灯笼海棠(紫红色)</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF00FF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,0,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#8b008b">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkMagenta</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深洋红色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#8B008B</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">139,0,139</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#800080">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Purple</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">紫色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#800080</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">128,0,128</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ba55d3">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumOrchid</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的兰花紫</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#BA55D3</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">186,85,211</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#9400d3">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkVoilet</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深紫罗兰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#9400D3</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">148,0,211</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#9932cc">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkOrchid</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深兰花紫</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#9932CC</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">153,50,204</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#4b0082">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Indigo</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">靛青</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#4B0082</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">75,0,130</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#8a2be2">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">BlueViolet</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深紫罗兰的蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#8A2BE2</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">138,43,226</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#9370db">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumPurple</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的紫色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#9370DB</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">147,112,219</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#7b68ee">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumSlateBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的板岩暗蓝灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#7B68EE</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">123,104,238</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#6a5acd">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SlateBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">板岩暗蓝灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#6A5ACD</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">106,90,205</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#483d8b">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkSlateBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深岩暗蓝灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#483D8B</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">72,61,139</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#e6e6fa">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Lavender</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">熏衣草花的淡紫色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#E6E6FA</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">230,230,250</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f8f8ff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">GhostWhite</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">幽灵的白色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F8F8FF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">248,248,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#0000ff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Blue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">纯蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#0000FF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,0,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#0000cd">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#0000CD</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,0,205</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#191970">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MidnightBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">午夜的蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#191970</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">25,25,112</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00008b">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00008B</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,0,139</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#000080">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Navy</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">海军蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#000080</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,0,128</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#4169e1">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">RoyalBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">皇军蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#4169E1</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">65,105,225</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#6495ed">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">CornflowerBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">矢车菊的蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#6495ED</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">100,149,237</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#b0c4de">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightSteelBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">淡钢蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#B0C4DE</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">176,196,222</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#778899">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightSlateGray</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">浅石板灰</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#778899</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">119,136,153</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#708090">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SlateGray</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">石板灰</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#708090</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">112,128,144</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#1e90ff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DoderBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">道奇蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#1E90FF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">30,144,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f0f8ff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">AliceBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">爱丽丝蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F0F8FF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">240,248,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#4682b4">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SteelBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">钢蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#4682B4</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">70,130,180</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#87cefa">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightSkyBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">淡蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#87CEFA</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">135,206,250</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#87ceeb">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SkyBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">天蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#87CEEB</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">135,206,235</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00bfff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DeepSkyBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深天蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00BFFF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,191,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#add8e6">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightBLue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">淡蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#ADD8E6</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">173,216,230</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#b0e0e6">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">PowDerBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">火药蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#B0E0E6</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">176,224,230</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#5f9ea0">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">CadetBlue</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">军校蓝</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#5F9EA0</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">95,158,160</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f0ffff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Azure</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">蔚蓝色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F0FFFF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">240,255,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#e1ffff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightCyan</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">淡青色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#E1FFFF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">225,255,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#afeeee">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">PaleTurquoise</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">苍白的绿宝石</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#AFEEEE</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">175,238,238</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00ffff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Cyan</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">青色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00FFFF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,255,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00ffff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Aqua</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">水绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00FFFF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,255,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00ced1">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkTurquoise</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深绿宝石</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00CED1</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,206,209</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#2f4f4f">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkSlateGray</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深石板灰</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#2F4F4F</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">47,79,79</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#008b8b">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkCyan</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深青色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#008B8B</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,139,139</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#008080">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Teal</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">水鸭色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#008080</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,128,128</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#48d1cc">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumTurquoise</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的绿宝石</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#48D1CC</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">72,209,204</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#20b2aa">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightSeaGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">浅海洋绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#20B2AA</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">32,178,170</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#40e0d0">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Turquoise</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">绿宝石</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#40E0D0</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">64,224,208</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#7fffaa">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Auqamarin</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">绿玉\碧绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#7FFFAA</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">127,255,170</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00fa9a">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumAquamarine</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的碧绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00FA9A</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,250,154</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00ff7f">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MediumSpringGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">适中的春天的绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00FF7F</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,255,127</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f5fffa">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MintCream</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">薄荷奶油</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F5FFFA</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">245,255,250</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#3cb371">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SpringGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">春天的绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#3CB371</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">60,179,113</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#2e8b57">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SeaGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">海洋绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#2E8B57</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">46,139,87</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f0fff0">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Honeydew</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">蜂蜜</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F0FFF0</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">240,255,240</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#90ee90">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">淡绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#90EE90</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">144,238,144</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#98fb98">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">PaleGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">苍白的绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#98FB98</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">152,251,152</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#8fbc8f">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkSeaGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深海洋绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#8FBC8F</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">143,188,143</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#32cd32">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LimeGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">酸橙绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#32CD32</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">50,205,50</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#00ff00">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Lime</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">酸橙色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#00FF00</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,255,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#228b22">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">ForestGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">森林绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#228B22</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">34,139,34</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#008000">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Green</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">纯绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#008000</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,128,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#006400">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深绿色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#006400</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,100,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#7fff00">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Chartreuse</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">查特酒绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#7FFF00</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">127,255,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#7cfc00">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LawnGreen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">草坪绿</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#7CFC00</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">124,252,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#adff2f">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">GreenYellow</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">绿黄色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#ADFF2F</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">173,255,47</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#556b2f">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">OliveDrab</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">橄榄土褐色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#556B2F</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">85,107,47</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f5f5dc">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Beige</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">米色(浅褐色)</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F5F5DC</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">245,245,220</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fafad2">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightGoldenrodYellow</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">浅秋麒麟黄</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FAFAD2</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">250,250,210</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fffff0">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Ivory</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">象牙</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFFFF0</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,255,240</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffffe0">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightYellow</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">浅黄色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFFFE0</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,255,224</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffff00">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Yellow</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">纯黄</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFFF00</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,255,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#808000">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Olive</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">橄榄</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#808000</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">128,128,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#bdb76b">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkKhaki</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深卡其布</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#BDB76B</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">189,183,107</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fffacd">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LemonChiffon</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">柠檬薄纱</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFFACD</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,250,205</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#eee8aa">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">PaleGodenrod</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">灰秋麒麟</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#EEE8AA</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">238,232,170</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f0e68c">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Khaki</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">卡其布</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F0E68C</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">240,230,140</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffd700">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Gold</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">金</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFD700</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,215,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fff8dc">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Cornislk</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">玉米色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFF8DC</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,248,220</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#daa520">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">GoldEnrod</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">秋麒麟</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#DAA520</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">218,165,32</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fffaf0">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">FloralWhite</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">花的白色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFFAF0</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,250,240</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fdf5e6">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">OldLace</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">老饰带</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FDF5E6</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">253,245,230</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f5deb3">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Wheat</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">小麦色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F5DEB3</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">245,222,179</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffe4b5">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Moccasin</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">鹿皮鞋</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFE4B5</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,228,181</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffa500">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Orange</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">橙色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFA500</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,165,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffefd5">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">PapayaWhip</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">番木瓜</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFEFD5</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,239,213</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffebcd">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">BlanchedAlmond</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">漂白的杏仁</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFEBCD</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,235,205</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffdead">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">NavajoWhite</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">纳瓦霍白</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFDEAD</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,222,173</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#faebd7">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">AntiqueWhite</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">古代的白色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FAEBD7</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">250,235,215</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#d2b48c">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Tan</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">晒黑</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#D2B48C</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">210,180,140</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#deb887">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">BrulyWood</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">结实的树</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#DEB887</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">222,184,135</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffe4c4">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Bisque</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">(浓汤)乳脂,番茄等</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFE4C4</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,228,196</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff8c00">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkOrange</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深橙色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF8C00</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,140,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#faf0e6">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Linen</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">亚麻布</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FAF0E6</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">250,240,230</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#cd853f">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Peru</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">秘鲁</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#CD853F</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">205,133,63</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffdab9">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">PeachPuff</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">桃色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFDAB9</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,218,185</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f4a460">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SandyBrown</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">沙棕色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F4A460</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">244,164,96</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#d2691e">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Chocolate</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">巧克力</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#D2691E</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">210,105,30</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#8b4513">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SaddleBrown</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">马鞍棕色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#8B4513</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">139,69,19</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fff5ee">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">SeaShell</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">海贝壳</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFF5EE</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,245,238</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#a0522d">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Sienna</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">黄土赭色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#A0522D</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">160,82,45</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffa07a">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightSalmon</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">浅鲜肉(鲑鱼)色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFA07A</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,160,122</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff7f50">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Coral</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">珊瑚</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF7F50</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,127,80</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff4500">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">OrangeRed</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">橙红色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF4500</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,69,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#e9967a">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkSalmon</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深鲜肉(鲑鱼)色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#E9967A</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">233,150,122</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff6347">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Tomato</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">番茄</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF6347</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,99,71</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffe4e1">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">MistyRose</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">薄雾玫瑰</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFE4E1</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,228,225</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fa8072">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Salmon</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">鲜肉(鲑鱼)色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FA8072</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">250,128,114</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#fffafa">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Snow</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">雪</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFFAFA</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,250,250</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f08080">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightCoral</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">淡珊瑚色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F08080</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">240,128,128</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#bc8f8f">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">RosyBrown</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">玫瑰棕色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#BC8F8F</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">188,143,143</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#cd5c5c">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">IndianRed</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">印度红</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#CD5C5C</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">205,92,92</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ff0000">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Red</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">纯红</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FF0000</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,0,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#a52a2a">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Brown</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">棕色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#A52A2A</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">165,42,42</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#b22222">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">FireBrick</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">耐火砖</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#B22222</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">178,34,34</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#8b0000">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkRed</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深红色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#8B0000</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">139,0,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#800000">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Maroon</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">栗色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#800000</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">128,0,0</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#ffffff">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">White</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">纯白</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#FFFFFF</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">255,255,255</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#f5f5f5">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">WhiteSmoke</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">白烟</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#F5F5F5</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">245,245,245</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#dcdcdc">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Gainsboro</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">亮灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#DCDCDC</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">220,220,220</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#d3d3d3">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">LightGrey</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">浅灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#D3D3D3</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">211,211,211</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#c0c0c0">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Silver</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">银白色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#C0C0C0</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">192,192,192</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#a9a9a9">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DarkGray</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">深灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#A9A9A9</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">169,169,169</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#808080">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Gray</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#808080</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">128,128,128</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;" bgcolor="#696969">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">DimGray</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">暗淡的灰色</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#696969</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">105,105,105</td>
</tr>
<tr style="margin: 0px; padding: 0px;">
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: center;" bgcolor="#000000">　</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">Black</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">纯黑</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">#000000</td>
<td style="margin: 0px; border-color: silver; padding: 8px 14px; text-align: left;">0,0,0</td>
</tr>
</tbody>
</table>
<h3 style="text-align: center;">&nbsp;排序</h3>
<p>&nbsp;&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190805110052961-959572259.png" alt="" /></p>
<p>&nbsp;</p>]]></description></item><item><title>多线程简介（全）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11285611.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 04 Aug 2019 14:16:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11285611.html</guid><description><![CDATA[<h2>线程实现方式</h2>
<h3>并发与并行</h3>
<ul>
<li><strong>并发：</strong>指两或多个事件在<strong>同一个时间段</strong>内发生</li>
<li><strong>并行：</strong>指两或多个事件在<strong>同一个时刻</strong>发生（同时发生）</li>
</ul>
<h3>进程的概念</h3>
<p><strong>内存：</strong>所有的应用程序都需要进入到内存中执行 临时存储RAM</p>
<p><strong>硬盘：</strong>永久存储ROM</p>
<ul>
<li><strong>进入到内存的程序叫进程</strong></li>
<li><strong>任务管理器--&gt;结束进程</strong></li>
<li>那么就把进程从内存中清除了</li>
</ul>
<h3>线程的概念</h3>
<p>点击一个应用程序的功能执行，就会开启一条应用程序到cpu的执行路径，cup就可以通过这个路径执行功能，这个路径有一个名字，叫<strong>线程。</strong></p>
<p><strong>线程属于进程：</strong>是进程中的一个执行单元，负责程序的执行</p>
<p>线程的<strong>好处：</strong></p>
<ol>
<li>效率高</li>
<li>多线程之间互不影响</li>
</ol>
<p><strong>如：</strong><br /><strong>单核心线程cpu</strong></p>
<ul>
<li>cpu在多个线程之间做高速的切换</li>
<li>轮流执行多个线程</li>
<li>效率低</li>
<li>切换的速度块（1/n毫秒）</li>










</ul>
<p><strong>4核心8线程</strong></p>
<ul>
<li>有8个线程，可以同时执行8个线程</li>
<li>8个线程在多个任务之间做高速的切换</li>
<li>速度是单线程cpu的8倍(每个执行到的几率都被提高了8倍）</li>

</ul>
<h3>线程的调度</h3>
<p><strong>分时调度</strong></p>
<ul>
<li>所有线程轮流使用cpu的使用权</li>










</ul>
<p><strong>抢占式调度</strong></p>
<ul>
<li>优先级高的线程使用cpu先使用，若相同，随机选择一个。Java使用的就是抢占式调度。</li>

</ul>
<h3>主线程</h3>
<p><strong>主线程：</strong>执行主<strong>（main）</strong>方法的线程</p>
<p><strong>单线程程序：</strong>Java程序中只有一个线程<br />执行从main方法开始，从上到下依次执行</p>
<ul>
<li>JVM执行main方法，main方法会进入到栈内存</li>
<li>JVM会找操作系统开辟一条main方法通向cpu的执行路径</li>
<li>cpu就可以通过这个路径来执行main方法</li>
<li>而这个路径有一个名字，叫main（主）线程</li>

</ul>
<h3>创建多线程</h3>
<p>创建多线程程序的<strong>第一种方式：创建Thread的子类</strong><br /><strong>java.lang.Thread类：</strong>是描述线程的类，我们想要实现多线程程序，就必须继承Thread类。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>创建一个Thread类的子类</li>
<li>在Thread类的子类中重写Thread类的run方法，设置线程任务（开启线程要做什么？）</li>
<li>创建Thread类的子类对象</li>
<li>调用Thread类中的方法start方法，开启新的线程，执行run方法。</li>










</ol>
<ul>
<li>		void start() 使该线程开始执行；Java虚拟机调用该线程的run方法。</li>
<li>		结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建地新线程，执行其run方法）。</li>
<li>		多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</li>










</ul>
<p>Java使用的就是抢占式调度。优先级高的线程使用cpu先使用，若相同，随机选择一个。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">1.创建一个Thread类的子类</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">2.在Thread类的子类中重写Thread类的run方法，设置线程任务（开启线程要做什么？）</span>
<span style="color: #000000;">    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0;i&lt;20;i++<span style="color: #000000;">){
            System.out.println(</span>"run:"+1<span style="color: #000000;">);
        }
    }
}
    
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3 创建Thread类的子类对象</span>
        MyThread mt = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyThread();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4.调用Thread类中的方法start方法，开启新的线程，执行run方法。</span>
<span style="color: #000000;">        mt.start();
    
        </span><span style="color: #008000;">//</span><span style="color: #008000;">主线程会继续执行主方法中的代码</span>
        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0;i&lt;37;i++<span style="color: #000000;">){
            System.out.println(</span>"main:"+<span style="color: #000000;">i);
        }
    
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>创建多线程程序的<strong>第二种方法：实现Runnable接口</strong><br /><strong>java.lang.Runnable</strong></p>
<ul>
<li>	Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为run的无参数方法。</li>










</ul>
<p><strong>java.lang.Thread类的构造方法</strong></p>
<ul>
<li>	Thread(Runnable target)分配新的 Thread对象。</li>
<li>	Thread(Runnable target，String name)分配新的 Thread对象。</li>










</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li>创建一个Runnable接口的实现类</li>
<li>在实现类中重写Runnable接口的run方法，设置线程任务</li>
<li>创建一个Runnable 接口的实现类对象</li>
<li>创建Thread类对象，构造方法中传递Runnable接口的实现类对象</li>
<li>调用Thread类中的方法<strong>start方法</strong>，开启新的线程，执行run方法。</li>










</ol>
<p><strong>实现Runnable接口创建多线程程序的好处：</strong><br />	<strong>1 避免了单继承的局限性</strong></p>
<ul>
<li>		一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类</li>
<li>		实现Runnable接口，还可以继承其他的类，实现其他的接口</li>










</ul>
<p><strong>	2 增强了程序的扩展性，降低了程序的耦合性（解耦）</strong></p>
<ul>
<li>		实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）</li>
<li>		实现类中，重写了run方法：用来设置线程任务</li>
<li>		创建Thread类对象，调用Thread类中的方法start方法，开启新的线程，执行run方法。</li>










</ul>
<h3><strong>匿名内部类方式实现线程的创建</strong></h3>
<ul>
<li><strong>匿名：</strong>没有名字</li>
<li><strong>内部类：</strong>写在其他类内部的类</li>










</ul>
<p><strong>匿名内部类的作用：</strong>简化代码</p>
<ul>
<li>	把子类继承父类，重写父类的方法，创建子类对象合一步完成</li>
<li>	把实现类实现类接口，重写接口中的方法，创建实现类对象合一步完成</li>










</ul>
<p><strong>格式：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">new</span> 父类/<span style="color: #000000;">接口(){
    重置父类</span>/<span style="color: #000000;">接口中的方法
};

</span><span style="color: #008000;">//</span><span style="color: #008000;">线程的父类是Thread
</span><span style="color: #008000;">//</span><span style="color: #008000;">new MyThread().start();

</span><span style="color: #008000;">//</span><span style="color: #008000;">线程的接口Runnable
</span><span style="color: #008000;">//</span><span style="color: #008000;">Runnable r = RunnableTmpl();</span><span style="color: #008000;">//</span><span style="color: #008000;">多态
</span><span style="color: #008000;">//</span><span style="color: #008000;">new Runnable(r).start();</span></pre>
</div>
<p>&nbsp;</p>
<h3><strong>Thread类的常用方法</strong></h3>
<p><strong>获取线程的名称：</strong></p>
<ol>
<li>使用Thread类中的方法getName() 返回该线程的名称。</li>
<li>static Thread currentThread() 返回对当前正在执行的线程对象的引用。</li>
</ol>
<p><strong>设置线程的名称：</strong></p>
<ol>
<li>使用Thread类中的方法setName(名字)</li>
<li>void setName(String name) 改变线程的名称，使之参数 name相同。</li>
</ol>
<ul>
<li>public void start():使该线程开始执行；Java虚拟机调用该线程的run方法</li>
<li>public void run():此线程要执行的任务在此处定义代码</li>
<li>public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行）。</li>
</ul>
<p>&nbsp;</p>
<h2>线程的安全问题</h2>
<h3><strong>模拟卖票案例</strong></h3>
<p>创建三个的线程，同时开启，对共享的票进行出售</p>
<p><br /><img src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190801211824600-1725164345.jpg" alt="" /></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> RunnableImpl implementsc Runnable{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义一个多线程共享的票源</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> ticket = 100<span style="color: #000000;">；
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置线程任务：买票</span>
<span style="color: #000000;">    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">使用死循环，让卖票操作重复执行</span>
        <span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">先判断票是否存在</span>
            <span style="color: #0000ff;">if</span>(ticket&gt;0<span style="color: #000000;">){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">提高安全问题出现的概率，让程序睡眠</span>
                <span style="color: #0000ff;">try</span><span style="color: #000000;">{
                    Thread.sleep(</span>10<span style="color: #000000;">);
                }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e){
                    e.printStackTrace();
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">票存在，卖票 ticket--</span>
                System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"<span style="color: #000000;">);
                ticket </span>--<span style="color: #000000;">;
            }
        }
    }
}


</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建Runnable接口的实现类对象</span>
        RunnableImpl run = <span style="color: #0000ff;">new</span><span style="color: #000000;"> RunnableImpl();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span>
        Thread t0 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(run);        
        Thread t1 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(run);        
        Thread t2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(run);        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用start方法开启多线程</span>
<span style="color: #000000;">        t0.start();
        t1.start();
        t2.start();
    }
}</span></pre>
</div>
<p><strong>这样会导致一个结果</strong></p>
<ul>
<li>Thread-0 --&gt;正在卖第1张票</li>
<li>Thread-1 --&gt;正在卖第1张票</li>
<li>Thread-2 --&gt;正在卖第0张票</li>
</ul>
<h3><strong>解决线程安全问题的一种方案</strong>：使用同步代码块</h3>
<p><strong>格式：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
    syncharonized(锁对象){
        可能会出现线程安全问题的代码（访问了共享数据的代码）        
    }</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>注意：</strong></p>
<ul>
<li>通过代码块中的锁对象，可以使用任意的对象</li>
<li>但是必须要保证多个线程使用的锁对象是同一个</li>
</ul>
<h3><strong>锁对象作用</strong></h3>
<ul>
<li>把同步代码块锁住，只让一个线程在同步代码中执行</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> RunnableImpl implementsc Runnable{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义一个多线程共享的票源</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> ticket = 100<span style="color: #000000;">；
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">设置线程任务：买票</span>
<span style="color: #000000;">    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">使用死循环，让卖票操作重复执行</span>
        <span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">同步代码块</span>
<span style="color: #000000;">            syncharonized(obj){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">先判断票是否存在</span>
                <span style="color: #0000ff;">if</span>(ticket&gt;0<span style="color: #000000;">){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">提高安全问题出现的概率，让程序睡眠</span>
                    <span style="color: #0000ff;">try</span><span style="color: #000000;">{
                        Thread.sleep(</span>10<span style="color: #000000;">);
                    }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e){
                        e.printStackTrace();
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">票存在，卖票 ticket--</span>
                    System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"<span style="color: #000000;">);
                    ticket </span>--<span style="color: #000000;">;    
            }</span></pre>
</div>
<p>&nbsp;</p>
<h3>解决线程安全问题的二种方案：使用同步方法</h3>
<p><strong>使用步骤:</strong></p>
<ol>
<li>把访问了共享数据的代码抽取出来，放到一个方法中</li>
<li>在方法上添加synchronized修饰符</li>
</ol>
<p><strong>格式：</strong>定义方法的格式</p>
<div class="cnblogs_code">
<pre>    修饰符 <span style="color: #0000ff;">synchronized</span><span style="color: #000000;"> 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码（访问了共享数据的代码）
    }</span></pre>
</div>
<h3><br />解决线程安全问题的三种方案：使用Lock锁</h3>
<p><strong>java.util.concurrent.Locks.Lock接口</strong><br />Lock实现提供了比使用synchronized 方法和语句可获得的更广泛的锁定操作。</p>
<p><strong>Lock接口中的方法：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　void</span><span style="color: #000000;"> Lock()获取锁
　　</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> unLock() 释放锁
java.util.concurrent.Locks.ReentrantLock </span><span style="color: #0000ff;">implements</span> Lock 接口</pre>
</div>
<h3><strong>使用步骤：</strong></h3>
<ol>
<li>在成员位置创建一个ReentrantLock对象</li>
<li>在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取锁</li>
<li>在可能会出现安全问题的代码前调后用Lock接口中的方法unLock释放锁</li>
</ol>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">1.在成员位置创建一个ReentrantLock对象</span>
Lock l = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ReentrantLock();

@Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">使用死循环，让卖票操作重复执行</span>
        <span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">2. 在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取锁</span>
<span style="color: #000000;">            l.lock();
            
            </span><span style="color: #008000;">//</span><span style="color: #008000;">同步代码块</span>
<span style="color: #000000;">            syncharonized(obj){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">先判断票是否存在</span>
                <span style="color: #0000ff;">if</span>(ticket&gt;0<span style="color: #000000;">){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">提高安全问题出现的概率，让程序睡眠</span>
                    <span style="color: #0000ff;">try</span><span style="color: #000000;">{
                        Thread.sleep(</span>10<span style="color: #000000;">);
                    }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e){
                        e.printStackTrace();
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">票存在，卖票 ticket--</span>
                    System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"<span style="color: #000000;">);
                    ticket </span>--<span style="color: #000000;">;    
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">3.在可能会出现安全问题的代码前调后用Lock接口中的方法unLock释放锁</span>
                l.unLock();<span style="color: #008000;">//</span><span style="color: #008000;">无论程序释放异常，锁都会释放</span>
            </pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>等待唤醒机制</h2>
<h3><strong>线程的状态</strong></h3>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190804173143100-1782786495.jpg" alt="" /></p>
<p>&nbsp;</p>
<ol>
<li><strong>NEW</strong>&nbsp; &nbsp;至今尚未启动的线程处于这种状态</li>
<li><strong>RUNNABLE</strong>&nbsp; &nbsp;正在Java虚拟机中执行的线程处于这种状态</li>
<li><strong>BLOCKED　</strong>受阻塞并等待某个监视器锁的线程处于这种状态</li>
<li><strong>WAITING　</strong>无限期的等待另一个线程来执行某一待定操作的线程处于这种状态</li>
<li><strong>TIMED_WAITNG　</strong>等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态</li>
<li><strong>TERMINATED</strong>　已退出的线程处于这种状态。</li>
</ol>
<ul>
<li><strong>阻塞状态：</strong>具有cpu的执行资格，等待cpu空闲时执行</li>
<li><strong>休眠状态：</strong>放弃cpu的执行资格，cpu空闲，也不执行</li>
</ul>
<h3><br />等待唤醒案例分析</h3>
<p><strong>public static void sleep(Long millis):</strong>使用当前正在执行的线程以指定的毫秒数暂停（暂停停止执行).</p>
<ul>
<li>毫秒数结束之后，线程继续执行</li>

</ul>
<h3>等待唤醒案例：线程之间的通信</h3>
<ul>
<li>	创建一个顾客线程（消费者）：告知老板要包子的中类和数量，调用wait方法，放弃cpu的执行，进入到WAITNG状态（无限等待）</li>
<li>	创建一个老板线程（生产者）：花了5秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子</li>

</ul>
<p><strong>注意：</strong></p>
<ul>
<li>	顾客和老板线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行</li>
<li>	同步使用的锁对象必须保证唯一</li>
<li>	只有锁对象才能调用<strong>wait和notify</strong>方法</li>

</ul>
<h2>Object类中的方法</h2>
<p><strong>void wait()</strong></p>
<ul>
<li>	在其他线程调用此对象的notify()方法或notify() 方法前，导致当前线程等待。</li>

</ul>
<p><strong>void notify()</strong></p>
<ul>
<li>	唤醒在此对象监视器上等待的单个线程。</li>
<li>	会继续执行wait方法之后的代码</li>

</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建锁对象，保证唯一</span>
        Object obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个顾客线程（消费者）</span>
        <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(){
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一直等着买包子</span>
            <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">保证等待和唤醒的线程只能有一个执行，需要使用同步技术</span>
<span style="color: #000000;">                    syncharonized (obj){
                        System.out.println(</span>"告知老板要的包子的种类和数量"<span style="color: #000000;">);
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用wait方法，放弃cpu的执行，进入到WAITNG状态（无限等待）</span>
                        <span style="color: #0000ff;">try</span><span style="color: #000000;">{
                            obj.wait();
                        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e){
                            e.printStackTrace();
                        }
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">唤醒之后执行的代码</span>
                        System.out.println("包子已经做好了，开吃！"<span style="color: #000000;">);
                        System.out.println(</span>"--------------"<span style="color: #000000;">);
                    }
                }
            }
        }.start();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个老板线程（生产者）</span>
        <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(){
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">一直做包子</span>
                <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">花5秒做包子</span>
                    <span style="color: #0000ff;">try</span><span style="color: #000000;">{
                        Thread.sleep(</span>5000);<span style="color: #008000;">//</span><span style="color: #008000;">花5秒做包子</span>
                    }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e);
                        e.printStackTrace();
                    }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">保证等待和唤醒只能有一个在执行,需要使用同步技术</span>
<span style="color: #000000;">                syncharonized (obj){
                    System.out.println(</span>"花了5秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子"<span style="color: #000000;">);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">做好包子之后，调用notify方法，唤醒顾客吃包子</span>
<span style="color: #000000;">                    obj.notify();
                }
            }
        }.start();
    }
  </span></pre>
</div>
<p>&nbsp;</p>
<p><br />  </p>
<h3>Object类中wait带参方法和notify</h3>
<p>进入到<strong>TimeWaiting（计时等待）</strong>有两种方法</p>
<ol>
<li>使用sleep(Long m)方法，在毫秒值结束之后，线程睡醒进入到Runnable/Blacked状态</li>
<li>使用wait(Long m))方法，wait方法如果在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/Blacked状态</li>

</ol>
<h3>唤醒的方法：</h3>
<ol>
<li>	void notify()唤醒在此对象监视器上等待的单个线程。</li>
<li>	void notifyAll()唤醒在此对象监视器上等待的所有线程。</li>

</ol>
<h3>调用wait和notify方法需要注意的细节</h3>
<ol>
<li>wait方法与notify方法必须<strong>要由同一个锁对象调用。</strong>因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程</li>
<li>wait方法与notify方法<strong>是属于Object类的方法的</strong>。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须<strong>要在同步代码块或者是同步函数中使用</strong>。因为：必须要通过锁对象调用这两个方法。</li>

</ol>
<h2 style="text-align: center;"><br />线程间通信</h2>
<p><br /><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同<br /><strong>重点：</strong>有效的利用资源</p>
<h3>分析：需要那些类</h3>
<p><strong>1 资源类：包子类</strong></p>
<ul>
<li>	设置包子的属性</li>
<li>	包子的状态：有true 没有false</li>

</ul>
<p><strong>2 生产者（包子铺）类：是一个线程类，可以继承Thread</strong></p>
<ul>
<li><strong>	设置线程任务（run):</strong>生产包子</li>
<li>	对包子的状态进行判断</li>

</ul>
<p><strong>	true:</strong>有包子</p>
<ul>
<li>		包子铺调用<strong>wait方法</strong>进入等待状态</li>

</ul>
<p><strong>	false:</strong>没有包子</p>
<ul>
<li>		包子铺生产包子</li>
<li>		增加一些多样性：交替生产两种包子</li>
<li><strong>			有两种状态（i%2 == 0 ）</strong></li>
<li>		包子铺生产好了包子</li>
<li>		修改包子的状态为true有</li>
<li>		唤醒吃货线程，让吃货线程吃包子</li>

</ul>
<p><strong>3 消费者（吃货）类：是一个线程类，可以继承Thread</strong></p>
<ul>
<li><strong>	设置线程任务（run）</strong>：吃包子</li>
<li>	对包子的状态进行判断</li>

</ul>
<p><strong>	false：</strong>没有包子</p>
<ul>
<li>		吃货线程调用wait方法进入等待状态</li>

</ul>
<p><strong>	true：</strong>有包子</p>
<ul>
<li>		吃货吃包子</li>
<li>		吃货吃完包子</li>
<li>		修改包子的状态为<strong>false没有</strong></li>
<li>		吃货唤醒包子铺线程，生产包子</li>

</ul>
<p><br /><strong>4 测试类:</strong></p>
<ul>
<li><strong>	包含main方法，</strong>程序执行的入口，启动程序</li>
<li>	创建包子对象：</li>
<li>	创建包子铺线程，开启，生产包子</li>
<li>	创建吃货线程，开启，吃包子；</li>

</ul>
<p><strong>注意：</strong></p>
<ul>
<li>	包子铺线程和包子<strong>线程关系--&gt;通信（互斥）、</strong></li>
<li>	必须同时同步技术保证两个线程只能有一个在执行</li>
<li><strong>	锁对象必须保证唯一，可以使用包子对象作为锁对象</strong></li>
<li>	包子铺类和吃货的类就需要把包子对象作为参数传递进来</li>

</ul>
<ol>
<li>需要在成员位置创建一个包子变量</li>
<li>使用带参数的构造方法，为这个包子变量赋值</li>

</ol>
<h2>线程池</h2>
<p><strong>线程池概念：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源。</p>
<p><strong>线程池：容器--&gt;集合(ArrayList,HashSet,LinkedList&lt;Thread&gt;,HashMap)</strong></p>
<ul>
<li>	当程序第一次启动的时候，创建多个线程，保存到一个集合中</li>
<li>	当我们想要使用线程的时候，就可以从集合中取出来线程使用</li>

</ul>
<div class="cnblogs_code">
<pre>Thread t = list.remove(0<span style="color: #000000;">);返回的是被移除的元素，（线程只能被一个任务使用）
Thread t </span>= linked.removeFist();</pre>
</div>
<ul>
<li>当我们使用完毕线程，需要把线程归还给线程池</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">list.add(t);
linked.addLast(t);</span></pre>
</div>
<p><br /><strong>	在JDK1.5 之后，JDK内置了线程池，我们可以直接使用</strong><br /><br /><strong>	合理利用线程池带来的好处：</strong></p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性。</li>

</ol>
<p><br /><strong>线程池的代码实现：JDK1.5之后提供的</strong></p>
<div class="cnblogs_code">
<pre>java.util.concurrent.Executors;线程池的工厂类，用来生成线程池</pre>
</div>
<p><strong>Executors类中的静态方法：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">static</span> ExecutorService newFixedThreadPool(<span style="color: #0000ff;">int</span> nThreads)创建一个可重用的固定线程数的线程池</pre>
</div>
<p><strong>参数：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> nTherad:创建线程池中包含的线程数量</pre>
</div>
<p><strong>返回值：</strong></p>
<div class="cnblogs_code">
<pre>ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程）</pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>	java.util.concurrent.ExecutorService:线程池接口</strong></p>
<ul>
<li>		用来从线程池中获取线程，调用start方法开启多线程,执行线程任务</li>

</ul>
<div class="cnblogs_code">
<pre>submit(Runnable task)提交一个Runnable任务用于执行</pre>
</div>
<p><strong> 关闭/销毁线程池的方法</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">void</span> shutdown()</pre>
</div>
<p>&nbsp;</p>
<h3><br />	线程池的使用步骤：</h3>
<ol>
<li>使用线程池的工厂类Executors里边提供的静态方法，<strong>newFixedThreadPool生产一个指定线程数量的线程池</strong></li>
<li>创建一个类，<strong>实现Runnable接口，重写了run方法：用来设置线程任务</strong></li>
<li><strong>调用ExecutorService中的方法submit,传递线程任务（实现类），开启线程，执行run方法。</strong></li>
<li>调用ExecutorService中的方法<strong>shotdown销毁线程池</strong>（不建议执行）</li>

</ol>
<div class="cnblogs_code">
<pre>ExecutorService es = Executors.newFixedThreadPool(2<span style="color: #000000;">)
es.submit(</span><span style="color: #0000ff;">new</span> RunnableImpl());<span style="color: #008000;">//</span><span style="color: #008000;">创建了一个新的线程执行</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Lambda表达式</h2>
<p><strong>函数式编程思想概述</strong><br /><strong>---强调做什么，而不是以什么形式做</strong></p>
<p><strong>面向对象的思想：</strong></p>
<ul>
<li>	做一件事情，找一个能解决这个的事情的对象，调用对象的方法，完成事情</li>

</ul>
<p><strong>函数式编程思想</strong></p>
<ul>
<li>	只要能获取到结果，谁去做的，这么做的都不重要，重视的是结果，不重视过程</li>

</ul>
<h3><br />传统写法和Lambda写法对比</h3>
<h3><strong>传统写法</strong></h3>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名内部类，实现多线程
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Runnable task = new Runnable()</span>
        Runnable task = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable(){
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){<span style="color: #008000;">//</span><span style="color: #008000;">覆盖重写抽象方法</span>
                System.out.println(Thread.currentThread().getName()+"新线程创建了"<span style="color: #000000;">);
                System.out.println(</span>"多线程任务执行！"<span style="color: #000000;">);
                
            }
        };
        </span><span style="color: #0000ff;">new</span> Thread(task).start();<span style="color: #008000;">//</span><span style="color: #008000;">开启线程</span>
<span style="color: #000000;">    
    }
    
}</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>匿名内部类的好处与弊端</strong></p>
<ul>
<li>一方面，匿名内部类可以帮助我们省去实现类的定义；</li>
<li>另一方面，匿名内部类的语法确实太复杂了</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名内部类，实现多线程
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Runnable task = new Runnable()</span>
        <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable(){
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> run(){<span style="color: #008000;">//</span><span style="color: #008000;">覆盖重写抽象方法</span>
                System.out.println(Thread.currentThread().getName()+"新线程创建了"<span style="color: #000000;">);
                System.out.println(</span>"多线程任务执行！"<span style="color: #000000;">);
            }
        }).start();</span><span style="color: #008000;">//</span><span style="color: #008000;">开启线程</span>
<span style="color: #000000;">    
    }
    
}</span></pre>
</div>
<p>&nbsp;</p>
<h3><br />Lambda写法</h3>
<p><strong>()-&gt;{}</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">匿名内部类，实现多线程
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Runnable task = new Runnable()</span>
        <span style="color: #0000ff;">new</span> Thread(()-&gt;{<span style="color: #008000;">//</span><span style="color: #008000;">覆盖重写抽象方法</span>
                System.out.println(Thread.currentThread().getName()+"新线程创建了"<span style="color: #000000;">);
                System.out.println(</span>"多线程任务执行！"<span style="color: #000000;">);
            }
        ).start();</span><span style="color: #008000;">//</span><span style="color: #008000;">开启线程</span>
<span style="color: #000000;">    
    }
    
}</span></pre>
</div>
<p>&nbsp;</p>
<h3><br />Lambda表达式的标准格式</h3>
<p><strong>	由三部分组成：</strong></p>
<ol>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>

</ol>
<p><strong>	格式：</strong></p>
<ul>
<li>		<strong>（参数列表）-&gt; {一些重写方法的代码}：</strong></li>

</ul>
<p><strong>	解释说明格式：</strong></p>
<ul>
<li><strong>		():接口中抽象方法的参数列表，没有参数，就空着</strong></li>
<li><strong>		-&gt;:传递的意思，把参数传递给方法体{}</strong></li>
<li><strong>		{}:重写接口的抽象方法的方法体</strong></li>

</ul>
<p><strong>Lambda表达式：是可推导，可以省略</strong></p>
<ul>
<li><strong>凡是根据上下文推导出来的内容，都可以省略书写</strong></li>

</ul>
<p><strong>可以省略的内容</strong>：</p>
<ol>
<li>（参数列表）：括号中的参数列表的数据类型，可以省略不写</li>
<li>（参数列表）：括号中的参数如果只有一个，那么类型和（）都可以省略 </li>
<li>（一些代码）：如果（）中的代码只有一行，无论是否由返回值，都可以省略（{}，return，分号）</li>

</ol>
<p><strong>		注意：</strong>要省略<strong>{}，return，分号</strong>必须一起省略</p>
<ul>
<li>		JDK1.7 版本之前，创建集合对象必须把前后的泛型都写上</li>
<li>		JDK1.7 版本之后，=号后边的泛型可以省略，后边的泛型可以根据前边的泛型推导出来</li>

</ul>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">new</span> Thread(()-&gt;{<span style="color: #008000;">//</span><span style="color: #008000;">覆盖重写抽象方法</span>
        System.out.println(Thread.currentThread().getName()+"新线程创建了"<span style="color: #000000;">);
    }
).start();</span><span style="color: #008000;">//</span><span style="color: #008000;">开启线程</span>
        
    <span style="color: #0000ff;">new</span> Thread(()-&gt;System.out.println(Thread.currentThread().getName()+"新线程创建了")).start();<span style="color: #008000;">//</span><span style="color: #008000;">开启线程</span></pre>
</div>
<p>&nbsp;</p>
<h3>Lambda的使用前提</h3>
<ol>
<li>使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法；</li>
<li>使用Lambda必须具有上下文推断。</li>
</ol>
<p><strong>备注：</strong>有且仅有一个抽象方法的接口，成为<strong>&ldquo;函数式接口&rdquo;。</strong></p>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：Lambda表达式</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11300138.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 04 Aug 2019 14:12:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11300138.html</guid><description><![CDATA[<h2>Lambda表达式</h2>
<p><strong>函数式编程思想概述</strong><br /><strong>---强调做什么，而不是以什么形式做</strong></p>
<p><strong>面向对象的思想：</strong></p>
<ul>
<li>做一件事情，找一个能解决这个的事情的对象，调用对象的方法，完成事情</li>

</ul>
<p><strong>函数式编程思想</strong></p>
<ul>
<li>只要能获取到结果，谁去做的，这么做的都不重要，重视的是结果，不重视过程</li>

</ul>
<h3><br />传统写法和Lambda写法对比</h3>
<h3><strong>传统写法</strong></h3>
<div class="cnblogs_code">
<pre>public class<span> CaiNiao{
    public static void<span> main(String[] args){
        //匿名内部类，实现多线程
        //Runnable task = new Runnable()
        Runnable task = new<span> Runnable(){
            @Override
            public void run(){//覆盖重写抽象方法
                System.out.println(Thread.currentThread().getName()+"新线程创建了"<span>);
                System.out.println("多线程任务执行！"<span>);
                
            }
        };
        new Thread(task).start();//开启线程
<span>    
    }
    
}</span></span></span></span></span></span></pre>
</div>
<p><strong>匿名内部类的好处与弊端</strong></p>
<ul>
<li>一方面，匿名内部类可以帮助我们省去实现类的定义；</li>
<li>另一方面，匿名内部类的语法确实太复杂了</li>
</ul>
<div class="cnblogs_code">
<pre>public class<span> CaiNiao{
    public static void<span> main(String[] args){
        //匿名内部类，实现多线程
        //Runnable task = new Runnable()
        new Thread(new<span> Runnable(){
            @Override
            public void run(){//覆盖重写抽象方法
                System.out.println(Thread.currentThread().getName()+"新线程创建了"<span>);
                System.out.println("多线程任务执行！"<span>);
            }
        }).start();//开启线程
<span>    
    }
    
}</span></span></span></span></span></span></pre>
</div>
<h3>Lambda写法</h3>
<p><strong>()-&gt;{}</strong></p>
<div class="cnblogs_code">
<pre>public class<span> CaiNiao{
    public static void<span> main(String[] args){
        //匿名内部类，实现多线程
        //Runnable task = new Runnable()
        new Thread(()-&gt;{//覆盖重写抽象方法
                System.out.println(Thread.currentThread().getName()+"新线程创建了"<span>);
                System.out.println("多线程任务执行！"<span>);
            }
        ).start();//开启线程
<span>    
    }
    
}</span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<h3>Lambda表达式的标准格式</h3>
<p><strong>由三部分组成：</strong></p>
<ol>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ol>
<p><strong>格式：</strong></p>
<ul>
<li><strong>（参数列表）-&gt; {一些重写方法的代码}：</strong></li>
</ul>
<p><strong>解释说明格式：</strong></p>
<ul>
<li><strong>():接口中抽象方法的参数列表，没有参数，就空着</strong></li>
<li><strong>-&gt;:传递的意思，把参数传递给方法体{}</strong></li>
<li><strong>{}:重写接口的抽象方法的方法体</strong></li>
</ul>
<p><strong>Lambda表达式：是可推导，可以省略</strong></p>
<ul>
<li><strong>凡是根据上下文推导出来的内容，都可以省略书写</strong></li>
</ul>
<p><strong>可以省略的内容</strong>：</p>
<ol>
<li>（参数列表）：括号中的参数列表的数据类型，可以省略不写</li>
<li>（参数列表）：括号中的参数如果只有一个，那么类型和（）都可以省略</li>
<li>（一些代码）：如果（）中的代码只有一行，无论是否由返回值，都可以省略（{}，return，分号）</li>
</ol>
<p><strong>注意：</strong>要省略<strong>{}，return，分号</strong>必须一起省略</p>
<ul>
<li>JDK1.7 版本之前，创建集合对象必须把前后的泛型都写上</li>
<li>JDK1.7 版本之后，=号后边的泛型可以省略，后边的泛型可以根据前边的泛型推导出来</li>
</ul>
<div class="cnblogs_code">
<pre>    new Thread(()-&gt;{//覆盖重写抽象方法
        System.out.println(Thread.currentThread().getName()+"新线程创建了"<span>);
    }
).start();//开启线程
        
    new Thread(()-&gt;System.out.println(Thread.currentThread().getName()+"新线程创建了")).start();//开启线程</span></pre>
</div>
<p>&nbsp;</p>
<h3>Lambda的使用前提</h3>
<ol>
<li>使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法；</li>
<li>使用Lambda必须具有上下文推断。</li>
</ol>
<p><strong>备注：</strong>有且仅有一个抽象方法的接口，成为<strong>&ldquo;函数式接口&rdquo;。</strong></p>]]></description></item><item><title>Java学习：线程池</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11299988.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 04 Aug 2019 13:50:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11299988.html</guid><description><![CDATA[<h2 style="text-align: center;">线程池</h2>
<p><strong>线程池概念：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源。</p>
<p><strong>线程池：容器--&gt;集合(ArrayList,HashSet,LinkedList&lt;Thread&gt;,HashMap)</strong></p>
<ul>
<li>当程序第一次启动的时候，创建多个线程，保存到一个集合中</li>
<li>当我们想要使用线程的时候，就可以从集合中取出来线程使用</li>
</ul>
<div class="cnblogs_code">
<pre>Thread t = list.remove(0<span>);返回的是被移除的元素，（线程只能被一个任务使用）
Thread t = linked.removeFist();</span></pre>
</div>
<ul>
<li>当我们使用完毕线程，需要把线程归还给线程池</li>
</ul>
<div class="cnblogs_code">
<pre><span>list.add(t);
linked.addLast(t);</span></pre>
</div>
<p><br /><strong>在JDK1.5 之后，JDK内置了线程池，我们可以直接使用</strong><br /><br /><strong>合理利用线程池带来的好处：</strong></p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性。</li>


</ol>
<h3><br />线程池的代码实现：JDK1.5之后提供的</h3>
<div class="cnblogs_code">
<pre>java.util.concurrent.Executors;线程池的工厂类，用来生成线程池</pre>
</div>
<p><strong>Executors类中的静态方法：</strong></p>
<div class="cnblogs_code">
<pre>static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用的固定线程数的线程池</pre>
</div>
<p><strong>参数：</strong></p>
<div class="cnblogs_code">
<pre>int nTherad:创建线程池中包含的线程数量</pre>
</div>
<p><strong>返回值：</strong></p>
<div class="cnblogs_code">
<pre>ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程）</pre>
</div>
<p><strong>java.util.concurrent.ExecutorService:线程池接口</strong></p>
<ul>
<li>用来从线程池中获取线程，调用start方法开启多线程,执行线程任务</li>
</ul>
<div class="cnblogs_code">
<pre>submit(Runnable task)提交一个Runnable任务用于执行</pre>
</div>
<p><strong>关闭/销毁线程池的方法</strong></p>
<div class="cnblogs_code">
<pre>void shutdown()</pre>
</div>
<p>&nbsp;</p>
<h3>线程池的使用步骤：</h3>
<ol>
<li>使用线程池的工厂类Executors里边提供的静态方法，<strong>newFixedThreadPool生产一个指定线程数量的线程池</strong></li>
<li>创建一个类，<strong>实现Runnable接口，重写了run方法：用来设置线程任务</strong></li>
<li><strong>调用ExecutorService中的方法submit,传递线程任务（实现类），开启线程，执行run方法。</strong></li>
<li>调用ExecutorService中的方法<strong>shotdown销毁线程池</strong>（不建议执行）</li>
</ol>
<div class="cnblogs_code">
<pre>ExecutorService es = Executors.newFixedThreadPool(2<span>)
es.submit(new RunnableImpl());//创建了一个新的线程执行</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：线程间通信</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11299892.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 04 Aug 2019 13:35:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11299892.html</guid><description><![CDATA[<h2 style="text-align: center;">线程间通信</h2>
<p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同<br /><strong>重点：</strong>有效的利用资源</p>
<h3>分析：需要那些类</h3>
<h4><strong>1 资源类：包子类</strong></h4>
<ul>
<li>设置包子的属性</li>
<li>包子的状态：有true 没有false</li>

</ul>
<h3><strong>2 生产者（包子铺）类：是一个线程类，可以继承Thread</strong></h3>
<ul>
<li><strong>设置线程任务（run):</strong>生产包子</li>
<li>对包子的状态进行判断</li>

</ul>
<p><strong>true:</strong>有包子</p>
<ul>
<li>包子铺调用<strong>wait方法</strong>进入等待状态</li>

</ul>
<p><strong>false:</strong>没有包子</p>
<ul>
<li>包子铺生产包子</li>
<li>增加一些多样性：交替生产两种包子</li>
<li><strong>有两种状态（i%2 == 0 ）</strong></li>
<li>包子铺生产好了包子</li>
<li>修改包子的状态为true有</li>
<li>唤醒吃货线程，让吃货线程吃包子</li>

</ul>
<h3><strong>3 消费者（吃货）类：是一个线程类，可以继承Thread</strong></h3>
<ul>
<li><strong>设置线程任务（run）</strong>：吃包子</li>
<li>对包子的状态进行判断</li>

</ul>
<p><strong>false：</strong>没有包子</p>
<ul>
<li>吃货线程调用wait方法进入等待状态</li>

</ul>
<p><strong>true：</strong>有包子</p>
<ul>
<li>吃货吃包子</li>
<li>吃货吃完包子</li>
<li>修改包子的状态为<strong>false没有</strong></li>
<li>吃货唤醒包子铺线程，生产包子</li>

</ul>
<p><br /><strong>4 测试类:</strong></p>
<ul>
<li><strong>包含main方法，</strong>程序执行的入口，启动程序</li>
<li>创建包子对象：</li>
<li>创建包子铺线程，开启，生产包子</li>
<li>创建吃货线程，开启，吃包子；</li>

</ul>
<p><strong>注意：</strong></p>
<ul>
<li>包子铺线程和包子<strong>线程关系--&gt;通信（互斥）、</strong></li>
<li>必须同时同步技术保证两个线程只能有一个在执行</li>
<li><strong>锁对象必须保证唯一，可以使用包子对象作为锁对象</strong></li>
<li>包子铺类和吃货的类就需要把包子对象作为参数传递进来</li>

</ul>
<ol><ol>
<li>需要在成员位置创建一个包子变量</li>
<li>使用带参数的构造方法，为这个包子变量赋值</li>
</ol></ol>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建锁对象，保证唯一</span>
        Object obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个顾客线程（消费者）</span>
        <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(){
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">一直等着买包子</span>
            <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">保证等待和唤醒的线程只能有一个执行，需要使用同步技术</span>
<span style="color: #000000;">                    syncharonized (obj){
                        System.out.println(</span>"告知老板要的包子的种类和数量"<span style="color: #000000;">);
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用wait方法，放弃cpu的执行，进入到WAITNG状态（无限等待）</span>
                        <span style="color: #0000ff;">try</span><span style="color: #000000;">{
                            obj.wait();
                        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e){
                            e.printStackTrace();
                        }
                        </span><span style="color: #008000;">//</span><span style="color: #008000;">唤醒之后执行的代码</span>
                        System.out.println("包子已经做好了，开吃！"<span style="color: #000000;">);
                        System.out.println(</span>"--------------"<span style="color: #000000;">);
                    }
                }
            }
        }.start();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个老板线程（生产者）</span>
        <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(){
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">一直做包子</span>
                <span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">花5秒做包子</span>
                    <span style="color: #0000ff;">try</span><span style="color: #000000;">{
                        Thread.sleep(</span>5000);<span style="color: #008000;">//</span><span style="color: #008000;">花5秒做包子</span>
                    }<span style="color: #0000ff;">catch</span><span style="color: #000000;">(InterruptedException e);
                        e.printStackTrace();
                    }
                </span><span style="color: #008000;">//</span><span style="color: #008000;">保证等待和唤醒只能有一个在执行,需要使用同步技术</span>
<span style="color: #000000;">                syncharonized (obj){
                    System.out.println(</span>"花了5秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子"<span style="color: #000000;">);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">做好包子之后，调用notify方法，唤醒顾客吃包子</span>
<span style="color: #000000;">                    obj.notify();
                }
            }
        }.start();
    }
  </span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：等待唤醒机制</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11299824.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 04 Aug 2019 13:23:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/04/11299824.html</guid><description><![CDATA[<h2 style="text-align: center;">等待唤醒机制</h2>
<p><strong>线程的状态</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190804173143100-1782786495.jpg" alt="" /></p>
<ol>
<li><strong>NEW</strong>&nbsp; &nbsp;至今尚未启动的线程处于这种状态</li>
<li><strong>RUNNABLE</strong>&nbsp; &nbsp;正在Java虚拟机中执行的线程处于这种状态</li>
<li><strong>BLOCKED　</strong>受阻塞并等待某个监视器锁的线程处于这种状态</li>
<li><strong>WAITING　</strong>无限期的等待另一个线程来执行某一待定操作的线程处于这种状态</li>
<li><strong>TIMED_WAITNG　</strong>等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态</li>
<li><strong>TERMINATED</strong>　已退出的线程处于这种状态。</li>
</ol>
<ul>
<li><strong>阻塞状态：</strong>具有cpu的执行资格，等待cpu空闲时执行</li>
<li><strong>休眠状态：</strong>放弃cpu的执行资格，cpu空闲，也不执行</li>
</ul>
<h2><br />等待唤醒案例分析</h2>
<p><strong>public static void sleep(Long millis):</strong>使用当前正在执行的线程以指定的毫秒数暂停（暂停停止执行).</p>
<ul>
<li>毫秒数结束之后，线程继续执行</li>


</ul>
<h3>等待唤醒案例：线程之间的通信</h3>
<ul>
<li>创建一个顾客线程（消费者）：告知老板要包子的中类和数量，调用wait方法，放弃cpu的执行，进入到WAITNG状态（无限等待）</li>
<li>创建一个老板线程（生产者）：花了5秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子</li>


</ul>
<p><strong>注意：</strong></p>
<ul>
<li>顾客和老板线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行</li>
<li>同步使用的锁对象必须保证唯一</li>
<li>只有锁对象才能调用<strong>wait和notify</strong>方法</li>


</ul>
<p>&nbsp;</p>
<h2>Object类中的方法</h2>
<p><strong>void wait()</strong></p>
<ul>
<li>在其他线程调用此对象的notify()方法或notify() 方法前，导致当前线程等待。</li>


</ul>
<p><strong>void notify()</strong></p>
<ul>
<li>唤醒在此对象监视器上等待的单个线程。</li>
<li>会继续执行wait方法之后的代码</li>


</ul>
<div class="cnblogs_code">
<pre>public class<span> CaiNiao{
    public static void<span> main(String[] args){
        //创建锁对象，保证唯一
        Object obj = new<span> Object();
        //创建一个顾客线程（消费者）
        new<span> Thread(){
            @Override
            public void<span> run(){
            //一直等着买包子
            while(true<span>){
                    //保证等待和唤醒的线程只能有一个执行，需要使用同步技术
<span>                    syncharonized (obj){
                        System.out.println("告知老板要的包子的种类和数量"<span>);
                        //调用wait方法，放弃cpu的执行，进入到WAITNG状态（无限等待）
                        try<span>{
                            obj.wait();
                        }catch<span> (InterruptedException e){
                            e.printStackTrace();
                        }
                        //唤醒之后执行的代码
                        System.out.println("包子已经做好了，开吃！"<span>);
                        System.out.println("--------------"<span>);
                    }
                }
            }
        }.start();
        
        //创建一个老板线程（生产者）
        new<span> Thread(){
            @Override
            public void<span> run(){
                //一直做包子
                while(true<span>){
                    //花5秒做包子
                    try<span>{
                        Thread.sleep(5000);//花5秒做包子
                    }catch<span>(InterruptedException e);
                        e.printStackTrace();
                    }
                //保证等待和唤醒只能有一个在执行,需要使用同步技术
<span>                syncharonized (obj){
                    System.out.println("花了5秒做包子，做好包子之后，调用notify方法，唤醒顾客吃包子"<span>);
                    //做好包子之后，调用notify方法，唤醒顾客吃包子
<span>                    obj.notify();
                }
            }
        }.start();
    }
  </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>Object类中wait带参方法和notify</h3>
<p>进入到<strong>TimeWaiting（计时等待）</strong>有两种方法</p>
<ol>
<li>使用sleep(Long m)方法，在毫秒值结束之后，线程睡醒进入到Runnable/Blacked状态</li>
<li>使用wait(Long m))方法，wait方法如果在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/Blacked状态</li>
</ol>
<h3>唤醒的方法：</h3>
<ol>
<li>void notify()唤醒在此对象监视器上等待的单个线程。</li>
<li>void notifyAll()唤醒在此对象监视器上等待的所有线程。</li>
</ol>
<h3>调用wait和notify方法需要注意的细节</h3>
<ol>
<li>wait方法与notify方法必须<strong>要由同一个锁对象调用。</strong>因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程</li>
<li>wait方法与notify方法<strong>是属于Object类的方法的</strong>。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须<strong>要在同步代码块或者是同步函数中使用</strong>。因为：必须要通过锁对象调用这两个方法。</li>
</ol>
<p>&nbsp;</p>]]></description></item><item><title>我的随笔---博客园自定义样式</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/02/11287963.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 02 Aug 2019 04:56:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/02/11287963.html</guid><description><![CDATA[<h2 style="text-align: center;">我的随笔---博客园自定义样式</h2>
<p>这是我的博客园的<strong>样式代码。比较简洁。。。</strong></p>
<p>其中<strong>js样式</strong>需要去<strong>申请权限</strong>。（只要语气谦和，基本都能通过。我的是上午申请，下午就开通了）</p>
<p><strong>下面的代码案例</strong>只需<strong>复制</strong>到其中<strong>对应的选框中</strong>就可以了。原有的css样例模板就能应用，<strong>不需要</strong>禁用css。如果有细小的差别，下面<strong>每一个</strong>样例<strong>都有注释</strong>。大家可以更改调式。</p>
<p>每一个小插件<strong>都可以单独使用</strong>的哦，如果不喜欢。可以删除增加。</p>
<p>大家可以点击<strong><a href="https://www.cnblogs.com/cainiao-chuanqi/" target="_blank">我的首页</a></strong>，对比我的博客园加以更改。</p>
<h3 style="text-align: center;">页面制定CSS代码</h3>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span><span style="color: #008000;">好看的滚动条</span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 2</span> <span style="color: #800000;">::-webkit-scrollbar</span>{
<span style="color: #008080;"> 3</span> <span style="color: #ff0000;">    width</span>:<span style="color: #0000ff;">10px!important</span>;
<span style="color: #008080;"> 4</span> <span style="color: #ff0000;">    height</span>:<span style="color: #0000ff;">10px!important</span>;
<span style="color: #008080;"> 5</span> <span style="color: #ff0000;">    -webkit-appearance</span>:<span style="color: #0000ff;">none</span>;
<span style="color: #008080;"> 6</span> }
<span style="color: #008080;"> 7</span> <span style="color: #800000;">::-webkit-scrollbar-thumb</span>{
<span style="color: #008080;"> 8</span> <span style="color: #ff0000;">    height</span>:<span style="color: #0000ff;">5px</span>;<span style="color: #ff0000;">border</span>:<span style="color: #0000ff;">1px solid transparent</span>;
<span style="color: #008080;"> 9</span> <span style="color: #ff0000;">    border-top</span>:<span style="color: #0000ff;">none</span>;<span style="color: #ff0000;">border-bottom</span>:<span style="color: #0000ff;">none</span>;
<span style="color: #008080;">10</span> <span style="color: #ff0000;">    -webkit-border-radius</span>:<span style="color: #0000ff;">6px</span>;
<span style="color: #008080;">11</span> <span style="color: #ff0000;">    background-color</span>:<span style="color: #0000ff;">rgba(0,0,0,.3)</span>;
<span style="color: #008080;">12</span> <span style="color: #ff0000;">    background-clip</span>:<span style="color: #0000ff;">padding-box</span>;
<span style="color: #008080;">13</span> }
<span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 删除反对按钮,有点邪恶了 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">17</span> <span style="color: #800000;">.buryit</span>{
<span style="color: #008080;">18</span> <span style="color: #ff0000;">  display</span>:<span style="color: #0000ff;"> none</span>;
<span style="color: #008080;">19</span> }
<span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span> <span style="color: #008000;">/*</span><span style="color: #008000;">目录样式</span><span style="color: #008000;">*/</span>
<span style="color: #008080;">22</span> <span style="color: #800000;">#sideCatalog a</span>{
<span style="color: #008080;">23</span> <span style="color: #ff0000;">  font-size</span>:<span style="color: #0000ff;">12px</span>;
<span style="color: #008080;">24</span> <span style="color: #ff0000;">  font-weight</span>:<span style="color: #0000ff;">normal !important</span>;
<span style="color: #008080;">25</span> }
<span style="color: #008080;">26</span> 
<span style="color: #008080;">27</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 文章title自定义带动画样式 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">28</span> <span style="color: #800000;">.postTitle </span>{
<span style="color: #008080;">29</span> <span style="color: #ff0000;">  font-family</span>:<span style="color: #0000ff;"> "Lato", Helvetica Neue, Helvetica, Arial, sans-serif</span>;
<span style="color: #008080;">30</span> <span style="color: #ff0000;">  clear</span>:<span style="color: #0000ff;"> both</span>;
<span style="color: #008080;">31</span> <span style="color: #ff0000;">  background-color</span>:<span style="color: #0000ff;"> #FBF9F9</span>;
<span style="color: #008080;">32</span> <span style="color: #ff0000;">  margin-bottom</span>:<span style="color: #0000ff;"> 8px</span>;
<span style="color: #008080;">33</span> <span style="color: #ff0000;">  padding-top</span>:<span style="color: #0000ff;"> 5px</span>;
<span style="color: #008080;">34</span> <span style="color: #ff0000;">  padding-bottom</span>:<span style="color: #0000ff;"> 5px</span>;
<span style="color: #008080;">35</span> <span style="color: #ff0000;">  margin-top</span>:<span style="color: #0000ff;"> 17px</span>;
<span style="color: #008080;">36</span> <span style="color: #ff0000;">  border-left</span>:<span style="color: #0000ff;"> 3px solid #21759b</span>;
<span style="color: #008080;">37</span> <span style="color: #ff0000;">  padding-left</span>:<span style="color: #0000ff;"> 17px</span>;
<span style="color: #008080;">38</span> <span style="color: #ff0000;">  font-size</span>:<span style="color: #0000ff;"> 17px</span>;
<span style="color: #008080;">39</span> <span style="color: #ff0000;">  border-radius</span>:<span style="color: #0000ff;">0px</span>;
<span style="color: #008080;">40</span> }
<span style="color: #008080;">41</span> <span style="color: #800000;">.postTitle a:hover </span>{
<span style="color: #008080;">42</span> <span style="color: #ff0000;">  text-decoration</span>:<span style="color: #0000ff;"> none</span>;
<span style="color: #008080;">43</span> <span style="color: #ff0000;">  margin-left</span>:<span style="color: #0000ff;"> 17px</span>;
<span style="color: #008080;">44</span> <span style="color: #ff0000;">  color</span>:<span style="color: #0000ff;"> #E00000</span>;
<span style="color: #008080;">45</span> }
<span style="color: #008080;">46</span> <span style="color: #800000;">.postTitle a:link,
</span><span style="color: #008080;">47</span> <span style="color: #800000;">.postTitle a:visited,
</span><span style="color: #008080;">48</span> <span style="color: #800000;">.postTitle a:active </span>{
<span style="color: #008080;">49</span> <span style="color: #ff0000;">  transition</span>:<span style="color: #0000ff;"> all 0.4s linear 0s</span>;
<span style="color: #008080;">50</span> }
<span style="color: #008080;">51</span> 
<span style="color: #008080;">52</span> <span style="color: #008000;">/*</span><span style="color: #008000;">博客导航栏 </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">53</span> <span style="color: #800000;">#navList </span>{
<span style="color: #008080;">54</span> <span style="color: #ff0000;">    float</span>:<span style="color: #0000ff;"> right</span>;
<span style="color: #008080;">55</span> }
<span style="color: #008080;">56</span> 
<span style="color: #008080;">57</span> <span style="color: #800000;">#navList li </span>{
<span style="color: #008080;">58</span> <span style="color: #ff0000;">    border</span>:<span style="color: #0000ff;"> none</span>;
<span style="color: #008080;">59</span> <span style="color: #ff0000;">    font-size</span>:<span style="color: #0000ff;"> 16px</span>;
<span style="color: #008080;">60</span> }
<span style="color: #008080;">61</span> 
<span style="color: #008080;">62</span> <span style="color: #800000;">.blogStats </span>{
<span style="color: #008080;">63</span> <span style="color: #ff0000;">    display</span>:<span style="color: #0000ff;"> none</span>;
<span style="color: #008080;">64</span> }
<span style="color: #008080;">65</span> 
<span style="color: #008080;">66</span> 
<span style="color: #008080;">67</span> <span style="color: #008000;">/*</span><span style="color: #008000;">屏蔽广告 adblock </span><span style="color: #008000;">*/</span>
<span style="color: #008080;">68</span> <span style="color: #800000;">#ad_t2 </span>{
<span style="color: #008080;">69</span> <span style="color: #ff0000;">    display</span>:<span style="color: #0000ff;"> none</span>;
<span style="color: #008080;">70</span> }
<span style="color: #008080;">71</span> <span style="color: #800000;">.c_ad_block </span>{
<span style="color: #008080;">72</span> <span style="color: #ff0000;">    display</span>:<span style="color: #0000ff;"> none</span>;
<span style="color: #008080;">73</span> }
<span style="color: #008080;">74</span> 
<span style="color: #008080;">75</span> 
<span style="color: #008080;">76</span> 
<span style="color: #008080;">77</span> 
<span style="color: #008080;">78</span> <span style="color: #008000;">/*</span><span style="color: #008000;">新加  头像 img 侧边</span><span style="color: #008000;">*/</span>
<span style="color: #008080;">79</span> 
<span style="color: #008080;">80</span> <span style="color: #800000;">#newsSideBar .headImage </span>{
<span style="color: #008080;">81</span> <span style="color: #ff0000;">    padding</span>:<span style="color: #0000ff;"> auto</span>;
<span style="color: #008080;">82</span> }
<span style="color: #008080;">83</span> <span style="color: #800000;">#newsSideBar .headImage img </span>{
<span style="color: #008080;">84</span> <span style="color: #ff0000;">    border</span>:<span style="color: #0000ff;"> 3px solid #C0C0C0</span>;
<span style="color: #008080;">85</span> <span style="color: #ff0000;">    border-radius</span>:<span style="color: #0000ff;"> 50%</span>;
<span style="color: #008080;">86</span> <span style="color: #ff0000;">    width</span>:<span style="color: #0000ff;"> 150px</span>;
<span style="color: #008080;">87</span> <span style="color: #ff0000;">    margin</span>:<span style="color: #0000ff;"> auto</span>;
<span style="color: #008080;">88</span> <span style="color: #ff0000;">    display</span>:<span style="color: #0000ff;"> block</span>;
<span style="color: #008080;">89</span> }</pre>
</div>
<h3 style="text-align: center;">博客侧边公告栏&nbsp;</h3>
<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> <span style="color: #800000;">&lt;script type="text/javascript"&gt;
</span><span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> <span style="color: #008000;">/*</span><span style="color: #008000;">设置目录（侧边HTML代码）</span><span style="color: #008000;">*/</span>
<span style="color: #008080;">  4</span> <span style="color: #800000;">      //以下是锚点JS
</span><span style="color: #008080;">  5</span> <span style="color: #800000;">      var a = $(document);
</span><span style="color: #008080;">  6</span> <span style="color: #800000;">      a.ready(function() </span>{
<span style="color: #008080;">  7</span> <span style="color: #ff0000;">        var b = $('body'),
</span><span style="color: #008080;">  8</span> <span style="color: #ff0000;">          d = 'sideToolbar',
</span><span style="color: #008080;">  9</span> <span style="color: #ff0000;">          e = 'sideCatalog',
</span><span style="color: #008080;"> 10</span> <span style="color: #ff0000;">          f = 'sideCatalog-catalog',
</span><span style="color: #008080;"> 11</span> <span style="color: #ff0000;">          g = 'sideCatalogBtn',
</span><span style="color: #008080;"> 12</span> <span style="color: #ff0000;">          h = 'sideToolbar-up',
</span><span style="color: #008080;"> 13</span> <span style="color: #ff0000;">          i = '&lt;div id="sideToolbar"style="display</span>:<span style="color: #0000ff;">none</span>;<span style="color: #ff0000;">"&gt;\&lt;div class="sideCatalogBg"id="sideCatalog"&gt;\&lt;div id="sideCatalog-sidebar"&gt;\&lt;div class="sideCatalog-sidebar-top"&gt;&lt;/div&gt;\&lt;div class="sideCatalog-sidebar-bottom"&gt;&lt;/div&gt;\&lt;/div&gt;\&lt;div id="sideCatalog-catalog"&gt;\&lt;ul class="nav"style="width</span>:<span style="color: #0000ff;">225px</span>;<span style="color: #ff0000;">zoom</span>:<span style="color: #0000ff;">1"&gt;\&lt;/ul&gt;\&lt;/div&gt;\&lt;/div&gt;\&lt;a href="javascript:void(0)</span>;<span style="color: #ff0000;">"id="sideCatalogBtn"class="sideCatalogBtnDisable"&gt;&lt;/a&gt;\&lt;/div&gt;',
</span><span style="color: #008080;"> 14</span> <span style="color: #ff0000;">          j = '',
</span><span style="color: #008080;"> 15</span> <span style="color: #ff0000;">          k = 200,
</span><span style="color: #008080;"> 16</span> <span style="color: #ff0000;">          l = 0,
</span><span style="color: #008080;"> 17</span> <span style="color: #ff0000;">          m = 0,
</span><span style="color: #008080;"> 18</span> <span style="color: #ff0000;">          n = 0,
</span><span style="color: #008080;"> 19</span> <span style="color: #ff0000;">          //限制存在个数，如数量过多，则只显示h2，不显示h3
</span><span style="color: #008080;"> 20</span> <span style="color: #ff0000;">          //o, p = 13,
</span><span style="color: #008080;"> 21</span> <span style="color: #ff0000;">          o, p = 100,
</span><span style="color: #008080;"> 22</span> <span style="color: #ff0000;">          q = true,
</span><span style="color: #008080;"> 23</span> <span style="color: #ff0000;">          r = true,
</span><span style="color: #008080;"> 24</span> <span style="color: #ff0000;">          s = b;
</span><span style="color: #008080;"> 25</span> <span style="color: #ff0000;">        if(s.length === 0) {
</span><span style="color: #008080;"> 26</span> <span style="color: #ff0000;">          return
</span><span style="color: #008080;"> 27</span>         }<span style="color: #800000;">;
</span><span style="color: #008080;"> 28</span> <span style="color: #800000;">        b.append(i);
</span><span style="color: #008080;"> 29</span> <span style="color: #800000;">        //指定获取目录的范围-------------这一点非常重要，因为每个人指定的范围都不一样，所以这是要修改的地方
</span><span style="color: #008080;"> 30</span> <span style="color: #800000;">        //o = s.find(':header');
</span><span style="color: #008080;"> 31</span> <span style="color: #800000;">        o = $('#cnblogs_post_body').find(':header')
</span><span style="color: #008080;"> 32</span> <span style="color: #800000;">        if(o.length &gt; p) </span>{
<span style="color: #008080;"> 33</span> <span style="color: #ff0000;">          r = false;
</span><span style="color: #008080;"> 34</span> <span style="color: #ff0000;">          var t = s.find('h2');
</span><span style="color: #008080;"> 35</span> <span style="color: #ff0000;">          var u = s.find('h3');
</span><span style="color: #008080;"> 36</span> <span style="color: #ff0000;">          if(t.length + u.length &gt; p) {
</span><span style="color: #008080;"> 37</span> <span style="color: #ff0000;">            q = false
</span><span style="color: #008080;"> 38</span>           }
<span style="color: #008080;"> 39</span> <span style="color: #800000;">        };
</span><span style="color: #008080;"> 40</span> <span style="color: #800000;">        o.each(function(t) </span>{
<span style="color: #008080;"> 41</span> <span style="color: #ff0000;">          var u = $(this),
</span><span style="color: #008080;"> 42</span> <span style="color: #ff0000;">            v = u[0];
</span><span style="color: #008080;"> 43</span> 
<span style="color: #008080;"> 44</span> <span style="color: #ff0000;">          var title = u.text();
</span><span style="color: #008080;"> 45</span> <span style="color: #ff0000;">          var text = u.text();
</span><span style="color: #008080;"> 46</span> 
<span style="color: #008080;"> 47</span> <span style="color: #ff0000;">          u.attr('id', 'autoid-' + l + '-' + m + '-' + n)
</span><span style="color: #008080;"> 48</span> <span style="color: #ff0000;">          //if (!u.attr('id')) {
</span><span style="color: #008080;"> 49</span> <span style="color: #ff0000;">          //    u.attr('id', 'autoid-' + l + '-' + m + '-' + n)
</span><span style="color: #008080;"> 50</span> <span style="color: #ff0000;">          //</span>}<span style="color: #800000;">;
</span><span style="color: #008080;"> 51</span> <span style="color: #800000;">          if(v.localName === 'h2') </span>{
<span style="color: #008080;"> 52</span> <span style="color: #ff0000;">            l++;
</span><span style="color: #008080;"> 53</span> <span style="color: #ff0000;">            m = 0;
</span><span style="color: #008080;"> 54</span> <span style="color: #ff0000;">            if(text.length &gt; 14) text = text.substr(0, 20) + "...";
</span><span style="color: #008080;"> 55</span> <span style="color: #ff0000;">            j += '&lt;li&gt;&lt;span&gt;' + l + '&amp;nbsp&amp;nbsp&lt;/span&gt;&lt;a href="#' + u.attr('id') + '" title="' + title + '"&gt;' + text + '&lt;/a&gt;&lt;span class="sideCatalog-dot"&gt;&lt;/span&gt;&lt;/li&gt;';
</span><span style="color: #008080;"> 56</span>           }<span style="color: #800000;"> else if(v.localName === 'h3') </span>{
<span style="color: #008080;"> 57</span> <span style="color: #ff0000;">            m++;
</span><span style="color: #008080;"> 58</span> <span style="color: #ff0000;">            n = 0;
</span><span style="color: #008080;"> 59</span> <span style="color: #ff0000;">            if(q) {
</span><span style="color: #008080;"> 60</span> <span style="color: #ff0000;">              if(text.length &gt; 12) text = text.substr(0, 16) + "...";
</span><span style="color: #008080;"> 61</span> <span style="color: #ff0000;">              j += '&lt;li class="h2Offset"&gt;&lt;span&gt;' + l + '.' + m + '&amp;nbsp&amp;nbsp&lt;/span&gt;&lt;a href="#' + u.attr('id') + '" title="' + title + '"&gt;' + text + '&lt;/a&gt;&lt;/li&gt;';
</span><span style="color: #008080;"> 62</span>             }
<span style="color: #008080;"> 63</span> <span style="color: #800000;">          } else if(v.localName === 'h4') </span>{
<span style="color: #008080;"> 64</span> <span style="color: #ff0000;">            n++;
</span><span style="color: #008080;"> 65</span> <span style="color: #ff0000;">            if(r) {
</span><span style="color: #008080;"> 66</span> <span style="color: #ff0000;">              j += '&lt;li class="h3Offset"&gt;&lt;span&gt;' + l + '.' + m + '.' + n + '&amp;nbsp&amp;nbsp&lt;/span&gt;&lt;a href="#' + u.attr('id') + '" title="' + title + '"&gt;' + u.text() + '&lt;/a&gt;&lt;/li&gt;';
</span><span style="color: #008080;"> 67</span>             }
<span style="color: #008080;"> 68</span> <span style="color: #800000;">          }
</span><span style="color: #008080;"> 69</span> <span style="color: #800000;">        });
</span><span style="color: #008080;"> 70</span> <span style="color: #800000;">        $('#' + f + '&gt;ul').html(j);
</span><span style="color: #008080;"> 71</span> <span style="color: #800000;">        b.data('spy', 'scroll');
</span><span style="color: #008080;"> 72</span> <span style="color: #800000;">        b.data('target', '.sideCatalogBg');
</span><span style="color: #008080;"> 73</span> <span style="color: #800000;">        $('body').scrollspy(</span>{
<span style="color: #008080;"> 74</span> <span style="color: #ff0000;">          target</span>:<span style="color: #0000ff;"> '.sideCatalogBg'
</span><span style="color: #008080;"> 75</span>         }<span style="color: #800000;">);
</span><span style="color: #008080;"> 76</span> <span style="color: #800000;">        $sideCatelog = $('#' + e);
</span><span style="color: #008080;"> 77</span> <span style="color: #800000;">        $('#' + g).on('click', function() </span>{
<span style="color: #008080;"> 78</span> <span style="color: #ff0000;">          if($(this).hasClass('sideCatalogBtnDisable')) {
</span><span style="color: #008080;"> 79</span> <span style="color: #ff0000;">            $sideCatelog.css('visibility', 'hidden')
</span><span style="color: #008080;"> 80</span>           }<span style="color: #800000;"> else </span>{
<span style="color: #008080;"> 81</span> <span style="color: #ff0000;">            $sideCatelog.css('visibility', 'visible')
</span><span style="color: #008080;"> 82</span>           }<span style="color: #800000;">;
</span><span style="color: #008080;"> 83</span> <span style="color: #800000;">          $(this).toggleClass('sideCatalogBtnDisable')
</span><span style="color: #008080;"> 84</span> <span style="color: #800000;">        });
</span><span style="color: #008080;"> 85</span> <span style="color: #800000;">        $('#' + h).on('click', function() </span>{
<span style="color: #008080;"> 86</span> <span style="color: #ff0000;">          $("html,body").animate({
</span><span style="color: #008080;"> 87</span> <span style="color: #ff0000;">            scrollTop</span>:<span style="color: #0000ff;"> 0
</span><span style="color: #008080;"> 88</span>           }<span style="color: #800000;">, 500)
</span><span style="color: #008080;"> 89</span> <span style="color: #800000;">        });
</span><span style="color: #008080;"> 90</span> <span style="color: #800000;">        $sideToolbar = $('#' + d);
</span><span style="color: #008080;"> 91</span> 
<span style="color: #008080;"> 92</span> <span style="color: #800000;">        //通过判断评论框是否存在显示索引目录
</span><span style="color: #008080;"> 93</span> <span style="color: #800000;">        var commentDiv = $("#blog-comments-placeholder");
</span><span style="color: #008080;"> 94</span> 
<span style="color: #008080;"> 95</span> <span style="color: #800000;">        a.on('scroll', function() </span>{
<span style="color: #008080;"> 96</span> <span style="color: #ff0000;">          //评论框存在才调用方法
</span><span style="color: #008080;"> 97</span> <span style="color: #ff0000;">          if(commentDiv.length &gt; 0) {
</span><span style="color: #008080;"> 98</span> <span style="color: #ff0000;">            var t = a.scrollTop();
</span><span style="color: #008080;"> 99</span> <span style="color: #ff0000;">            if(t &gt; k) {
</span><span style="color: #008080;">100</span> <span style="color: #ff0000;">              $sideToolbar.css('display', 'block');
</span><span style="color: #008080;">101</span> <span style="color: #ff0000;">              $('#gotop').show()
</span><span style="color: #008080;">102</span>             }<span style="color: #800000;"> else </span>{
<span style="color: #008080;">103</span> <span style="color: #ff0000;">              $sideToolbar.css('display', 'none')
</span><span style="color: #008080;">104</span> <span style="color: #ff0000;">              $('#gotop').hide()
</span><span style="color: #008080;">105</span>             }
<span style="color: #008080;">106</span> <span style="color: #800000;">          }
</span><span style="color: #008080;">107</span> <span style="color: #800000;">        })
</span><span style="color: #008080;">108</span> <span style="color: #800000;">      });
</span><span style="color: #008080;">109</span> <span style="color: #800000;">      //以上是锚点JS
</span><span style="color: #008080;">110</span> <span style="color: #800000;">      //以下是返回顶部JS
</span><span style="color: #008080;">111</span> <span style="color: #800000;">      $(function() </span>{
<span style="color: #008080;">112</span> <span style="color: #ff0000;">        $('body').append('&lt;div id="gotop" onclick="goTop();"&gt;&lt;/div&gt;');
</span><span style="color: #008080;">113</span>       }<span style="color: #800000;">);
</span><span style="color: #008080;">114</span> 
<span style="color: #008080;">115</span> <span style="color: #800000;">      function goTop(u, t, r) </span>{
<span style="color: #008080;">116</span> <span style="color: #ff0000;">        var scrollActivate = !0;
</span><span style="color: #008080;">117</span> <span style="color: #ff0000;">        if(scrollActivate) {
</span><span style="color: #008080;">118</span> <span style="color: #ff0000;">          u = u || 0.1;
</span><span style="color: #008080;">119</span> <span style="color: #ff0000;">          t = t || 16;
</span><span style="color: #008080;">120</span> <span style="color: #ff0000;">          var s = 0,
</span><span style="color: #008080;">121</span> <span style="color: #ff0000;">            q = 0,
</span><span style="color: #008080;">122</span> <span style="color: #ff0000;">            o = 0,
</span><span style="color: #008080;">123</span> <span style="color: #ff0000;">            p = 0,
</span><span style="color: #008080;">124</span> <span style="color: #ff0000;">            n = 0,
</span><span style="color: #008080;">125</span> <span style="color: #ff0000;">            j = 0;
</span><span style="color: #008080;">126</span> <span style="color: #ff0000;">          document.documentElement &amp;&amp; (s = document.documentElement.scrollLeft || 0, q = document.documentElement.scrollTop || 0);
</span><span style="color: #008080;">127</span> <span style="color: #ff0000;">          document.body &amp;&amp; (o = document.body.scrollLeft || 0, p = document.body.scrollTop || 0);
</span><span style="color: #008080;">128</span> <span style="color: #ff0000;">          n = window.scrollX || 0;
</span><span style="color: #008080;">129</span> <span style="color: #ff0000;">          j = window.scrollY || 0;
</span><span style="color: #008080;">130</span> <span style="color: #ff0000;">          s = Math.max(s, Math.max(o, n));
</span><span style="color: #008080;">131</span> <span style="color: #ff0000;">          q = Math.max(q, Math.max(p, j));
</span><span style="color: #008080;">132</span> <span style="color: #ff0000;">          p = 1 + u;
</span><span style="color: #008080;">133</span> <span style="color: #ff0000;">          window.scrollTo(Math.floor(s / p), Math.floor(q / p));
</span><span style="color: #008080;">134</span> <span style="color: #ff0000;">          0 &lt; s || 0 &lt; q ? window.setTimeout('goTop(' + u + ', ' + t + ')', t) </span>:<span style="color: #0000ff;"> 'undefined' != typeof r &amp;&amp; r()
</span><span style="color: #008080;">135</span>         }<span style="color: #800000;"> else </span>{
<span style="color: #008080;">136</span> <span style="color: #ff0000;">          scrollActivate = !0
</span><span style="color: #008080;">137</span>         }
<span style="color: #008080;">138</span> <span style="color: #800000;">      }
</span><span style="color: #008080;">139</span> <span style="color: #800000;">      //以上是返回顶部JS
</span><span style="color: #008080;">140</span> <span style="color: #800000;">    &lt;/script&gt;
</span><span style="color: #008080;">141</span> 
<span style="color: #008080;">142</span> 
<span style="color: #008080;">143</span> <span style="color: #800000;">&lt;div id="newsSideBar"&gt;
</span><span style="color: #008080;">144</span> <span style="color: #800000;">    &lt;div class="headImage"&gt;
</span><span style="color: #008080;">145</span> <span style="color: #800000;">        &lt;img src="https://pic.cnblogs.com/avatar/1444343/20190803112901.png" alt="头像"&gt;
</span><span style="color: #008080;">146</span> <span style="color: #800000;">    &lt;/div&gt;
</span><span style="color: #008080;">147</span> <span style="color: #800000;">&lt;/div&gt;</span></pre>
</div>
<h3 style="text-align: center;">首页HTML代码</h3>
<div class="cnblogs_code">
<pre><span style="color: #008080;">  1</span> <span style="color: #800000;">&lt;link  type="text/css" rel="stylesheet" href="https://files.cnblogs.com/files/miangao/maodian.css"</span><span style="color: #008000;">/*</span><span style="color: #008000;">设置目录（首页HTML代码）</span><span style="color: #008000;">*/</span><span style="color: #800000;">&gt;
</span><span style="color: #008080;">  2</span> 
<span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> 
<span style="color: #008080;">  5</span> <span style="color: #800000;">&lt;script type="text/javascript"&gt;
</span><span style="color: #008080;">  6</span> <span style="color: #008000;">/*</span><span style="color: #008000;">设置小心心</span><span style="color: #008000;">*/</span>
<span style="color: #008080;">  7</span> <span style="color: #800000;">(function(window, document, undefined) </span>{
<span style="color: #008080;">  8</span> <span style="color: #ff0000;">    var hearts = [];
</span><span style="color: #008080;">  9</span> <span style="color: #ff0000;">    window.requestAnimationFrame = (function() {
</span><span style="color: #008080;"> 10</span> <span style="color: #ff0000;">        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
</span><span style="color: #008080;"> 11</span> <span style="color: #ff0000;">        function(callback) {
</span><span style="color: #008080;"> 12</span> <span style="color: #ff0000;">            setTimeout(callback, 1000 / 60);
</span><span style="color: #008080;"> 13</span>         }
<span style="color: #008080;"> 14</span> <span style="color: #800000;">    })();
</span><span style="color: #008080;"> 15</span> <span style="color: #800000;">    init();
</span><span style="color: #008080;"> 16</span> <span style="color: #800000;">    function init() </span>{
<span style="color: #008080;"> 17</span> <span style="color: #ff0000;">        css(".heart{width</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">height</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">position</span>:<span style="color: #0000ff;"> fixed</span>;<span style="color: #ff0000;">background</span>:<span style="color: #0000ff;"> #f00</span>;<span style="color: #ff0000;">transform</span>:<span style="color: #0000ff;"> rotate(45deg)</span>;<span style="color: #ff0000;">-webkit-transform</span>:<span style="color: #0000ff;"> rotate(45deg)</span>;<span style="color: #ff0000;">-moz-transform</span>:<span style="color: #0000ff;"> rotate(45deg)</span>;}<span style="color: #800000;">.heart:after,.heart:before</span>{<span style="color: #ff0000;">content</span>:<span style="color: #0000ff;"> ''</span>;<span style="color: #ff0000;">width</span>:<span style="color: #0000ff;"> inherit</span>;<span style="color: #ff0000;">height</span>:<span style="color: #0000ff;"> inherit</span>;<span style="color: #ff0000;">background</span>:<span style="color: #0000ff;"> inherit</span>;<span style="color: #ff0000;">border-radius</span>:<span style="color: #0000ff;"> 50%</span>;<span style="color: #ff0000;">-webkit-border-radius</span>:<span style="color: #0000ff;"> 50%</span>;<span style="color: #ff0000;">-moz-border-radius</span>:<span style="color: #0000ff;"> 50%</span>;<span style="color: #ff0000;">position</span>:<span style="color: #0000ff;"> absolute</span>;}<span style="color: #800000;">.heart:after</span>{<span style="color: #ff0000;">top</span>:<span style="color: #0000ff;"> -5px</span>;}<span style="color: #800000;">.heart:before</span>{<span style="color: #ff0000;">left</span>:<span style="color: #0000ff;"> -5px</span>;}<span style="color: #800000;">");
</span><span style="color: #008080;"> 18</span> <span style="color: #800000;">        attachEvent();
</span><span style="color: #008080;"> 19</span> <span style="color: #800000;">        gameloop();
</span><span style="color: #008080;"> 20</span> <span style="color: #800000;">    }
</span><span style="color: #008080;"> 21</span> <span style="color: #800000;">    function gameloop() </span>{
<span style="color: #008080;"> 22</span> <span style="color: #ff0000;">        for (var i = 0; i &lt; hearts.length; i++) {
</span><span style="color: #008080;"> 23</span> <span style="color: #ff0000;">            if (hearts[i].alpha &lt;= 0) {
</span><span style="color: #008080;"> 24</span> <span style="color: #ff0000;">                document.body.removeChild(hearts[i].el);
</span><span style="color: #008080;"> 25</span> <span style="color: #ff0000;">                hearts.splice(i, 1);
</span><span style="color: #008080;"> 26</span> <span style="color: #ff0000;">                continue;
</span><span style="color: #008080;"> 27</span>             }
<span style="color: #008080;"> 28</span> <span style="color: #800000;">            hearts[i].y--;
</span><span style="color: #008080;"> 29</span> <span style="color: #800000;">            hearts[i].scale += 0.004;
</span><span style="color: #008080;"> 30</span> <span style="color: #800000;">            hearts[i].alpha -= 0.013;
</span><span style="color: #008080;"> 31</span> <span style="color: #800000;">            hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
</span><span style="color: #008080;"> 32</span> <span style="color: #800000;">        }
</span><span style="color: #008080;"> 33</span> <span style="color: #800000;">        requestAnimationFrame(gameloop);
</span><span style="color: #008080;"> 34</span> <span style="color: #800000;">    }
</span><span style="color: #008080;"> 35</span> <span style="color: #800000;">    function attachEvent() </span>{
<span style="color: #008080;"> 36</span> <span style="color: #ff0000;">        var old = typeof window.onclick === "function" &amp;&amp; window.onclick;
</span><span style="color: #008080;"> 37</span> <span style="color: #ff0000;">        window.onclick = function(event) {
</span><span style="color: #008080;"> 38</span> <span style="color: #ff0000;">            old &amp;&amp; old();
</span><span style="color: #008080;"> 39</span> <span style="color: #ff0000;">            createHeart(event);
</span><span style="color: #008080;"> 40</span>         }
<span style="color: #008080;"> 41</span> <span style="color: #800000;">    }
</span><span style="color: #008080;"> 42</span> <span style="color: #800000;">    function createHeart(event) </span>{
<span style="color: #008080;"> 43</span> <span style="color: #ff0000;">        var d = document.createElement("div");
</span><span style="color: #008080;"> 44</span> <span style="color: #ff0000;">        d.className = "heart";
</span><span style="color: #008080;"> 45</span> <span style="color: #ff0000;">        hearts.push({
</span><span style="color: #008080;"> 46</span> <span style="color: #ff0000;">            el</span>:<span style="color: #0000ff;"> d,
</span><span style="color: #008080;"> 47</span> <span style="color: #0000ff;">            x: event.clientX - 5,
</span><span style="color: #008080;"> 48</span> <span style="color: #0000ff;">            y: event.clientY - 5,
</span><span style="color: #008080;"> 49</span> <span style="color: #0000ff;">            scale: 1,
</span><span style="color: #008080;"> 50</span> <span style="color: #0000ff;">            alpha: 1,
</span><span style="color: #008080;"> 51</span> <span style="color: #0000ff;">            color: randomColor()
</span><span style="color: #008080;"> 52</span>         }<span style="color: #800000;">);
</span><span style="color: #008080;"> 53</span> <span style="color: #800000;">        document.body.appendChild(d);
</span><span style="color: #008080;"> 54</span> <span style="color: #800000;">    }
</span><span style="color: #008080;"> 55</span> <span style="color: #800000;">    function css(css) </span>{
<span style="color: #008080;"> 56</span> <span style="color: #ff0000;">        var style = document.createElement("style");
</span><span style="color: #008080;"> 57</span> <span style="color: #ff0000;">        style.type = "text/css";
</span><span style="color: #008080;"> 58</span> <span style="color: #ff0000;">        try {
</span><span style="color: #008080;"> 59</span> <span style="color: #ff0000;">            style.appendChild(document.createTextNode(css));
</span><span style="color: #008080;"> 60</span>         }<span style="color: #800000;"> catch(ex) </span>{
<span style="color: #008080;"> 61</span> <span style="color: #ff0000;">            style.styleSheet.cssText = css;
</span><span style="color: #008080;"> 62</span>         }
<span style="color: #008080;"> 63</span> <span style="color: #800000;">        document.getElementsByTagName('head')[0].appendChild(style);
</span><span style="color: #008080;"> 64</span> <span style="color: #800000;">    }
</span><span style="color: #008080;"> 65</span> <span style="color: #800000;">    function randomColor() </span>{
<span style="color: #008080;"> 66</span> <span style="color: #ff0000;">        return "rgb(" + (~~ (Math.random() * 255)) + "," + (~~ (Math.random() * 255)) + "," + (~~ (Math.random() * 255)) + ")";
</span><span style="color: #008080;"> 67</span>     }
<span style="color: #008080;"> 68</span> <span style="color: #800000;">})(window, document);
</span><span style="color: #008080;"> 69</span> <span style="color: #800000;">&lt;/script&gt;
</span><span style="color: #008080;"> 70</span> 
<span style="color: #008080;"> 71</span> 
<span style="color: #008080;"> 72</span> 
<span style="color: #008080;"> 73</span> 
<span style="color: #008080;"> 74</span> 
<span style="color: #008080;"> 75</span> <span style="color: #800000;">&lt;script type="text/javascript"&gt; 
</span><span style="color: #008080;"> 76</span> <span style="color: #008000;">/*</span><span style="color: #008000;">自定义的鼠标点击效果</span><span style="color: #008000;">*/</span>
<span style="color: #008080;"> 77</span> <span style="color: #008000;">/*</span><span style="color: #008000;"> 鼠标特效 </span><span style="color: #008000;">*/</span> 
<span style="color: #008080;"> 78</span> <span style="color: #800000;">var a_idx = 0; 
</span><span style="color: #008080;"> 79</span> <span style="color: #800000;">jQuery(document).ready(function($) </span>{ 
<span style="color: #008080;"> 80</span> <span style="color: #ff0000;">    $("body").click(function(e) { 
</span><span style="color: #008080;"> 81</span> <span style="color: #ff0000;">        var a = new Array("富强","民主","文明","和谐","菜鸟-传奇","自由","平等","公正","法治","菜鸟-传奇","爱国","敬业","诚信","友善","菜鸟-传奇"); 
</span><span style="color: #008080;"> 82</span> <span style="color: #ff0000;">        var $i = $("&lt;span/&gt;").text(a[a_idx]); 
</span><span style="color: #008080;"> 83</span> <span style="color: #ff0000;">        a_idx = (a_idx + 1) % a.length; 
</span><span style="color: #008080;"> 84</span> <span style="color: #ff0000;">        var x = e.pageX, 
</span><span style="color: #008080;"> 85</span> <span style="color: #ff0000;">        y = e.pageY; 
</span><span style="color: #008080;"> 86</span> <span style="color: #ff0000;">        $i.css({ 
</span><span style="color: #008080;"> 87</span> <span style="color: #ff0000;">            "z-index"</span>:<span style="color: #0000ff;"> 999999999999999999999999999999999999999999999999999999999999999999999, 
</span><span style="color: #008080;"> 88</span> <span style="color: #0000ff;">            "top": y - 20, 
</span><span style="color: #008080;"> 89</span> <span style="color: #0000ff;">            "left": x, 
</span><span style="color: #008080;"> 90</span> <span style="color: #0000ff;">            "position": "absolute", 
</span><span style="color: #008080;"> 91</span> <span style="color: #0000ff;">            "font-weight": "bold", 
</span><span style="color: #008080;"> 92</span> <span style="color: #0000ff;">            "color": "rgb(72,85,137)" 
</span><span style="color: #008080;"> 93</span>         }<span style="color: #800000;">); 
</span><span style="color: #008080;"> 94</span> <span style="color: #800000;">        $("body").append($i); 
</span><span style="color: #008080;"> 95</span> <span style="color: #800000;">        $i.animate(</span>{ 
<span style="color: #008080;"> 96</span> <span style="color: #ff0000;">            "top"</span>:<span style="color: #0000ff;"> y - 180, 
</span><span style="color: #008080;"> 97</span> <span style="color: #0000ff;">            "opacity": 0 
</span><span style="color: #008080;"> 98</span>         }<span style="color: #800000;">, 
</span><span style="color: #008080;"> 99</span> <span style="color: #800000;">        1500, 
</span><span style="color: #008080;">100</span> <span style="color: #800000;">        function() </span>{ 
<span style="color: #008080;">101</span> <span style="color: #ff0000;">            $i.remove(); 
</span><span style="color: #008080;">102</span>         }<span style="color: #800000;">); 
</span><span style="color: #008080;">103</span> <span style="color: #800000;">    }); 
</span><span style="color: #008080;">104</span> <span style="color: #800000;">}); 
</span><span style="color: #008080;">105</span> <span style="color: #800000;">&lt;/script&gt;</span></pre>
</div>
<h3 style="text-align: center;">页脚HTML代码</h3>
<p>&nbsp;<span class="cnblogs_code"><span style="color: #008080;">1</span> <span style="color: #800000;">&lt;script src="https://files.cnblogs.com/files/miangao/bootstrap.min.js"</span><span style="color: #008000;">/*</span><span style="color: #008000;">设置目录（首脚HTML代码）</span><span style="color: #008000;">*/</span><span style="color: #800000;">&gt;&lt;/script&gt;</span></span>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>如此简单明了</strong></p>
<p><a href="https://www.cnblogs.com/cainiao-chuanqi/p/11287052.html" target="_blank"><strong>&nbsp; #@---@#&nbsp; &nbsp;</strong></a></p>]]></description></item><item><title>我的随笔---博客园标题与点击效果自定义</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/02/11287052.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 02 Aug 2019 02:26:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/02/11287052.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre>我的随笔---标题修改</pre>
</div>
<h1><strong>示例如下：</strong></h1>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190802105828169-1375708560.png" alt="" /></p>
<h2><strong>标题h2</strong></h2>
<h3><strong>标题h3</strong></h3>
<h4><strong>标题h4</strong></h4>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#cnblogs_post_body
{
    color: black;      
    font: </span>0.875em/1.5em "微软雅黑" , "PTSans" , "Arial" ,sans-serif;
    font-<span style="color: #000000;">size: 15px;
}
#各个等级标题的颜色样式
#cnblogs_post_body h1    {
    background: #CC0000;
    border</span>-<span style="color: #000000;">radius: 5px 5px 5px 5px;
    box</span>-shadow: 0 0 0 1px #5F5A4B, 1px 1px 6px 1px rgba(10, 10, 0, 0.5<span style="color: #000000;">);
    color: #FFFFFF;
    font</span>-family: "微软雅黑" , "宋体" , "黑体"<span style="color: #000000;"> ,Arial;
    font</span>-<span style="color: #000000;">size: 24px;
    font</span>-<span style="color: #000000;">weight: bold;
    height: 25px;
    line</span>-<span style="color: #000000;">height: 25px;
    margin: 18px </span>0 !<span style="color: #000000;">important;
    padding: 8px </span>0<span style="color: #000000;"> 8px 5px;
    text</span>-shadow: 2px 2px 3px #222222<span style="color: #000000;">;
}
#cnblogs_post_body h2    {
    background: #CC0000;
    border</span>-<span style="color: #000000;">radius: 5px 5px 5px 5px;
    box</span>-shadow: 0 0 0 1px #5F5A4B, 1px 1px 6px 1px rgba(10, 10, 0, 0.5<span style="color: #000000;">);
    color: #FFFFFF;
    font</span>-family: "微软雅黑" , "宋体" , "黑体"<span style="color: #000000;"> ,Arial;
    font</span>-<span style="color: #000000;">size: 20px;
    font</span>-<span style="color: #000000;">weight: bold;
    height: 25px;
    line</span>-<span style="color: #000000;">height: 25px;
    margin: 18px </span>0 !<span style="color: #000000;">important;
    padding: 8px </span>0<span style="color: #000000;"> 8px 5px;
    text</span>-shadow: 2px 2px 3px #222222<span style="color: #000000;">;
}
#cnblogs_post_body h3    {
    background: #FF3300;
    border</span>-<span style="color: #000000;">radius: 6px 6px 6px 6px;
    box</span>-shadow: 0 0 0 1px #5F5A4B, 1px 1px 6px 1px rgba(10, 10, 0, 0.5<span style="color: #000000;">);
    color: #FFFFFF;
    font</span>-family: "微软雅黑" , "宋体" , "黑体"<span style="color: #000000;"> ,Arial;
    font</span>-<span style="color: #000000;">size: 18px;
    font</span>-<span style="color: #000000;">weight: bold;
    height: 25px;
    line</span>-<span style="color: #000000;">height: 25px;
    margin: 18px </span>0 0<span style="color: #000000;"> 30px;
    padding: 8px </span>0<span style="color: #000000;"> 5px 5px;
    text</span>-shadow: 2px 2px 3px #222222<span style="color: #000000;">;
}
#cnblogs_post_body h4{
    background:  #FF0033;
    border</span>-<span style="color: #000000;">radius: 6px 6px 6px 6px;
    box</span>-shadow: 0 0 0 1px #5F5A4B, 1px 1px 6px 1px rgba(10, 10, 0, 0.5<span style="color: #000000;">);
    color: #FFFFFF;
    font</span>-family: "微软雅黑" , "宋体" , "黑体"<span style="color: #000000;"> ,Arial;
    font</span>-<span style="color: #000000;">size: 16px;
    font</span>-<span style="color: #000000;">weight: bold;
    height: 24px;
    line</span>-<span style="color: #000000;">height: 23px;
    margin: 12px </span>0 0<span style="color: #000000;"> 40px;
    padding: 5px </span>0<span style="color: #000000;"> 5px 10px;
    text</span>-shadow: 2px 2px 3px #222222<span style="color: #000000;">;
}
#页面中a标签鼠标位置
#cnblogs_post_body h2:a{
   color: rgb(</span>235, 235, 235<span style="color: #000000;">);
}
#cnblogs_post_body h2 a:hover{
   color: rgb(</span>255, 102, 0<span style="color: #000000;">);
}
#页面中标题位置
#cnblogs_post_body h1{
   color: rgb(</span>235, 235, 235<span style="color: #000000;">);
}
#cnblogs_post_body h1:hover{
   color: rgb(</span>255, 102, 0<span style="color: #000000;">);
}
#cnblogs_post_body h2{
   color: rgb(</span>235, 235, 235<span style="color: #000000;">);
}
#cnblogs_post_body h2:hover{
   color: rgb(</span>255, 102, 0<span style="color: #000000;">);
}
#cnblogs_post_body h3{
   color: rgb(</span>235, 235, 235<span style="color: #000000;">);
}
#cnblogs_post_body h3:hover{
   color: rgb(</span>255, 102, 0<span style="color: #000000;">);
}
#cnblogs_post_body h4{
   color: rgb(</span>235, 235, 235<span style="color: #000000;">);
}
#cnblogs_post_body h4:hover{
   color: rgb(</span>255, 102, 0<span style="color: #000000;">);
}</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('97d12ac0-a4eb-48e3-9e1f-60d017971d59')"><img id="code_img_closed_97d12ac0-a4eb-48e3-9e1f-60d017971d59" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_97d12ac0-a4eb-48e3-9e1f-60d017971d59" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('97d12ac0-a4eb-48e3-9e1f-60d017971d59',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_97d12ac0-a4eb-48e3-9e1f-60d017971d59" class="cnblogs_code_hide">
<pre><span style="color: #800000;">@font-face </span>{<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> 'FontAwesome'</span>;<span style="color: #ff0000;">
  font-style</span>:<span style="color: #0000ff;"> normal</span>;<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;<span style="color: #ff0000;">
  src</span>:<span style="color: #0000ff;"> url("http://blog.zhaishidan.cn/css/font/fontawesome-webfont.eot?#iefix") format('embedded-opentype'), url("http://blog.zhaishidan.cn/css/font/fontawesome-webfont.woff") format('woff'), url("http://blog.zhaishidan.cn/css/font/fontawesome-webfont.ttf") format('truetype'), url("http://blog.zhaishidan.cn/css/font/fontawesome-webfont.svg#FontAwesomeRegular") format('svg')</span>;
}<span style="color: #800000;">
* </span>{<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
body </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #eee</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #444</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, Verdana, sans-serif</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 14px</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px transparent</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">#505050</span>;
}<span style="color: #800000;">
@media screen and (max-width: 1260px) </span>{<span style="color: #ff0000;">
  body {
    margin</span>:<span style="color: #0000ff;"> 0px</span>;
  }<span style="color: #800000;">
}
@media screen and (max-width: 600px) </span>{<span style="color: #ff0000;">
  body {
    font-size</span>:<span style="color: #0000ff;"> 13px</span>;
  }<span style="color: #800000;">
}
h1,h2,h3,h4,h5,h6 </span>{<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, Verdana, sans-serif</span>;
}<span style="color: #800000;">
h1 </span>{<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1.8em</span>;
}<span style="color: #800000;">
h2 </span>{<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1.5em</span>;
}<span style="color: #800000;">
h3 </span>{<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1.3em</span>;
}<span style="color: #800000;">
a </span>{<span style="color: #ff0000;">
  text-decoration</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #258fb8</span>;
}<span style="color: #800000;">
a:hover </span>{<span style="color: #ff0000;">
  text-decoration</span>:<span style="color: #0000ff;"> underline</span>;
}<span style="color: #800000;">
#home</span>{<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0 auto</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 85%</span>;<span style="color: #ff0000;">
  background-color</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 30px</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 50px</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 50px</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;"> 0 2px 6px rgba(100, 100, 100, 0.3)</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 20px</span>;
}<span style="color: #800000;">
#tbCommentBody </span>{<span style="color: #ff0000;">width</span>:<span style="color: #0000ff;"> 100%</span>;}<span style="color: #800000;">
#blogTitle </span>{<span style="color: #ff0000;">width</span>:<span style="color: #0000ff;">23%</span>;<span style="color: #ff0000;">margin-top</span>:<span style="color: #0000ff;"> -10px</span>;<span style="color: #ff0000;">text-align</span>:<span style="color: #0000ff;"> center</span>;}<span style="color: #800000;">
.alignright </span>{<span style="color: #ff0000;">float</span>:<span style="color: #0000ff;"> right</span>;}<span style="color: #800000;">
#header, #main, #footer </span>{<span style="color: #ff0000;">width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">margin</span>:<span style="color: #0000ff;"> 0 auto</span>;}<span style="color: #800000;">
@media screen and (max-width: 1260px) </span>{<span style="color: #ff0000;">
  #main {
    width</span>:<span style="color: #0000ff;"> 95%</span>;
  }<span style="color: #800000;">
}
#mainContent </span>{<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 75%</span>;<span style="color: #ff0000;">
  float</span>:<span style="color: #0000ff;"> left</span>;<span style="color: #ff0000;">
  margin-left</span>:<span style="color: #0000ff;"> 10px</span>;
}<span style="color: #800000;">
@media screen and (max-width: 1260px) </span>{<span style="color: #ff0000;">
  #main-col {
    width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
    margin-right</span>:<span style="color: #0000ff;"> -300px</span>;
  }<span style="color: #800000;">
}
@media screen and (max-width: 900px) </span>{<span style="color: #ff0000;">
  #main-col {
    margin-right</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
    float</span>:<span style="color: #0000ff;"> none</span>;
  }<span style="color: #800000;">
}
@media screen and (max-width: 1260px) </span>{<span style="color: #ff0000;">
  #wrapper {
    margin-right</span>:<span style="color: #0000ff;"> 300px</span>;
  }<span style="color: #800000;">
}
@media screen and (max-width: 900px) </span>{<span style="color: #ff0000;">
  #wrapper {
    margin-right</span>:<span style="color: #0000ff;"> 0</span>;
  }<span style="color: #800000;">
}
#header </span>{<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 20px auto 30px</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 60px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;
}<span style="color: #800000;">
#header a </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;
}<span style="color: #800000;">
#header a:hover </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #258fb8</span>;<span style="color: #ff0000;">
  text-decoration</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#header h1 </span>{<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 30px</span>;
}<span style="color: #800000;">
#header h2 </span>{<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  margin-left</span>:<span style="color: #0000ff;"> 30px</span>;
}<span style="color: #800000;">
#header #navigator </span>{<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "Lato", Helvetica Neue, Helvetica, Arial, sans-serif</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 16px</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px solid #ededed</span>;<span style="color: #ff0000;">
  border-top</span>:<span style="color: #0000ff;"> 1px solid #ededed</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 50px</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 50px</span>;<span style="color: #ff0000;">
  clear</span>:<span style="color: #0000ff;"> both</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 25px</span>;
}<span style="color: #800000;">
#header #navigator ul </span>{<span style="color: #ff0000;">
  list-style</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#header #navigator ul li </span>{<span style="color: #ff0000;">
  float</span>:<span style="color: #0000ff;"> left</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 10%</span>;<span style="color: #ff0000;">
  text-align</span>:<span style="color: #0000ff;"> center</span>;<span style="color: #ff0000;">
  margin-right</span>:<span style="color: #0000ff;"> 15px</span>;
}<span style="color: #800000;">
#header .blogStats </span>{<span style="color: #ff0000;">
  float</span>:<span style="color: #0000ff;"> right</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 13px</span>;
}<span style="color: #800000;">
.topicListFooter </span>{<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;">30px</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 30px</span>;<span style="color: #ff0000;">
  margin-right</span>:<span style="color: #0000ff;"> 0 !important</span>;
}<span style="color: #800000;">
.topicListFooter a </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> inline !important</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 10px 20px</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #ddd</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "Lato", Helvetica Neue, Helvetica, Arial, sans-serif</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 5px</span>;
}<span style="color: #800000;">
.topicListFooter a:hover </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #258fb8</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  text-decoration</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
.topicListFooter .prev:before </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f053'</span>;<span style="color: #ff0000;">
  padding-right</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> FontAwesome</span>;
}<span style="color: #800000;">
.topicListFooter .next:after </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f054'</span>;<span style="color: #ff0000;">
  padding-left</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> FontAwesome</span>;
}<span style="color: #800000;">
article </span>{<span style="color: #ff0000;">
  -webkit-box-shadow</span>:<span style="color: #0000ff;"> 1px 2px 3px #ddd</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;"> 1px 2px 3px #ddd</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #fff</span>;
}<span style="color: #800000;">
article.page </span>{<span style="color: #ff0000;">
  padding-left</span>:<span style="color: #0000ff;"> 20px</span>;
}<span style="color: #800000;">
article.page .icon </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
.postIcon:before </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f016'</span>;
}<span style="color: #800000;">
article.photo .icon:before </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f030'</span>;
}<span style="color: #800000;">
article.link .icon:before </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f0c1'</span>;
}<span style="color: #800000;">
article.link .title a:after </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f08e'</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  font</span>:<span style="color: #0000ff;"> 12px FontAwesome</span>;<span style="color: #ff0000;">
  padding-left</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  vertical-align</span>:<span style="color: #0000ff;"> super</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;">*****************************************以下自定义样式**********************************************</span><span style="color: #008000;">*/</span><span style="color: #800000;">
#MySignature</span>{<span style="color: #ff0000;">
border-top</span>:<span style="color: #0000ff;"> 2px solid #ccc</span>;<span style="color: #ff0000;">
  padding-top</span>:<span style="color: #0000ff;"> 20px</span>;
}<span style="color: #800000;">
.pager</span>{<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px dashed #ddd</span>;<span style="color: #ff0000;">
  padding-bottom</span>:<span style="color: #0000ff;"> 30px</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> -10px</span>;
}<span style="color: #800000;">
#blog-calendar</span>{<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;">0px</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;">0px</span>;<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> none !important</span>;
}<span style="color: #800000;">
#TopViewPostsBlock ul li</span>{<span style="color: #ff0000;">
  white-space</span>:<span style="color: #0000ff;"> nowrap</span>;<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> hidden</span>;<span style="color: #ff0000;">
  text-overflow</span>:<span style="color: #0000ff;"> ellipsis</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> inline-block</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 30px</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 30px</span>;
}<span style="color: #800000;">
.day .dayTitle</span>{<span style="color: #ff0000;">
      display</span>:<span style="color: #0000ff;"> none !important</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;"> 去掉广告 </span><span style="color: #008000;">*/</span><span style="color: #800000;">
#ad_t2,#opt_under_post,.c_ad_block,#under_post_news,#under_post_kb</span>{<span style="color: #ff0000;">
    display</span>:<span style="color: #0000ff;"> none !important</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;">*****************************************以上自定义样式**********************************************</span><span style="color: #008000;">*/</span><span style="color: #800000;">
.postTitle, .entrylistPosttitle </span>{<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "Lato", Helvetica Neue, Helvetica, Arial, sans-serif</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1.8em</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 20px 20px 15px 0px</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 10px 10px 0px 0px</span>;<span style="color: #ff0000;">
  white-space</span>:<span style="color: #0000ff;"> nowrap</span>;<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> hidden</span>;<span style="color: #ff0000;">
  text-overflow</span>:<span style="color: #0000ff;"> ellipsis</span>;
}<span style="color: #800000;">
.entrylistPostSummary, .postCon, .postBody </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0 20px 15px 0px</span>;<span style="color: #ff0000;">
  -webkit-box-shadow</span>:<span style="color: #0000ff;"> 1px 2px 3px #ddd</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;"> 0 2px 0 #ddd</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;
}<span style="color: #800000;">
.postDesc, .entrylistItemPostDesc </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0px 20px 15px 0px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 16px</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;<span style="color: #ff0000;">
  min-height</span>:<span style="color: #0000ff;"> 16px</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px dashed #ccc</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;"> 去掉博客园自带日历控件 </span><span style="color: #008000;">*/</span><span style="color: #800000;">
#blog-calendar </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
@media screen and (max-width: 600px) </span>{<span style="color: #ff0000;">
  .postCon {
    padding-left</span>:<span style="color: #0000ff;"> 0px</span>;
  }<span style="color: #800000;">
}
.postIcon </span>{<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 0px</span>;<span style="color: #ff0000;">
  margin-right</span>:<span style="color: #0000ff;"> 25px</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;<span style="color: #ff0000;">
  top</span>:<span style="color: #0000ff;"> 25px</span>;<span style="color: #ff0000;">
  left</span>:<span style="color: #0000ff;"> 25px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #258fb8</span>;
}<span style="color: #800000;">
@media screen and (max-width: 600px) </span>{<span style="color: #ff0000;">
  article header .icon {
    display</span>:<span style="color: #0000ff;"> none</span>;
  }<span style="color: #800000;">
}
.postIcon:before </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">
  font</span>:<span style="color: #0000ff;"> 32px FontAwesome</span>;<span style="color: #ff0000;">
  top</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  left</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 32px</span>;<span style="color: #ff0000;">
  text-align</span>:<span style="color: #0000ff;"> center</span>;
}<span style="color: #800000;">
article header time </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  font</span>:<span style="color: #0000ff;"> 0.9em "Lato", Helvetica Neue, Helvetica, Arial, sans-serif</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 5px</span>;<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> block</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 1</span>;
}<span style="color: #800000;">
article header .title </span>{<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;
}<span style="color: #800000;">
article header .title a </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #444</span>;
}<span style="color: #800000;">
article header .title a:hover </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #258fb8</span>;<span style="color: #ff0000;">
  text-decoration</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#cnblogs_post_body </span>{<span style="color: #ff0000;">
  text-align</span>:<span style="color: #0000ff;"> justify</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 1.6</span>;
}<span style="color: #800000;">
#cnblogs_post_body p,
#cnblogs_post_body blockquote,
#cnblogs_post_body ul,
#cnblogs_post_body ol,
#cnblogs_post_body dl,
#cnblogs_post_body table,
#cnblogs_post_body iframe,
#cnblogs_post_body h3,
#cnblogs_post_body h4,
#cnblogs_post_body h5,
#cnblogs_post_body h6,
#cnblogs_post_body .video-container </span>{<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 15px</span>;
}<span style="color: #800000;">
#cnblogs_post_body blockquote </span>{<span style="color: #ff0000;">
  border-top</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  font-style</span>:<span style="color: #0000ff;"> italic</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "Georgia", serif</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1.2em</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0 30px 15px</span>;
}<span style="color: #800000;">
#cnblogs_post_body blockquote footer </span>{<span style="color: #ff0000;">
  border-top</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.8em</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 1</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 20px 0 0</span>;<span style="color: #ff0000;">
  padding-top</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
#cnblogs_post_body blockquote footer cite:before </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '&mdash;'</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #ccc</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0 0.5em</span>;
}<span style="color: #800000;">
#cnblogs_post_body code,
#cnblogs_post_body pre </span>{<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> Monaco, Menlo, Consolas, Courier New, monospace</span>;
}<span style="color: #800000;">
#cnblogs_post_body code </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #eee</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #666</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0 5px</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0 2px</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  -webkit-border-radius</span>:<span style="color: #0000ff;"> 3px</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 3px</span>;
}<span style="color: #800000;">
#cnblogs_post_body pre </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #eee</span>;<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> auto</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 7px 15px</span>;<span style="color: #ff0000;">
  -webkit-border-radius</span>:<span style="color: #0000ff;"> 2px</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 2px</span>;
}<span style="color: #800000;">
#cnblogs_post_body pre code </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  -webkit-border-radius</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
#cnblogs_post_body ul ul,
#cnblogs_post_body ol ul,
#cnblogs_post_body dl ul,
#cnblogs_post_body ul ol,
#cnblogs_post_body ol ol,
#cnblogs_post_body dl ol,
#cnblogs_post_body ul dl,
#cnblogs_post_body ol dl,
#cnblogs_post_body dl dl </span>{<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
#cnblogs_post_body h1,
#cnblogs_post_body h2 </span>{<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> bold</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  padding-bottom</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 20px</span>;
}<span style="color: #800000;">
#cnblogs_post_body h3,
#cnblogs_post_body h4,
#cnblogs_post_body h5,
#cnblogs_post_body h6 </span>{<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #eee</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 6px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> Red</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "微软雅黑" , "宋体" , "黑体" ,Arial</span>;<span style="color: #ff0000;">
  min-height</span>:<span style="color: #0000ff;"> 25px</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 25px</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 18px 5px !important</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 8px</span>;<span style="color: #ff0000;">
  opacity</span>:<span style="color: #0000ff;"> 0.8</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px dashed #aaa</span>;
}<span style="color: #800000;">
#cnblogs_post_body h4 </span>{<span style="color: #ff0000;">
  padding-left</span>:<span style="color: #0000ff;">20px !important</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">Green !important</span>;
}<span style="color: #800000;">
.postBody img,
.entrylistPostSummary img, .postCon img,
.postBody video </span>{<span style="color: #ff0000;">
  max-width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> auto</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#cnblogs_post_body iframe </span>{<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#cnblogs_post_body .caption </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> block</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 5px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;<span style="color: #ff0000;">
  padding-left</span>:<span style="color: #0000ff;"> 25px</span>;
}<span style="color: #800000;">
#cnblogs_post_body .caption:before </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f040'</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">
  font</span>:<span style="color: #0000ff;"> 1.3em FontAwesome</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">
  left</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  top</span>:<span style="color: #0000ff;"> 3px</span>;
}<span style="color: #800000;">
#cnblogs_post_body .video-container </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;<span style="color: #ff0000;">
  padding-bottom</span>:<span style="color: #0000ff;"> 56.25%</span>;<span style="color: #ff0000;">
  padding-top</span>:<span style="color: #0000ff;"> 30px</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> hidden</span>;
}<span style="color: #800000;">
#cnblogs_post_body .video-container iframe,
#cnblogs_post_body .video-container object,
#cnblogs_post_body .video-container embed </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">
  top</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  left</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
#cnblogs_post_body .pullquote </span>{<span style="color: #ff0000;">
  float</span>:<span style="color: #0000ff;"> right</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 1em 0 0.5em 1.5em</span>;<span style="color: #ff0000;">
  text-align</span>:<span style="color: #0000ff;"> left</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 45%</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1.5em</span>;
}<span style="color: #800000;">
#blog-comments-placeholder, #comment_form </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 20px</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  -webkit-box-shadow</span>:<span style="color: #0000ff;"> 1px 10px 10px #ddd</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;"> 10px 10px 10px #ddd</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 50px</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px solid #ccc</span>;<span style="color: #ff0000;">
  padding-top</span>:<span style="color: #0000ff;">0</span>;
}<span style="color: #800000;">
.feedback_area_title </span>{<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 15px</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1.8em</span>;
}<span style="color: #800000;">
.feedbackItem </span>{<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px dashed #CCC</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 5px</span>;
}<span style="color: #800000;">
.color_shine </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> rgb(226, 242, 255)</span>;
}<span style="color: #800000;">
.feedbackItem:hover </span>{<span style="color: #ff0000;">
  -webkit-animation-name</span>:<span style="color: #0000ff;"> color_shine</span>;<span style="color: #ff0000;">
  -webkit-animation-duration</span>:<span style="color: #0000ff;"> 2s</span>;<span style="color: #ff0000;">
  -webkit-animation-iteration-count</span>:<span style="color: #0000ff;"> infinite</span>;
}<span style="color: #800000;">
#comment_form .title </span>{<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 15px</span>;
}<span style="color: #800000;">
#ad_under_post_holder </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
.entrylistTitle </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 30px</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;
}<span style="color: #800000;">
.entrylistTitle:before </span>{<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> FontAwesome</span>;<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '\f07b'</span>;<span style="color: #ff0000;">
  padding-right</span>:<span style="color: #0000ff;"> 15px</span>;
}<span style="color: #800000;">
.archive </span>{<span style="color: #ff0000;">
  -webkit-box-shadow</span>:<span style="color: #0000ff;"> 1px 2px 3px #ddd</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;"> 1px 2px 3px #ddd</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 50px</span>;
}<span style="color: #800000;">
.archive article </span>{<span style="color: #ff0000;">
  -webkit-box-shadow</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
.archive article .post-content </span>{<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
#sideBar</span>{<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 22%</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 1.8em</span>;<span style="color: #ff0000;">
  float</span>:<span style="color: #0000ff;"> right</span>;
}<span style="color: #800000;">
@media screen and (max-width: 900px) </span>{<span style="color: #ff0000;">
  #sideBar {
    float</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
    width</span>:<span style="color: #0000ff;"> 100%</span>;
  }<span style="color: #800000;">
}
.catListLink,
.catListMyTeams,
.catListComment,
.catListFeedback </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
.search,
.newsItem,
.catListPostCategory,
.catListPostArchive,
.catListTag,
.catListView,
.catListBlogRank </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  -webkit-box-shadow</span>:<span style="color: #0000ff;"> 1px 2px 3px #ddd</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;"> 10px 10px 10px #ddd</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 30px</span>;<span style="color: #ff0000;">
  word-wrap</span>:<span style="color: #0000ff;"> break-word</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;
}<span style="color: #800000;">
#blog-sidecolumn h3, .newsItem h3 </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 15px 20px</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1em</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> normal</span>;
}<span style="color: #800000;">
#blog-sidecolumn ul, .newsItem #blog-news </span>{<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 15px 20px</span>;
}<span style="color: #800000;">
#blog-sidecolumn ul,
#blog-sidecolumn ol,
#blog-sidecolumn dl </span>{<span style="color: #ff0000;">
  list-style</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#blog-sidecolumn ul ul,
#blog-sidecolumn ol ul,
#blog-sidecolumn dl ul,
#blog-sidecolumn ul ol,
#blog-sidecolumn ol ol,
#blog-sidecolumn dl ol,
#blog-sidecolumn ul dl,
#blog-sidecolumn ol dl,
#blog-sidecolumn dl dl </span>{<span style="color: #ff0000;">
  list-style</span>:<span style="color: #0000ff;"> disc</span>;<span style="color: #ff0000;">
  margin-left</span>:<span style="color: #0000ff;"> 20px</span>;
}<span style="color: #800000;">
#q </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #fff</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> "Lato", Helvetica Neue, Helvetica, Arial, sans-serif</span>;<span style="color: #ff0000;">
  font-style</span>:<span style="color: #0000ff;"> italic</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 1em</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 10px 15px</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  -webkit-box-sizing</span>:<span style="color: #0000ff;"> border-box</span>;<span style="color: #ff0000;">
  -moz-box-sizing</span>:<span style="color: #0000ff;"> border-box</span>;<span style="color: #ff0000;">
  box-sizing</span>:<span style="color: #0000ff;"> border-box</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>;
}<span style="color: #800000;">
#q:focus </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #444</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;">隐藏搜索框中的无用组件</span><span style="color: #008000;">*/</span><span style="color: #800000;">
.mySearch </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">

#sideBar .tag small </span>{<span style="color: #ff0000;">
  margin-left</span>:<span style="color: #0000ff;"> 15px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;
}<span style="color: #800000;">
#sideBar .tag small:before </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> '('</span>;
}<span style="color: #800000;">
#sideBar .tag small:after </span>{<span style="color: #ff0000;">
  content</span>:<span style="color: #0000ff;"> ')'</span>;
}<span style="color: #800000;">
#sideBar .twitter li </span>{<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 15px 20px</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;
}<span style="color: #800000;">
#sideBar .twitter li:last-of-type </span>{<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#sideBar .twitter small </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> block</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 1</span>;
}<span style="color: #800000;">
#sideBar .tagcloud .entry </span>{<span style="color: #ff0000;">
  padding-right</span>:<span style="color: #0000ff;"> 5px</span>;
}<span style="color: #800000;">
#sideBar .tagcloud a </span>{<span style="color: #ff0000;">
  margin-right</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> inline-block</span>;
}<span style="color: #800000;">
#footer </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 50px</span>;<span style="color: #ff0000;">
  font</span>:<span style="color: #0000ff;"> 0.9em/1.6 "Lato", Helvetica Neue, Helvetica, Arial, sans-serif</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;<span style="color: #ff0000;">
  text-align</span>:<span style="color: #0000ff;">center</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 30px 0px 50px</span>;
}<span style="color: #800000;">
.entry .gist </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #eee</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 15px</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 7px 15px</span>;<span style="color: #ff0000;">
  -webkit-border-radius</span>:<span style="color: #0000ff;"> 2px</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 2px</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 1.6</span>;<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> auto</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #666</span>;
}<span style="color: #800000;">
.entry .gist .gist-file </span>{<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> inherit</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;
}<span style="color: #800000;">
.entry .gist .gist-file .gist-data </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
.entry .gist .gist-file .gist-data pre </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0 !important</span>;<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;"> Monaco, Menlo, Consolas, Courier New, monospace</span>;
}<span style="color: #800000;">
.entry .gist .gist-file .gist-meta </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 5px</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 100%</span>;
}<span style="color: #800000;">
.entry .gist .gist-file .gist-meta a </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #258fb8</span>;
}<span style="color: #800000;">
.entry .gist .gist-file .gist-meta a:visited </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #258fb8</span>;
}<span style="color: #800000;">
figure.highlight </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #eee</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 15px</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 7px 15px</span>;<span style="color: #ff0000;">
  -webkit-border-radius</span>:<span style="color: #0000ff;"> 2px</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 2px</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;"> 1.6</span>;<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> auto</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> 0.9em</span>;
}<span style="color: #800000;">
figure.highlight figcaption </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;"> 5px</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;"> 0 0 1px #fff</span>;
}<span style="color: #800000;">
figure.highlight figcaption a </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">
  right</span>:<span style="color: #0000ff;"> 15px</span>;
}<span style="color: #800000;">
figure.highlight pre </span>{<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> none</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
figure.highlight table </span>{<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  border-spacing</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
figure.highlight .gutter </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #999</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 7px 10px 7px 5px !important</span>;<span style="color: #ff0000;">
  border-right</span>:<span style="color: #0000ff;"> 1px solid #ddd</span>;<span style="color: #ff0000;">
  text-align</span>:<span style="color: #0000ff;"> right</span>;
}<span style="color: #800000;">
figure.highlight .code </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 7px 7px 7px 10px !important</span>;<span style="color: #ff0000;">
  border-left</span>:<span style="color: #0000ff;"> 1px solid #fff</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #666</span>;
}<span style="color: #800000;">
pre .comment,
pre .template_comment,
pre .diff .header,
pre .doctype,
pre .pi,
pre .lisp .string,
pre .javadoc </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #93a1a1</span>;<span style="color: #ff0000;">
  font-style</span>:<span style="color: #0000ff;"> italic</span>;
}<span style="color: #800000;">
pre .keyword,
pre .winutils,
pre .method,
pre .addition,
pre .css .tag,
pre .request,
pre .status,
pre .nginx .title </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #859900</span>;
}<span style="color: #800000;">
pre .number,
pre .command,
pre .string,
pre .tag .value,
pre .phpdoc,
pre .tex .formula,
pre .regexp,
pre .hexcolor </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #2aa198</span>;
}<span style="color: #800000;">
pre .title,
pre .localvars,
pre .chunk,
pre .decorator,
pre .built_in,
pre .identifier,
pre .vhdl,
pre .literal,
pre .id </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #268bd2</span>;
}<span style="color: #800000;">
pre .attribute,
pre .variable,
pre .lisp .body,
pre .smalltalk .number,
pre .constant,
pre .class .title,
pre .parent,
pre .haskell .type </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #b58900</span>;
}<span style="color: #800000;">
pre .preprocessor,
pre .preprocessor .keyword,
pre .shebang,
pre .symbol,
pre .symbol .string,
pre .diff .change,
pre .special,
pre .attr_selector,
pre .important,
pre .subst,
pre .cdata,
pre .clojure .title </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #cb4b16</span>;
}<span style="color: #800000;">
pre .deletion </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> #dc322f</span>;
}<span style="color: #800000;">
.feedbackManage </span>{<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 160px</span>;<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">
  right</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  text-align</span>:<span style="color: #0000ff;"> right</span>;
}<span style="color: #800000;">
.cnblogs_code_toolbar </span>{<span style="color: #ff0000;">
  display</span>:<span style="color: #0000ff;"> none</span>;
}<span style="color: #800000;">
#cnblogs_post_body </span>{<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> hidden</span>;
}<span style="color: #800000;">
#cnblogs_post_body ol </span>{<span style="color: #ff0000;">
  padding-left</span>:<span style="color: #0000ff;"> 40px</span>;
}<span style="color: #800000;">
#cnblogs_post_body ul </span>{<span style="color: #ff0000;">
  margin-left</span>:<span style="color: #0000ff;"> 35px</span>;
}<span style="color: #800000;">
.fixedReadRank </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> fixed</span>;<span style="color: #ff0000;">
  top</span>:<span style="color: #0000ff;"> 20px</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 270px</span>;
}<span style="color: #800000;">
.fixedRecRank </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> fixed</span>;<span style="color: #ff0000;">
  top</span>:<span style="color: #0000ff;"> 360px</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 270px</span>;
}<span style="color: #800000;">
figure.highlight </span>{<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
figure table </span>{<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0 !important</span>;
}<span style="color: #800000;">
#cnblogs_post_body pre </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
#cnblogs_post_body th,
#cnblogs_post_body td </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
.cnblogs_code pre </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 7px 15px !important</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #f5f5f5</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
.cnblogs_code th </span>{<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px solid silver</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 3px</span>;
}<span style="color: #800000;">
.cnblogs_code </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;">评论标题</span><span style="color: #008000;">*/</span><span style="color: #800000;">
.feedback_area_title </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;">10px</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;">24px</span>;<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;">bold</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">#aaa</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;">1px dashed #ccc</span>;
}<span style="color: #800000;">
.feedbackListSubtitle </span>{<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;">12px</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">#888</span>;
}<span style="color: #800000;">
.feedbackListSubtitle a </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">#888</span>;
}<span style="color: #800000;">
.comment_quote </span>{<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;"> #eee</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 15px</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;"> 1px dashed #aaa</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 5px</span>;
}<span style="color: #800000;">
#commentform_title </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">#aaa</span>;<span style="color: #ff0000;">
  background-image</span>:<span style="color: #0000ff;">none</span>;<span style="color: #ff0000;">
  background-repeat</span>:<span style="color: #0000ff;">no-repeat</span>;<span style="color: #ff0000;">
  margin-bottom</span>:<span style="color: #0000ff;">10px</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;">10px 20px 10px 10px</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;">24px</span>;<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;">bold</span>;<span style="color: #ff0000;">
  border-bottom</span>:<span style="color: #0000ff;">1px dashed #ccc</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;">评论框</span><span style="color: #008000;">*/</span><span style="color: #800000;">
#comment_form </span>{<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;">10px 0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;">25px</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 343px</span>;<span style="color: #ff0000;">
  overflow</span>:<span style="color: #0000ff;"> hidden</span>;
}<span style="color: #800000;">
.commentform </span>{<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;">10px 0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;">10px 20px</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;">#fff</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;">评论输入域</span><span style="color: #008000;">*/</span><span style="color: #800000;">
#tbCommentBody </span>{<span style="color: #ff0000;">
  font-family</span>:<span style="color: #0000ff;">'MIcrosoft Yahei'</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;">10px</span>;<span style="color: #ff0000;">
  background</span>:<span style="color: #0000ff;">white</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">#333</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;">2px solid #fff</span>;<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;">inset 0 0 8px #aaa</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;">120px</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;">14px</span>;<span style="color: #ff0000;">
  min-height</span>:<span style="color: #0000ff;">120px</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;"> 10px</span>;
}
<span style="color: #008000;">/*</span><span style="color: #008000;">评论条目</span><span style="color: #008000;">*/</span><span style="color: #800000;">
.feedbackItem </span>{<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;">14px</span>;<span style="color: #ff0000;">
  line-height</span>:<span style="color: #0000ff;">24px</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;">10px 0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;">20px</span>;<span style="color: #ff0000;">
  padding-top</span>:<span style="color: #0000ff;">5px</span>;
}<span style="color: #800000;">
.feedbackListSubtitle </span>{<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;">normal</span>;
}

<span style="color: #008000;">/*</span><span style="color: #008000;">green_channel</span><span style="color: #008000;">*/</span><span style="color: #800000;">
#green_channel </span>{<span style="color: #ff0000;">
  text</span>:<span style="color: #0000ff;">align:right</span>;<span style="color: #ff0000;">
  padding-left</span>:<span style="color: #0000ff;">0px</span>;<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;">normal</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;">13px</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;">100%</span>;<span style="color: #ff0000;">
  border</span>:<span style="color: #0000ff;">1px dashed #ccc</span>;<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;">#fff</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;">4px</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;">5px auto</span>;
}<span style="color: #800000;">
@media screen and (max-width: 768px) </span>{<span style="color: #ff0000;">
  body {
    font-size</span>:<span style="color: #0000ff;"> 13px</span>;
  }<span style="color: #800000;">
  #main</span>{<span style="color: #ff0000;">
    padding</span>:<span style="color: #0000ff;">0px !important</span>;
  }<span style="color: #800000;">
  #mainContent</span>{<span style="color: #ff0000;">
    width</span>:<span style="color: #0000ff;"> 96%</span>;<span style="color: #ff0000;">
    float</span>:<span style="color: #0000ff;"> left</span>;<span style="color: #ff0000;">
    margin</span>:<span style="color: #0000ff;"> 0px 2%</span>;
  }<span style="color: #800000;">
  #sideBar </span>{<span style="color: #ff0000;">
    display</span>:<span style="color: #0000ff;"> none</span>;
  }<span style="color: #800000;">
  #blogTitle </span>{<span style="color: #ff0000;">
    width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
    float</span>:<span style="color: #0000ff;">none</span>;<span style="color: #ff0000;">
    margin</span>:<span style="color: #0000ff;"> 20px auto 0 !important</span>;
  }<span style="color: #800000;">
  #header </span>{<span style="color: #ff0000;">
    height</span>:<span style="color: #0000ff;">auto !important</span>;<span style="color: #ff0000;">
    margin</span>:<span style="color: #0000ff;"> 20px auto 5px</span>;
  }<span style="color: #800000;">
  #header #navigator </span>{<span style="color: #ff0000;">
    width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
    text-align</span>:<span style="color: #0000ff;"> center</span>;<span style="color: #ff0000;">
    float</span>:<span style="color: #0000ff;">none</span>;
  }<span style="color: #800000;">
  #header #navigator ul </span>{<span style="color: #ff0000;">
    width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
    margin-left</span>:<span style="color: #0000ff;"> 6%</span>;
  }<span style="color: #800000;">
  #header #navigator ul li </span>{<span style="color: #ff0000;">
    float</span>:<span style="color: #0000ff;"> left</span>;<span style="color: #ff0000;">
    width</span>:<span style="color: #0000ff;"> 25%</span>;<span style="color: #ff0000;">
    text-align</span>:<span style="color: #0000ff;"> center</span>;<span style="color: #ff0000;">
    margin-right</span>:<span style="color: #0000ff;">0px</span>;
  }<span style="color: #800000;">
  .postTitle, .entrylistPosttitle </span>{<span style="color: #ff0000;">
    font-size</span>:<span style="color: #0000ff;">14px</span>;<span style="color: #ff0000;">
    padding</span>:<span style="color: #0000ff;"> 20px 20px 15px 0px</span>;
  }<span style="color: #800000;">
  .postDesc, .entrylistItemPostDesc </span>{<span style="color: #ff0000;">
    padding</span>:<span style="color: #0000ff;"> 0px 20px 15px 0px</span>;
  }<span style="color: #800000;">
  #green_channel </span>{<span style="color: #ff0000;">
    padding</span>:<span style="color: #0000ff;">0px !important</span>;
  }<span style="color: #800000;">
  #blog_stats </span>{<span style="color: #ff0000;">
    display</span>:<span style="color: #0000ff;"> none</span>;
  }<span style="color: #800000;">
}
#blog-news label </span>{<span style="color: #ff0000;">
  box-shadow</span>:<span style="color: #0000ff;">5px 5px 5px #cccccc</span>;<span style="color: #ff0000;">
  text-shadow</span>:<span style="color: #0000ff;">5px 5px 5px #cccccc</span>;<span style="color: #ff0000;">
  border-radius</span>:<span style="color: #0000ff;">5px</span>;
}<span style="color: #800000;">
div.commentform textarea.comment_textarea </span>{<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 10px</span>;
}<span style="color: #800000;">
#tbCommentBody</span>{<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;">98%</span>;
}<span style="color: #800000;">
#cnblogs_post_body h3:hover </span>{<span style="color: #ff0000;">
  color</span>:<span style="color: #0000ff;"> green</span>;<span style="color: #ff0000;">
  font-size</span>:<span style="color: #0000ff;"> large</span>;<span style="color: #ff0000;">
  font-weight</span>:<span style="color: #0000ff;"> bold</span>;
}</pre>
</div>
<span class="cnblogs_code_collapse">转载&nbsp;<a href="https://www.cnblogs.com/hafiz/p/9276689.html">https://www.cnblogs.com/hafiz/p/9276689.html</a></span></div>
<h2>&nbsp;页面添加小心心</h2>
<h3>只需插入如下代码到【页首HTML代码】：</h3>
<div class="cnblogs_code">
<pre><span style="color: #800000;">&lt;script type="text/javascript"&gt;
(function(window, document, undefined) </span>{<span style="color: #ff0000;">
    var hearts = [];
    window.requestAnimationFrame = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
        function(callback) {
            setTimeout(callback, 1000 / 60);
        </span>}<span style="color: #800000;">
    })();
    init();
    function init() </span>{<span style="color: #ff0000;">
        css(".heart{width</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">height</span>:<span style="color: #0000ff;"> 10px</span>;<span style="color: #ff0000;">position</span>:<span style="color: #0000ff;"> fixed</span>;<span style="color: #ff0000;">background</span>:<span style="color: #0000ff;"> #f00</span>;<span style="color: #ff0000;">transform</span>:<span style="color: #0000ff;"> rotate(45deg)</span>;<span style="color: #ff0000;">-webkit-transform</span>:<span style="color: #0000ff;"> rotate(45deg)</span>;<span style="color: #ff0000;">-moz-transform</span>:<span style="color: #0000ff;"> rotate(45deg)</span>;}<span style="color: #800000;">.heart:after,.heart:before</span>{<span style="color: #ff0000;">content</span>:<span style="color: #0000ff;"> ''</span>;<span style="color: #ff0000;">width</span>:<span style="color: #0000ff;"> inherit</span>;<span style="color: #ff0000;">height</span>:<span style="color: #0000ff;"> inherit</span>;<span style="color: #ff0000;">background</span>:<span style="color: #0000ff;"> inherit</span>;<span style="color: #ff0000;">border-radius</span>:<span style="color: #0000ff;"> 50%</span>;<span style="color: #ff0000;">-webkit-border-radius</span>:<span style="color: #0000ff;"> 50%</span>;<span style="color: #ff0000;">-moz-border-radius</span>:<span style="color: #0000ff;"> 50%</span>;<span style="color: #ff0000;">position</span>:<span style="color: #0000ff;"> absolute</span>;}<span style="color: #800000;">.heart:after</span>{<span style="color: #ff0000;">top</span>:<span style="color: #0000ff;"> -5px</span>;}<span style="color: #800000;">.heart:before</span>{<span style="color: #ff0000;">left</span>:<span style="color: #0000ff;"> -5px</span>;}<span style="color: #800000;">");
        attachEvent();
        gameloop();
    }
    function gameloop() </span>{<span style="color: #ff0000;">
        for (var i = 0; i &lt; hearts.length; i++) {
            if (hearts[i].alpha &lt;= 0) {
                document.body.removeChild(hearts[i].el);
                hearts.splice(i, 1);
                continue;
            </span>}<span style="color: #800000;">
            hearts[i].y--;
            hearts[i].scale += 0.004;
            hearts[i].alpha -= 0.013;
            hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
        }
        requestAnimationFrame(gameloop);
    }
    function attachEvent() </span>{<span style="color: #ff0000;">
        var old = typeof window.onclick === "function" &amp;&amp; window.onclick;
        window.onclick = function(event) {
            old &amp;&amp; old();
            createHeart(event);
        </span>}<span style="color: #800000;">
    }
    function createHeart(event) </span>{<span style="color: #ff0000;">
        var d = document.createElement("div");
        d.className = "heart";
        hearts.push({
            el</span>:<span style="color: #0000ff;"> d,
            x: event.clientX - 5,
            y: event.clientY - 5,
            scale: 1,
            alpha: 1,
            color: randomColor()
        </span>}<span style="color: #800000;">);
        document.body.appendChild(d);
    }
    function css(css) </span>{<span style="color: #ff0000;">
        var style = document.createElement("style");
        style.type = "text/css";
        try {
            style.appendChild(document.createTextNode(css));
        </span>}<span style="color: #800000;"> catch(ex) </span>{<span style="color: #ff0000;">
            style.styleSheet.cssText = css;
        </span>}<span style="color: #800000;">
        document.getElementsByTagName('head')[0].appendChild(style);
    }
    function randomColor() </span>{<span style="color: #ff0000;">
        return "rgb(" + (~~ (Math.random() * 255)) + "," + (~~ (Math.random() * 255)) + "," + (~~ (Math.random() * 255)) + ")";
    </span>}<span style="color: #800000;">
})(window, document);
&lt;/script&gt;<br /><br /></span></pre>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">/*对比*/<br />&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text/javascript"</span><span style="color: #0000ff;">&gt;</span>
<span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> a_idx </span><span style="background-color: #f5f5f5; color: #000000;">=</span> <span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">;
jQuery(document).ready(</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">($) {
    $(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">body</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">).click(</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">(e) {
        </span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> a </span><span style="background-color: #f5f5f5; color: #000000;">=</span> <span style="background-color: #f5f5f5; color: #0000ff;">new</span><span style="background-color: #f5f5f5; color: #000000;"> Array(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">❤</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">);
        </span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> $i </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> $(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">&lt;span&gt;&lt;/span&gt;</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">).text(a[a_idx]);
        a_idx </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> (a_idx </span><span style="background-color: #f5f5f5; color: #000000;">+</span> <span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">) </span><span style="background-color: #f5f5f5; color: #000000;">%</span><span style="background-color: #f5f5f5; color: #000000;"> a.length;
        </span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> x </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> e.pageX,
        y </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> e.pageY;
        $i.css({
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">z-index</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: </span><span style="background-color: #f5f5f5; color: #000000;">999999999999999999999999999999999999999999999999999999999999999999999</span><span style="background-color: #f5f5f5; color: #000000;">,
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">top</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: y </span><span style="background-color: #f5f5f5; color: #000000;">-</span> <span style="background-color: #f5f5f5; color: #000000;">20</span><span style="background-color: #f5f5f5; color: #000000;">,
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">left</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: x,
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">position</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">absolute</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">font-weight</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">bold</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">color</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">rgb(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+~~</span><span style="background-color: #f5f5f5; color: #000000;">(</span><span style="background-color: #f5f5f5; color: #000000;">255</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">Math.random())</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+~~</span><span style="background-color: #f5f5f5; color: #000000;">(</span><span style="background-color: #f5f5f5; color: #000000;">255</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">Math.random())</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+~~</span><span style="background-color: #f5f5f5; color: #000000;">(</span><span style="background-color: #f5f5f5; color: #000000;">255</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">Math.random())</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">)</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">
        });
        $(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">body</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">).append($i);
        $i.animate({
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">top</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: y </span><span style="background-color: #f5f5f5; color: #000000;">-</span> <span style="background-color: #f5f5f5; color: #000000;">180</span><span style="background-color: #f5f5f5; color: #000000;">,
            </span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">opacity</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">: </span><span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">
        },
        </span><span style="background-color: #f5f5f5; color: #000000;">1500</span><span style="background-color: #f5f5f5; color: #000000;">,
        </span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">() {
            $i.remove();
        });
    });
});
</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
</div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">/*烟花特效<br /></span></pre>
<pre>&lt;script src="https://blog-static.cnblogs.com/files/zouwangblog/mouse-click.js"&gt;&lt;/script&gt;
&lt;canvas width="1777" height="841" style="position: fixed; left: 0px; top: 0px; z-index: 2147483647; pointer-events: none;"&gt;&lt;/canvas&gt;</pre>
<pre><span style="color: #000000;">*/
</span><span style="color: #0000ff;"><br /></span></pre>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>
<span style="background-color: #f5f5f5; color: #000000;">!</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">(){

</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> n(n,e,t){

</span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;"> n.getAttribute(e)</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">t

}

</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> e(n){

</span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;"> document.getElementsByTagName(n)

}

</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> t(){

</span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> t</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">e(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">script</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">),o</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">t.length,i</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">t[o</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">];

</span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;">{

l:o,z:n(i,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">zIndex</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">),o:n(i,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">opacity</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,.</span><span style="background-color: #f5f5f5; color: #000000;">5</span><span style="background-color: #f5f5f5; color: #000000;">),c:n(i,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">color</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">0,0,0</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">),n:n(i,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">count</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">99</span><span style="background-color: #f5f5f5; color: #000000;">)

}

}

</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> o(){

a</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">m.width</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">window.innerWidth</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">document.documentElement.clientWidth</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">document.body.clientWidth,

c</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">m.height</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">window.innerHeight</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">document.documentElement.clientHeight</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">document.body.clientHeight

}

</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> i(){

r.clearRect(</span><span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">,a,c);

</span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> n,e,t,o,m,l;

s.forEach(</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">(i,x){

</span><span style="background-color: #f5f5f5; color: #0000ff;">for</span><span style="background-color: #f5f5f5; color: #000000;">(i.x</span><span style="background-color: #f5f5f5; color: #000000;">+=</span><span style="background-color: #f5f5f5; color: #000000;">i.xa,i.y</span><span style="background-color: #f5f5f5; color: #000000;">+=</span><span style="background-color: #f5f5f5; color: #000000;">i.ya,i.xa</span><span style="background-color: #f5f5f5; color: #000000;">*=</span><span style="background-color: #f5f5f5; color: #000000;">i.x</span><span style="background-color: #f5f5f5; color: #000000;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;">a</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">i.x</span><span style="background-color: #f5f5f5; color: #000000;">&lt;</span><span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">?-</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">:</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">,i.ya</span><span style="background-color: #f5f5f5; color: #000000;">*=</span><span style="background-color: #f5f5f5; color: #000000;">i.y</span><span style="background-color: #f5f5f5; color: #000000;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;">c</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">i.y</span><span style="background-color: #f5f5f5; color: #000000;">&lt;</span><span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">?-</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">:</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">,r.fillRect(i.x</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">.</span><span style="background-color: #f5f5f5; color: #000000;">5</span><span style="background-color: #f5f5f5; color: #000000;">,i.y</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">.</span><span style="background-color: #f5f5f5; color: #000000;">5</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">),e</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">x</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">;e</span><span style="background-color: #f5f5f5; color: #000000;">&lt;</span><span style="background-color: #f5f5f5; color: #000000;">u.length;e</span><span style="background-color: #f5f5f5; color: #000000;">++</span><span style="background-color: #f5f5f5; color: #000000;">)n</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">u[e],

</span><span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">!==</span><span style="background-color: #f5f5f5; color: #000000;">n.x</span><span style="background-color: #f5f5f5; color: #000000;">&amp;&amp;</span><span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">!==</span><span style="background-color: #f5f5f5; color: #000000;">n.y</span><span style="background-color: #f5f5f5; color: #000000;">&amp;&amp;</span><span style="background-color: #f5f5f5; color: #000000;">(o</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">i.x</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">n.x,m</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">i.y</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">n.y,

l</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">o</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">o</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">m</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">m,l</span><span style="background-color: #f5f5f5; color: #000000;">&lt;</span><span style="background-color: #f5f5f5; color: #000000;">n.max</span><span style="background-color: #f5f5f5; color: #000000;">&amp;&amp;</span><span style="background-color: #f5f5f5; color: #000000;">(n</span><span style="background-color: #f5f5f5; color: #000000;">===</span><span style="background-color: #f5f5f5; color: #000000;">y</span><span style="background-color: #f5f5f5; color: #000000;">&amp;&amp;</span><span style="background-color: #f5f5f5; color: #000000;">l</span><span style="background-color: #f5f5f5; color: #000000;">&gt;=</span><span style="background-color: #f5f5f5; color: #000000;">n.max</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">2&amp;&amp;(i.x-=.03*o,i.y-=.03*m), </span>
<span style="background-color: #f5f5f5; color: #000000;">t</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">(n.max</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">l)</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">n.max,r.beginPath(),r.lineWidth=t</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">2</span><span style="background-color: #f5f5f5; color: #000000;">,r.strokeStyle</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">rgba(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">d.c</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">(t</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">.</span><span style="background-color: #f5f5f5; color: #000000;">2</span><span style="background-color: #f5f5f5; color: #000000;">)</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">)</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">,r.moveTo(i.x,i.y),r.lineTo(n.x,n.y),r.stroke()))

}),

x(i)

}

</span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> a,c,u,m</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">document.createElement(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">canvas</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">),

d</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">t(),l</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">c_n</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">d.l,r</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">m.getContext(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">2d</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">),
x</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">window.requestAnimationFrame</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">window.webkitRequestAnimationFrame</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">window.mozRequestAnimationFrame</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">window.oRequestAnimationFrame</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">window.msRequestAnimationFrame</span><span style="background-color: #f5f5f5; color: #000000;">||</span>

<span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">(n){

window.setTimeout(n,</span><span style="background-color: #f5f5f5; color: #000000;">1e3</span><span style="background-color: #f5f5f5; color: #000000;">/</span><span style="background-color: #f5f5f5; color: #000000;">45) </span>
<span style="background-color: #f5f5f5; color: #000000;">},

w</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">Math.random,y</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">{x:</span><span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">,y:</span><span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">,max:</span><span style="background-color: #f5f5f5; color: #000000;">2e4</span><span style="background-color: #f5f5f5; color: #000000;">};m.id</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">l,m.style.cssText</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">position:fixed;top:0;left:0;z-index:</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">d.z</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">;opacity:</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">+</span><span style="background-color: #f5f5f5; color: #000000;">d.o,e(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">body</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">)[</span><span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">].appendChild(m),o(),window.onresize</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">o,

window.onmousemove</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">(n){

n</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">n</span><span style="background-color: #f5f5f5; color: #000000;">||</span><span style="background-color: #f5f5f5; color: #000000;">window.event,y.x</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">n.clientX,y.y</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">n.clientY

},

window.onmouseout</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">(){

y.x</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">,y.y</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">

};

</span><span style="background-color: #f5f5f5; color: #0000ff;">for</span><span style="background-color: #f5f5f5; color: #000000;">(</span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> s</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">[],f</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">;d.n</span><span style="background-color: #f5f5f5; color: #000000;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;">f;f</span><span style="background-color: #f5f5f5; color: #000000;">++</span><span style="background-color: #f5f5f5; color: #000000;">){

</span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> h</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">w()</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">a,g</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">w()</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">c,v</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">2</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">w()</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">,p</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">2</span><span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;">w()</span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">;s.push({x:h,y:g,xa:v,ya:p,max:</span><span style="background-color: #f5f5f5; color: #000000;">6e3</span><span style="background-color: #f5f5f5; color: #000000;">})

}

u</span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;">s.concat([y]),

setTimeout(</span><span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;">(){i()},</span><span style="background-color: #f5f5f5; color: #000000;">100</span><span style="background-color: #f5f5f5; color: #000000;">)

}();

</span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
</div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">/*雪花特效*/

</span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">class</span><span style="color: #0000ff;">="Snow"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">canvas </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="Snow"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">canvas</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">src</span><span style="color: #0000ff;">="https://blog-static.cnblogs.com/files/zouwangblog/xue.js"</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>注：<a href="https://www.cnblogs.com/cainiao-chuanqi/p/11287963.html#autoid-0-0-0" target="_blank">备忘录！</a></strong><br /><span style="margin: 0px; padding: 0px; font-family: 'Courier New'; white-space: pre-wrap; background-color: #f5f5f5; line-height: 1 !important;"><br /></span></p>]]></description></item><item><title>多线程面试题(含答案)</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/01/11285751.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 01 Aug 2019 14:17:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/01/11285751.html</guid><description><![CDATA[<h2><strong>1~10题</strong></h2>
<p><strong>1</strong><strong>、并发编程三要素？</strong></p>
<p>1）原子性</p>
<ul>
<li>原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。</li>
</ul>
<p>2）可见性</p>
<ul>
<li>可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。</li>
</ul>
<p>3）有序性</p>
<ul>
<li>有序性，即程序的执行顺序按照代码的先后顺序来执行。</li>
</ul>
<p>&nbsp;</p>
<p><strong>2、实现可见性的方法有哪些？</strong></p>
<p>synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</p>
<p><strong>&nbsp;</strong></p>
<p><strong>3、多线程的价值？</strong></p>
<p>1）发挥多核CPU的优势</p>
<ul>
<li>多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的，采用多线程的方式去同时完成几件事情而不互相干扰。</li>
</ul>
<p>2）防止阻塞</p>
<ul>
<li>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</li>
</ul>
<p>3）便于建模</p>
<ul>
<li>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</li>
</ul>
<p>&nbsp;</p>
<p><strong>4.创建线程的三种方式的对比？</strong></p>
<p>1）采用实现Runnable、Callable接口的方式创建多线程。</p>
<p>优势是：</p>
<ul>
<li>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</li>
<li>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
</ul>
<p>劣势是：</p>
<ul>
<li>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</li>
</ul>
<p>2）使用继承Thread类的方式创建多线程</p>
<p>优势是：</p>
<ul>
<li>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。</li>
</ul>
<p>劣势是：</p>
<ul>
<li>线程类已经继承了Thread类，所以不能再继承其他父类。</li>
</ul>
<p>3）Runnable和Callable的区别</p>
<ul>
<li>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。</li>
<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</li>
<li>Call方法可以抛出异常，run方法不可以。</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ul>
<p>线程的生命周期及五种基本状态：</p>
<p>&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190801220852383-427751876.jpg" alt="" /></p>
<p>&nbsp;</p>
<p><strong>6.Java线程具有五中基本状态</strong></p>
<ul>
<li>1）新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread()；</li>
<li>2）就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li>
<li>3）运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li>
<li>4）阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</li>
<li>根据阻塞产生的原因不同，阻塞状态又可以分为三种：</li>
<li>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li>
<li>2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li>
<li>3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
<li>5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ul>
<p><strong>&nbsp;</strong></p>
<p><strong>7.什么是线程池？有哪几种创建方式？</strong></p>
<p>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。</p>
<p>java 提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。</p>
<p><strong>&nbsp;</strong></p>
<p><strong>8.四种线程池的创建：</strong></p>
<ul>
<li>（1）newCachedThreadPool创建一个可缓存线程池</li>
<li>（2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。</li>
<li>（3）newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>（4）newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。</li>
</ul>
<p><strong>&nbsp;</strong></p>
<p><strong>9.线程池的优点？</strong></p>
<ul>
<li>1）重用存在的线程，减少对象创建销毁的开销。</li>
<li>2）可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>
<li>3）提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ul>
<p>&nbsp;</p>
<p><strong>10.常用的并发工具类有哪些？</strong></p>
<ul>
<li>CountDownLatch</li>
<li>CyclicBa</li>
<li>rrier</li>
<li>Semaphore</li>
<li>Exchanger</li>
</ul>
<h2>&nbsp;10~20题</h2>
<p><strong>11.CyclicBarrier和CountDownLatch的区别</strong></p>
<ul>
<li>1)CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。</li>
<li>2)cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！</li>
<li>3)CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>4)CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。</li>
</ul>
<p>&nbsp;</p>
<p><strong>12.synchronized的作用？</strong></p>
<p>在Java中，synchronized关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized代码段不被多个线程同时执行。</p>
<p>synchronized既可以加在一段代码上，也可以加在方法上。</p>
<p>&nbsp;</p>
<p><strong>13.volatile关键字的作用</strong></p>
<ul>
<li>对于可见性，Java提供了volatile关键字来保证可见性。</li>
<li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</li>
<li>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</li>
</ul>
<p>&nbsp;</p>
<p><strong>14.什么是CAS</strong></p>
<ul>
<li>CAS是compare and swap的缩写，即我们所说的比较交换。</li>
<li>cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。</li>
<li>CAS 操作包含三个操作数 &mdash;&mdash; 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</li>
<li>java.util.concurrent.atomic 包下的类大多是使用CAS操作来实现的( AtomicInteger,AtomicBoolean,AtomicLong)。</li>
</ul>
<p>&nbsp;</p>
<p><strong>15. CAS的问题</strong></p>
<ul>
<li>1）CAS容易造成ABA问题。一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。</li>
<li>2） 不能保证代码块的原子性</li>
</ul>
<p>CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。</p>
<ul>
<li>3）CAS造成CPU利用率增加。之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。</li>
</ul>
<p>&nbsp;</p>
<p><strong>16.什么是Future？</strong></p>
<p>在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现Callback接口，并用Future可以来接收多线程的执行结果。</p>
<p>Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。</p>
<p>&nbsp;</p>
<p><strong>17.什么是AQS</strong></p>
<p>AQS是AbustactQueuedSynchronizer的简称，它是一个Java提高的底层同步工具类，用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。</p>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p>
<p>&nbsp;</p>
<p><strong>18. AQS支持两种同步方式：</strong></p>
<ul>
<li>1.独占式</li>
<li>2.共享式</li>
</ul>
<p>这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p>&nbsp;</p>
<p><strong>19.ReadWriteLock是什么</strong></p>
<p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p>
<p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>
<p>&nbsp;</p>
<p><strong>20.FutureTask是什么</strong></p>
<p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p>
<h2>&nbsp;20~30题</h2>
<p><strong>21.synchronized和ReentrantLock的区别</strong></p>
<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>
<ul>
<li>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>（2）ReentrantLock可以获取各种锁的信息</li>
<li>（3）ReentrantLock可以灵活地实现多路通知</li>
</ul>
<p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p>
<p><strong>&nbsp;</strong></p>
<p><strong>22.什么是乐观锁和悲观锁</strong></p>
<ul>
<li>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</li>
<li>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</li>
</ul>
<p>&nbsp;</p>
<p><strong>23.线程B怎么知道线程A修改了变量</strong></p>
<ul>
<li>volatile修饰变量</li>
<li>synchronized修饰修改变量的方法</li>
<li>wait/notify</li>
<li>while轮询</li>
</ul>
<p>&nbsp;</p>
<p><strong>24.synchronized、volatile、CAS比较</strong></p>
<ul>
<li>synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。</li>
<li>volatile提供多线程共享变量可见性和禁止指令重排序优化。</li>
<li>CAS是基于冲突检测的乐观锁（非阻塞）</li>
</ul>
<p><strong>&nbsp;</strong></p>
<p><strong>25.sleep方法和wait方法有什么区别?</strong></p>
<p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>
<p>&nbsp;</p>
<p><strong>26.ThreadLocal是什么？有什么用？</strong></p>
<p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p>
<p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
<p>&nbsp;</p>
<p><strong>27.为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</strong></p>
<p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<p>&nbsp;</p>
<p><strong>28.多线程同步有哪几种方法？</strong></p>
<p>Synchronized关键字，Lock锁实现，分布式锁等。</p>
<p>&nbsp;</p>
<p><strong>29.线程的调度策略</strong></p>
<p>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p>
<ul>
<li>（1）线程体中调用了yield方法让出了对cpu的占用权利</li>
<li>（2）线程体中调用了sleep方法使线程进入睡眠状态</li>
<li>（3）线程由于IO操作受到阻塞</li>
<li>（4）另外一个更高优先级线程出现</li>
<li>（5）在支持时间片的系统中，该线程的时间片用完</li>
</ul>
<p>&nbsp;</p>
<p><strong>30.ConcurrentHashMap的并发度是什么</strong></p>
<p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>
<p>&nbsp;</p>
<h2>&nbsp;30~40题</h2>
<p><strong>31.Linux环境下如何查找哪个线程使用CPU最长</strong></p>
<ul>
<li>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</li>
<li>（2）top -H -p pid，顺序不能改变</li>
</ul>
<p>&nbsp;</p>
<p><strong>32.Java死锁以及如何避免？</strong></p>
<p>Java中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java死锁情况出现至少两个线程和两个或更多资源。</p>
<p>Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。</p>
<p>&nbsp;</p>
<p><strong>33.死锁的原因</strong></p>
<ul>
<li>1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。</li>
</ul>
<p>例如：线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。</p>
<ul>
<li>2）默认的锁申请操作是阻塞的。</li>
</ul>
<p>所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。</p>
<p>&nbsp;</p>
<p><strong>34.怎么唤醒一个阻塞的线程</strong></p>
<p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
<p>&nbsp;</p>
<p><strong>35.不可变对象对多线程有什么帮助</strong></p>
<p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p>
<p>&nbsp;</p>
<p><strong>36.什么是多线程的上下文切换</strong></p>
<p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<p>&nbsp;</p>
<p><strong>37.如果你提交任务时，线程池队列已满，这时会发生什么</strong></p>
<p>这里区分一下：</p>
<ul>
<li>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</li>
<li>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li>
</ul>
<p>&nbsp;</p>
<p><strong>38.Java中用到的线程调度算法是什么</strong></p>
<p>抢占式：一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<p>&nbsp;</p>
<p><strong>39.什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</strong></p>
<p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>40.什么是自旋</strong></p>
<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<h2>&nbsp;40~48题</h2>
<p><strong>41.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</strong></p>
<p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<ul>
<li>可以使锁更公平</li>
<li>可以使线程在等待锁的时候响应中断</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁</li>
</ul>
<p>&nbsp;</p>
<p><strong>42.单例模式的线程安全性</strong></p>
<p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<ul>
<li>（1）饿汉式单例模式的写法：线程安全</li>
<li>（2）懒汉式单例模式的写法：非线程安全</li>
<li>（3）双检锁单例模式的写法：线程安全</li>
</ul>
<p>&nbsp;</p>
<p><strong>43.Semaphore有什么作用</strong></p>
<p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p>
<p>&nbsp;</p>
<p><strong>44.Executors类是什么？</strong></p>
<p>Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。</p>
<p>Executors可以用于方便的创建线程池</p>
<p>&nbsp;</p>
<p><strong>45.线程类的构造方法、静态块是被哪个线程调用的</strong></p>
<p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>
<p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>
<ul>
<li>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</li>
<li>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</li>
</ul>
<p>&nbsp;</p>
<p><strong>46.同步方法和同步块，哪个是更好的选择？</strong></p>
<p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p>
<p>&nbsp;</p>
<p><strong>47.Java线程数过多会造成什么异常？</strong></p>
<ul>
<li>1)线程的生命周期开销非常高</li>
<li>2)消耗过多的CPU资源</li>
</ul>
<p>如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。</p>
<ul>
<li>3)降低稳定性</li>
</ul>
<p>JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常。</p>
<p><strong>&nbsp;</strong></p>
<p><strong>48、创建线程的有哪些方式？</strong></p>
<ul>
<li>1）继承Thread类创建线程类</li>
<li>2）通过Runnable接口创建线程类</li>
<li>3）通过Callable和Future创建线程</li>
<li>4）通过线程池创建</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：线程的安全问题</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/01/11285626.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 01 Aug 2019 13:52:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/01/11285626.html</guid><description><![CDATA[<h2>线程的安全问题</h2>
<p><strong>模拟卖票案例</strong><br />创建三个的线程，同时开启，对共享的票进行出售</p>
<p><br /><img src="https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190801211824600-1725164345.jpg" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>public class<span> RunnableImpl implementsc Runnable{
    //定义一个多线程共享的票源
    private int ticket = 100<span>；
    
    //设置线程任务：买票
<span>    @Override
    public void<span> run(){
        //使用死循环，让卖票操作重复执行
        while (true<span>){
            //先判断票是否存在
            if(ticket&gt;0<span>){
                //提高安全问题出现的概率，让程序睡眠
                try<span>{
                    Thread.sleep(10<span>);
                }catch<span> (InterruptedException e){
                    e.printStackTrace();
                }
                //票存在，卖票 ticket--
                System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"<span>);
                ticket --<span>;
            }
        }
    }
}


public class<span> CaiNiao{
    public static void<span> main(String[] args){
        //创建Runnable接口的实现类对象
        RunnableImpl run = new<span> RunnableImpl();
        //创建Thread类对象，构造方法中传递Runnable接口的实现类对象
        Thread t0 = new<span> Thread(run);        
        Thread t1 = new<span> Thread(run);        
        Thread t2 = new<span> Thread(run);        
        //调用start方法开启多线程
<span>        t0.start();
        t1.start();
        t2.start();
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p><strong>这样会导致一个结果</strong></p>
<ul>
<li>Thread-0 --&gt;正在卖第1张票</li>
<li>Thread-1 --&gt;正在卖第1张票</li>
<li>Thread-2 --&gt;正在卖第0张票</li>
</ul>
<p>&nbsp;</p>
<h3><strong>解决线程安全问题的一种方案</strong>：使用同步代码块</h3>
<p><strong>格式：</strong></p>
<div class="cnblogs_code">
<pre><span>格式：
    syncharonized(锁对象){
        可能会出现线程安全问题的代码（访问了共享数据的代码）        
    }</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>注意：</strong></p>
<ul>
<li>通过代码块中的锁对象，可以使用任意的对象</li>
<li>但是必须要保证多个线程使用的锁对象是同一个</li>
</ul>
<p><strong>锁对象作用</strong></p>
<ul>
<li>把同步代码块锁住，只让一个线程在同步代码中执行</li>
</ul>
<div class="cnblogs_code">
<pre>public class<span> RunnableImpl implementsc Runnable{
    //定义一个多线程共享的票源
    private int ticket = 100<span>；
    
    //设置线程任务：买票
<span>    @Override
    public void<span> run(){
        //使用死循环，让卖票操作重复执行
        while (true<span>){
            //同步代码块
<span>            syncharonized(obj){
                //先判断票是否存在
                if(ticket&gt;0<span>){
                    //提高安全问题出现的概率，让程序睡眠
                    try<span>{
                        Thread.sleep(10<span>);
                    }catch<span> (InterruptedException e){
                        e.printStackTrace();
                    }
                    //票存在，卖票 ticket--
                    System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"<span>);
                    ticket --<span>;    
            }</span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<h3>解决线程安全问题的二种方案：使用同步方法</h3>
<p><strong>使用步骤:</strong></p>
<ol>
<li>把访问了共享数据的代码抽取出来，放到一个方法中</li>
<li>在方法上添加synchronized修饰符</li>
</ol>
<p><strong>格式：</strong>定义方法的格式</p>
<div class="cnblogs_code">
<pre>    修饰符 synchronized<span> 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码（访问了共享数据的代码）
    }</span></pre>
</div>
<p>&nbsp;</p>
<h3><br />解决线程安全问题的三种方案：使用Lock锁</h3>
<p><strong>java.util.concurrent.Locks.Lock接口</strong><br />Lock实现提供了比使用synchronized 方法和语句可获得的更广泛的锁定操作。</p>
<p><strong>Lock接口中的方法：</strong></p>
<div class="cnblogs_code">
<pre>　　void<span> Lock()获取锁
　　void<span> unLock() 释放锁
java.util.concurrent.Locks.ReentrantLock implements Lock 接口</span></span></pre>
</div>
<p>&nbsp;</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>在成员位置创建一个ReentrantLock对象</li>
<li>在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取锁</li>
<li>在可能会出现安全问题的代码前调后用Lock接口中的方法unLock释放锁</li>
</ol>
<p>/</p>
<div class="cnblogs_code">
<pre>//1.在成员位置创建一个ReentrantLock对象
Lock l = new<span> ReentrantLock();

@Override
    public void<span> run(){
        //使用死循环，让卖票操作重复执行
        while (true<span>){
            //2. 在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取锁
<span>            l.lock();
            
            //同步代码块
<span>            syncharonized(obj){
                //先判断票是否存在
                if(ticket&gt;0<span>){
                    //提高安全问题出现的概率，让程序睡眠
                    try<span>{
                        Thread.sleep(10<span>);
                    }catch<span> (InterruptedException e){
                        e.printStackTrace();
                    }
                    //票存在，卖票 ticket--
                    System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"<span>);
                    ticket --<span>;    
                }
                //3.在可能会出现安全问题的代码前调后用Lock接口中的方法unLock释放锁
                l.unLock();//无论程序释放异常，锁都会释放
            </span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：线程实现方式</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/01/11285428.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 01 Aug 2019 13:17:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/08/01/11285428.html</guid><description><![CDATA[<h2>线程实现方式</h2>
<h3>并发与并行</h3>
<ul>
<li><strong>并发：</strong>指两或多个事件在<strong>同一个时间段</strong>内发生</li>
<li><strong>并行：</strong>指两或多个事件在<strong>同一个时刻</strong>发生（同时发生）</li>
</ul>
<p>&nbsp;</p>
<h3>进程的概念</h3>
<p><strong>内存：</strong>所有的应用程序都需要进入到内存中执行 临时存储RAM</p>
<p><strong>硬盘：</strong>永久存储ROM</p>
<ul>
<li><strong>进入到内存的程序叫进程</strong></li>
<li><strong>任务管理器--&gt;结束进程</strong></li>
<li>那么就把进程从内存中清除了</li>
</ul>
<p>&nbsp;</p>
<h3>线程的概念</h3>
<p>点击一个应用程序的功能执行，就会开启一条应用程序到cpu的执行路径，cup就可以通过这个路径执行功能，这个路径有一个名字，叫<strong>线程。</strong></p>
<p><strong>线程属于进程：</strong>是进程中的一个执行单元，负责程序的执行</p>
<p>线程的<strong>好处：</strong></p>
<ol>
<li>效率高</li>
<li>多线程之间互不影响</li>
</ol>
<p><strong>如：</strong><br /><strong>单核心线程cpu</strong></p>
<ul>
<li>cpu在多个线程之间做高速的切换</li>
<li>轮流执行多个线程</li>
<li>效率低</li>
<li>切换的速度块（1/n毫秒）</li>


</ul>
<p><strong>4核心8线程</strong></p>
<ul>
<li>有8个线程，可以同时执行8个线程</li>
<li>8个线程在多个任务之间做高速的切换</li>
<li>速度是单线程cpu的8倍(每个执行到的几率都被提高了8倍）</li>


</ul>
<p>&nbsp;</p>
<h3>线程的调度</h3>
<p><strong>分时调度</strong></p>
<ul>
<li>所有线程轮流使用cpu的使用权</li>


</ul>
<p><strong>抢占式调度</strong></p>
<ul>
<li>优先级高的线程使用cpu先使用，若相同，随机选择一个。Java使用的就是抢占式调度。</li>


</ul>
<p>&nbsp;</p>
<h3>主线程</h3>
<p><strong>主线程：</strong>执行主<strong>（main）</strong>方法的线程</p>
<p><strong>单线程程序：</strong>Java程序中只有一个线程<br />执行从main方法开始，从上到下依次执行</p>
<ul>
<li>JVM执行main方法，main方法会进入到栈内存</li>
<li>JVM会找操作系统开辟一条main方法通向cpu的执行路径</li>
<li>cpu就可以通过这个路径来执行main方法</li>
<li>而这个路径有一个名字，叫main（主）线程</li>


</ul>
<p>&nbsp;</p>
<h3>创建多线程</h3>
<p>创建多线程程序的<strong>第一种方式：创建Thread的子类</strong><br /><strong>java.lang.Thread类：</strong>是描述线程的类，我们想要实现多线程程序，就必须继承Thread类。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>创建一个Thread类的子类</li>
<li>在Thread类的子类中重写Thread类的run方法，设置线程任务（开启线程要做什么？）</li>
<li>创建Thread类的子类对象</li>
<li>调用Thread类中的方法start方法，开启新的线程，执行run方法。</li>


</ol>
<ul>
<li>void start() 使该线程开始执行；Java虚拟机调用该线程的run方法。</li>
<li>结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建地新线程，执行其run方法）。</li>
<li>多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</li>


</ul>
<p>Java使用的就是抢占式调度。优先级高的线程使用cpu先使用，若相同，随机选择一个。</p>
<div class="cnblogs_code">
<pre>//1.创建一个Thread类的子类
public class MyThread extends<span> Thread{
    //2.在Thread类的子类中重写Thread类的run方法，设置线程任务（开启线程要做什么？）
<span>    @Override
    public void<span> run(){
        for (int i = 0;i&lt;20;i++<span>){
            System.out.println("run:"+1<span>);
        }
    }
}
    
public class<span> CaiNiao{
    public static void<span> main(String[] args){
        //3 创建Thread类的子类对象
        MyThread mt = new<span> MyThread();
        //4.调用Thread类中的方法start方法，开启新的线程，执行run方法。
<span>        mt.start();
    
        //主线程会继续执行主方法中的代码
        for (int i = 0;i&lt;37;i++<span>){
            System.out.println("main:"+<span>i);
        }
    
    }
}</span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>创建多线程程序的<strong>第二种方法：实现Runnable接口</strong><br /><strong>java.lang.Runnable</strong></p>
<ul>
<li>Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为run的无参数方法。</li>


</ul>
<p><strong>java.lang.Thread类的构造方法</strong></p>
<ul>
<li>Thread(Runnable target)分配新的 Thread对象。</li>
<li>Thread(Runnable target，String name)分配新的 Thread对象。</li>


</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li>创建一个Runnable接口的实现类</li>
<li>在实现类中重写Runnable接口的run方法，设置线程任务</li>
<li>创建一个Runnable 接口的实现类对象</li>
<li>创建Thread类对象，构造方法中传递Runnable接口的实现类对象</li>
<li>调用Thread类中的方法<strong>start方法</strong>，开启新的线程，执行run方法。</li>


</ol>
<p><strong>实现Runnable接口创建多线程程序的好处：</strong><br /><strong>1&nbsp;避免了单继承的局限性</strong></p>
<ul>
<li>一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类</li>
<li>实现Runnable接口，还可以继承其他的类，实现其他的接口</li>


</ul>
<p><strong>2 增强了程序的扩展性，降低了程序的耦合性（解耦）</strong></p>
<ul>
<li>实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）</li>
<li>实现类中，重写了run方法：用来设置线程任务</li>
<li>创建Thread类对象，调用Thread类中的方法start方法，开启新的线程，执行run方法。</li>


</ul>
<p>&nbsp;</p>
<p><strong>匿名内部类方式实现线程的创建</strong></p>
<ul>
<li><strong>匿名：</strong>没有名字</li>
<li><strong>内部类：</strong>写在其他类内部的类</li>


</ul>
<p><strong>匿名内部类的作用：</strong>简化代码</p>
<ul>
<li>把子类继承父类，重写父类的方法，创建子类对象合一步完成</li>
<li>把实现类实现类接口，重写接口中的方法，创建实现类对象合一步完成</li>


</ul>
<p><strong>格式：</strong></p>
<div class="cnblogs_code">
<pre>new 父类/<span>接口(){
    重置父类/<span>接口中的方法
};

//线程的父类是Thread
//new MyThread().start();

//线程的接口Runnable
//Runnable r = RunnableTmpl();//多态
//new Runnable(r).start();</span></span></pre>
</div>
<p>&nbsp;</p>
<p><strong>Thread类的常用方法</strong><br /><strong>获取线程的名称：</strong></p>
<ol>
<li>使用Thread类中的方法getName() 返回该线程的名称。</li>
<li>static Thread currentThread() 返回对当前正在执行的线程对象的引用。</li>


</ol>
<p><strong>设置线程的名称：</strong></p>
<ol>
<li>使用Thread类中的方法setName(名字)</li>
<li>void setName(String name) 改变线程的名称，使之参数 name相同。</li>


</ol>
<ul>
<li>public void start():使该线程开始执行；Java虚拟机调用该线程的run方法</li>
<li>public void run():此线程要执行的任务在此处定义代码</li>
<li>public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行）。</li>


</ul>]]></description></item><item><title>Java学习：异常的概念</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/31/11279691.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 31 Jul 2019 14:46:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/31/11279691.html</guid><description><![CDATA[<h2>异常</h2>
<h3><strong>异常概念</strong></h3>
<p><strong>异常:</strong>指的是程序在执行过程中，出现的非正常的情况，最终导致JVM的非正常停止。</p>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出一个异常对象。Java处理异常的方式是中断处理。</p>
<h3><strong>异常体系</strong></h3>
<p>异常机制其实是帮助我们找到程序中的问题，异常的根类是<strong>java.lang.Throwable</strong>,其下有两个子类：<br /><strong>java.lang.Error</strong>与<strong>java.lang.Exception,</strong>平常所说的异常指java.lang.Exception</p>
<p><strong>java.lang.Throwable：类是Java语言中所有错误或异常的超类。</strong></p>
<p> Exception：<strong>编译期异常</strong>，进行编译（代码）Java程序出现的问题</p>
<ul>
<li>RuntimeException：运行期异常，Java程序运行过程中出现的问题</li>
<li>		异常就相当于程序得了一个小毛病(感冒 发烧),把异常处理掉可以继续执行（吃药）</li>

</ul>
<p>	Error：<strong>错误</strong></p>
<ul>
<li>		错误就相当于程序得了一个无法治愈的毛病，必须修改源代码，程序才能继续执行</li>

</ul>
<h3><br />异常的产生过程的解析</h3>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span>[] arr = {1,2,3<span style="color: #000000;">};
</span><span style="color: #0000ff;">int</span> e = getElement(arr,3);</pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>1）</strong>访问数组中的3索引，而数组是没有3索引的，这时候，<strong>JVM就会检测程序出现异常</strong><br />JVM会做两件事：</p>
<ul>
<li>	1.JVM会根据异常产生的原因创建一个异常对象，这个异常对象包含了异常产生的（内容，原因，位置）</li>

</ul>
<p>		new ArrayIndexOutOfBoundsException("3");</p>
<ul>
<li>	2.在getElement方法中，没有异常的处理逻辑（try...catch),那么JVM就会把异常对象抛出给方法的调用者，main方法来处理这个异常。</li>

</ul>
<p><strong>2）main方法接收到这个异常对象，</strong>main方法也没有异常的处理逻辑，继续把对象抛出给main方法的调用者JVM处理<br />	new ArrayIndexOutOfBoundsException("3");</p>
<p><strong>3）JVM接收到了这个异常对象</strong>，做了两件事情<br />	new ArrayIndexOutOfBoundsException("3");</p>
<ul>
<li>	1.把异常对象（内容，原因，位置）以红色的字体打印在控制台</li>
<li>	2.JVM会终止当前在执行的Java程序--&gt;终端处理</li>

</ul>
<h3>异常的处理</h3>
<p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<p><strong>throw关键字</strong><br /><strong>作用：</strong></p>
<ul>
<li>	可以使用throw关键字在指定的方法中抛出指定的异常</li>

</ul>
<p><strong>使用格式：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> xxxException("异常产生的原因");</pre>
</div>
<p><strong>注意：</strong></p>
<ol>
<li>throw关键字必须写在方法的内部</li>
<li>throw关键字后边new的对象必须是Exception或者Exception的子类对象</li>
<li>throw关键字抛出指定的异常对象，我们就必须处理这个异常对象</li>
</ol>
<ul>
<li>throw关键字后边创建的是RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）</li>
<li>throw关键字后边创建的是编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws，要么try...catch</li>
</ul>
<p><br /><strong>Objects类中的静态方法</strong><br />public static &lt;T&gt; T reguireNonNull(T obj):查看指定引用对象不是null。<br /><strong>源码：</strong></p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> &lt;T&gt;<span style="color: #000000;"> T reguireNonNull(T obj){
        </span><span style="color: #0000ff;">if</span> (obj == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> NullPointerException();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> obj;
    }
    </span></pre>
</div>
<p>&nbsp;</p>
<p><br /><br /><strong>throws声明异常</strong><br /><strong>throws关键字</strong>：异常处理的第一种方式，交给别人处理<br /><strong>作用：</strong></p>
<ul>
<li>	当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象</li>
<li>	可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终交给JVM处理--&gt;中断处理</li>

</ul>
<p><strong>使用格式：</strong>在方法声明时使用</p>
<div class="cnblogs_code">
<pre>    修饰符 返回值类型 方法名(参数列表) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> AAAException ,BBBException...{
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> AAAException("产生原因"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BBBException("产生原因"<span style="color: #000000;">);
    }</span></pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>注意：</strong></p>
<ol>
<li>throws关键字必须写在方法声明处</li>
<li>throws关键字后边声明的异常必须是Exception或者是Exception的子类</li>
<li>方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常</li>
<li>		如果抛出的多个异常对象有父子类关系，那么直接声明父类异常即可</li>
<li>调用了一个声明抛出异常的方法，我们就必须处理这个异常对象</li>

</ol>
<ul>
<li>		要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM </li>
<li>		要么try...catch自己处理异常</li>

</ul>
<p><strong>捕获异常try...catch</strong></p>
<p><strong>try...catch:</strong>异常处理的第二种方式，自己处理异常</p>
<p><strong>格式：</strong></p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">try</span><span style="color: #000000;">{
        可能产生异常的代码
    }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">（定义一个异常的变量，用来接收try中抛出的异常对象）{
        异常的处理逻辑，在异常对象之后，怎么处理异常对象
        一般在工作中，会把异常的信息记录到一个日志中
    }
    ...
    </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(异常类名 变量名){
        
    }</span></pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>注意：</strong></p>
<ol>
<li>try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象</li>
<li>如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码</li>

</ol>
<p>		如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try...catch之后的代码<br /><br /><strong>Throwable类中定义了3个异常处理的方法</strong></p>
<ol>
<li>			String getMessage() 返回 Throwable 的简短描述</li>
<li>			String toString() 返回 Throwable 的详细消息字符串</li>
<li>			void printStackTrace() JVM打印异常对象，默认此方法，打印的异常信息是最全面的</li>

</ol>
<p><br /><strong>finally代码块</strong><br /><strong>格式：</strong></p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">try</span><span style="color: #000000;">{
        可能产生异常的代码
    }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">（定义一个异常的变量，用来接收try中抛出的异常对象）{
        异常的处理逻辑，在异常对象之后，怎么处理异常对象
        一般在工作中，会把异常的信息记录到一个日志中
    }
    ...
    </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(异常类名 变量名){
        
    }</span><span style="color: #0000ff;">finally</span><span style="color: #000000;">{
        无论是否出现异常都会执行
    }</span></pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>注意：</strong></p>
<ol>
<li>finally不能单独使用，必须和try一起使用</li>
<li>finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都需要资源释放（IO）</li>
<li>如果finally有return语句，永远返回finally中的结果，避免该情况。</li>

</ol>
<p><strong>注意：</strong></p>
<ul>
<li>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</li>
<li>父类异常时什么样，子类异常就什么样</li>

</ul>
<p><strong>自定义异常类：</strong></p>
<ul>
<li>	Java提供的异常类，不够我们使用，需要自己定义一些异常类</li>

</ul>
<p><strong>格式：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> XXXException <span style="color: #0000ff;">extends</span> Exception |<span style="color: #000000;"> RuntimeException{
    添加一个空参数的构造方法
    添加一个带异常的构造方法
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>例子：</strong><br /><strong>要求：</strong>模拟注册操作，如果用户已经存在，则抛出异常并提示：亲，该用户已经被注册。</p>
<p><strong>分析：</strong></p>
<ol>
<li>使用数组保存已经注册过的用户名（数据库）</li>
<li>使用Scanner获取用户输入的注册的用户名（前端，页面）</li>
<li>定义一个方法，对用户输入的注册的用户名进行判断</li>

</ol>
<ul>
<li>		遍历存储注册过的用户名的数据，获取每一个用户名</li>
<li>		使用获取到的用户名和用户输入的用户名比较</li>

</ul>
<p>		true：</p>
<ul>
<li>			用户已经存在，抛出RegisterException异常，告知用户&rdquo;亲，该用户已经被注册。&ldquo;</li>

</ul>
<p>		false：</p>
<ul>
<li>			继续遍历比较</li>
<li>		如果循环结束了，还没有找到重复的用户名，提示用户"恭喜您，注册成功！"</li>

</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">1.使用数组保存已经注册过的用户名（数据库）</span>
    <span style="color: #0000ff;">static</span> String[] usernames = {"菜鸟","小菜","老鸟"<span style="color: #000000;">};

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main (String[] ages) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> RegisterException{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2. 使用Scanner获取用户输入的注册的用户名（前端，页面）</span>
        Scanner sc = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
        System.out.println(</span>"请输入你要注册的用户名；"<span style="color: #000000;">)
        String username </span>=<span style="color: #000000;"> sc.next();
        checkUsername(username);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">3. 定义一个方法，对用户输入的注册的用户名进行判断</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> checkUsername(String username) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> RegisterException{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历存储注册过的用户名的数据，获取每一个用户名</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;"> (String name:usernames){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">使用获取到的用户名和用户输入的用户名比较</span>
            <span style="color: #0000ff;">if</span><span style="color: #000000;">(name.equals(username)){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">true：用户已经存在，抛出RegisterException异常，告知用户&rdquo;亲，该用户已经被注册。&ldquo;</span>
                <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RegisterException("亲，该用户已经被注册。"<span style="color: #000000;">);
            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果循环结束了，还没有找到重复的用户名，提示用户"恭喜您，注册成功！"</span>
        System.out.println("恭喜您，注册成功！"<span style="color: #000000;">);
    }
}    </span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>HDFS 其他命令---fsck</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/30/11268557.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 30 Jul 2019 02:43:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/30/11268557.html</guid><description><![CDATA[<h2>HDFS 其他命令</h2>
<p>HDFS支持fsck命令用以检查各种不一致。fsck用以报告各种文件问题，如 block丢失或缺少block等。<br /><strong>fack 命令用法如下：</strong></p>
<ul>
<li><strong>	hdfs fsck &lt;path&gt; [-move | -delete | -openforwrite] [-files [-blocks [-locations | -racks]]]</strong></li>
<li><strong>	&lt;path&gt; 检查的起始目录</strong></li>
<li><strong>	-move 将损坏的文件移动到/lost+found 下面</strong></li>
<li><strong>	-delete 删除损坏的文件</strong></li>
<li><strong>	-openforwrite 打印出正在写的文件</strong></li>
<li><strong>	-files 打印出所有被检查的文件</strong></li>
<li><strong>	-blocks 打印出 block 报告</strong></li>
<li><strong>	-locations 打印出每个 block 的位置</strong></li>
<li><strong>	-racks 打印出 datanode 的网络拓扑结构</strong></li>

</ul>
<p>默认情况下，fsck 会忽略正在写的文件，使用-openforwrite 选项可以汇报这种文件。<br />使用 <strong>hdfs fsck /1001/hive.log &ndash;racks</strong> 查看该/1001/hive.log 的拓扑信息</p>]]></description></item><item><title>Linux 常用命令</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/30/11268522.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 30 Jul 2019 02:41:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/30/11268522.html</guid><description><![CDATA[<h2>Linux 常用命令</h2>
<ul>
<li><strong> cd /home 进入 '/ home' 目录'</strong></li>
<li><strong> cd .. 返回上一级目录</strong></li>
<li><strong> cd ../.. 返回上两级目录</strong></li>
<li><strong> cd 进入个人的主目录</strong></li>
<li><strong> cd ~user1 进入个人的主目录</strong></li>
<li><strong> cd - 返回上次所在的目录</strong></li>
<li><strong> pwd 显示工作路径</strong></li>
<li><strong> ls 查看目录中的文件</strong></li>
<li><strong> ls -F 查看目录中的文件</strong></li>
<li><strong> ls -l 显示文件和目录的详细资料</strong></li>
<li><strong> ls -a 显示隐藏文件</strong></li>
<li><strong> ls *[0-9]* 显示包含数字的文件名和目录名</strong></li>
<li><strong> tree 显示文件和目录由根目录开始的树形结构(1)</strong></li>
<li><strong> lstree 显示文件和目录由根目录开始的树形结构(2)</strong></li>
<li><strong> mkdir dir1 创建一个叫做 'dir1' 的目录'</strong></li>
<li><strong> mkdir dir1 dir2 同时创建两个目录</strong></li>
<li><strong> mkdir -p /tmp/dir1/dir2 创建一个目录树</strong></li>
<li><strong> rm -f file1 删除一个叫做 'file1' 的文件'</strong></li>
<li><strong> rmdir dir1 删除一个叫做 'dir1' 的目录'</strong></li>
<li><strong> rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容</strong></li>
<li><strong> rm -rf dir1 dir2 同时删除两个目录及它们的内容</strong></li>
<li><strong> mv dir1 new_dir 重命名/移动 一个目录</strong></li>
<li><strong> cp file1 file2 复制一个文件</strong></li>
<li><strong> cp dir/* . 复制一个目录下的所有文件到当前工作目录</strong></li>
<li><strong> cp -a /tmp/dir1 . 复制一个目录到当前工作目录</strong></li>
<li><strong> cp -a dir1 dir2 复制一个目录</strong></li>
<li><strong> ln -s file1 lnk1 创建一个指向文件或目录的软链接</strong></li>
</ul>]]></description></item><item><title>Linux命令注释—HDFS运维</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/30/11268497.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 30 Jul 2019 02:38:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/30/11268497.html</guid><description><![CDATA[<h2>HDFS运维&mdash;命令注释</h2>
<h3><strong>1 实验背景</strong></h3>
<p>HDFS是大数据其他组件的基础，Hive的数据存储在HDFS中，Mapreduce、Spark 等计算数据也存储在HDFS 中，HBase 的 region 也是存储在HDFS 中。在HDFS shell 客户端我们可以实现多种操作，如上传、下载、删除数据，文件系统管理等。掌握HDFS 的使用对我们更好的理解和掌握大数据大有裨益。</p>
<h3><strong>2 实验目的</strong></h3>
<ol>
<li>掌握 HDFS 常用操作。 </li>
<li>掌握 HDFS 文件系统管理操作。</li>

</ol>
<h3><strong>3 实验步骤</strong></h3>
<ul>
<li>HDFS 常用操作</li>

</ul>
<div class="cnblogs_code">
<pre>[-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;<span style="color: #000000;">]
[</span>-cat [-ignoreCrc] &lt;src&gt;<span style="color: #000000;"> ...]
[</span>-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt;<span style="color: #000000;"> PATH...]
[</span>-chown [-<span style="color: #000000;">R] [OWNER][:[GROUP]] PATH...]
[</span>-copyFromLocal [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;<span style="color: #000000;">]
[</span>-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;<span style="color: #000000;">]
[</span>-count [-q] &lt;path&gt;<span style="color: #000000;"> ...]
[</span>-cp [-f] [-p] &lt;src&gt; ... &lt;dst&gt;<span style="color: #000000;">]
[</span>-df [-h] [&lt;path&gt;<span style="color: #000000;"> ...]]
[</span>-du [-s] [-h] &lt;path&gt;<span style="color: #000000;"> ...]
[</span>-<span style="color: #0000ff;">get</span> [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;<span style="color: #000000;">]
[</span>-getmerge [-nl] &lt;src&gt; &lt;localdst&gt;<span style="color: #000000;">]
[</span>-<span style="color: #000000;">help [cmd ...]]
[</span>-ls [-d] [-h] [-R] [&lt;path&gt;<span style="color: #000000;"> ...]]
[</span>-mkdir [-p] &lt;path&gt;<span style="color: #000000;"> ...]
[</span>-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;<span style="color: #000000;">]
[</span>-moveToLocal &lt;src&gt; &lt;localdst&gt;<span style="color: #000000;">]
[</span>-mv &lt;src&gt; ... &lt;dst&gt;<span style="color: #000000;">]
[</span>-put [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;<span style="color: #000000;">]
[</span>-rm [-f] [-r|-R] [-skipTrash] &lt;src&gt;<span style="color: #000000;"> ...]
[</span>-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt;<span style="color: #000000;"> ...]
[</span>-tail [-f] &lt;file&gt;<span style="color: #000000;">]
[</span>-text [-ignoreCrc] &lt;src&gt;<span style="color: #000000;"> ...]
[</span>-touchz &lt;path&gt; ...]</pre>
</div>
<p>&nbsp;</p>
<p><strong>步骤 1 help 命令</strong></p>
<ul>
<li>功能： 查看命令的帮助文档</li>
<li>hdfs dfs -help</li>
</ul>
<p><strong>步骤 2 ls 命令</strong></p>
<ul>
<li>功能：显示目录信息</li>
<li>hdfs dfs -ls /</li>
</ul>
<p><strong>步骤 3 mkdir 命令</strong></p>
<ul>
<li>功能：在 hdfs 上创建目录</li>
</ul>
<p>在根目录的 user 文件夹下创建 stu01 文件夹，首先查看 user 下的内容，然后创建，再使用 ls命令查看，可以看到出现了 stu01 文件夹：</p>
<ul>
<li>&nbsp;hdfs dfs -mkdir /user/stu01</li>
</ul>
<p><strong>步骤 4 put 命令</strong></p>
<ul>
<li>功能：上传本地文件到 hdfs 指定目录，首先使用 vi 命令在 linux 本地编辑一份数据文件</li>
<li>输入命令 vim stu01.txt</li>
</ul>
<p><strong>步骤 5 cat 命令</strong></p>
<ul>
<li>功能：显示文件内容</li>
<li>输入命令： hdfs dfs -cat /user/stu01/stu01.txt</li>
</ul>
<p><strong>步骤 6 text 命令</strong></p>
<ul>
<li>功能：以字符形式打印一个文件的内容</li>
<li>输入命令：hdfs dfs -text /user/stu01/stu01.txt</li>
</ul>
<p><strong>步骤 7 moveFromLocal 命令</strong></p>
<ul>
<li>功能：从本地剪切粘贴到 hdfs</li>
</ul>
<p>同理，使用 vi 命令在 linux 本地先创建一个数据文件，例如 stu01_2.txt，</p>
<ul>
<li>输入命令：hdfs dfs -moveFromLocal stu01_2.txt /user/stu01/</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>可以看到 stu01_2.txt 文件已上传到 hdfs 文件系统的/user/stu01 目录下，并且使用 ls 命令查看</li>
<li>linux 本地，stu01_2.txt 已不存在，证明是剪切粘贴到 hdfs 文件系统了。如果是 put 命令，linux 本地还存在，只是复制到 hdfs 系统。</li>
</ul>
<p><strong>步骤 8 appendToFile 命令</strong></p>
<ul>
<li>功能：追加一个文件到已经存在的文件末尾</li>
</ul>
<p>首先，使用 vi 命令在 linux 本地编辑一份数据文件：stu01_3.txt，</p>
<ul>
<li>输入命令：hdfs dfs -appendToFile stu01_3.txt /user/stu01/stu01_2.txt</li>
</ul>
<p>把 stu01_3.txt 文件的内容追加到 hdfs 文件系统的 stu01_2.txt 文件里面去。</p>
<p><strong>步骤 9 chmod 命令</strong></p>
<ul>
<li>功能：linux 文件系统中的用法一样，更改文件所属权限</li>
</ul>
<p> 使用 ls 命令可以查看到 hdfs 文件的权限：<br />	使用 chmod 命令修改 stu01 文件夹的权限，</p>
<ul>
<li>	输入命令：hdfs dfs -chmod 755 /user/stu01/</li>

</ul>
<p><strong>步骤 10 chown 命令</strong></p>
<ul>
<li>	功能：linux 文件系统中的用法一样，更改文件所属用户和用户组</li>

</ul>
<p>	首先在 hdfs 根目录下创建文件夹 stu01，使用 ls 命令可以查看属组：<br /><strong>注意：</strong>因为 root 用户无权限操作属组，需要切换到 admin 用户。</p>
<ul>
<li>输入命令：su admin，切换admin 用户：</li>

</ul>
<p>	使用 chown 命令修改 stu01 文件夹的用户及用户组，</p>
<ul>
<li>	输入命令：hdfs dfs -chown -R hive:hive /stu01/</li>

</ul>
<p><strong>步骤 11 cp 命令</strong></p>
<ul>
<li>	功能：从 hdfs 的一个路径拷贝 hdfs 的另一个路径</li>

</ul>
<p>首先在 linux 本地使用 vi 命令编辑一份文件：stu01_4.txt ，然后用 put 命令上传到 hdfs 的根目<br />录下。</p>
<ul>
<li>输入 cp 命令：hdfs dfs -cp /stu01_4.txt /user/stu01/</li>

</ul>
<p><strong>步骤 12 mv 命令</strong></p>
<ul>
<li>	功能：在 hdfs 目录中移动文件</li>

</ul>
<p>	首先在 linux 本地使用 vi 命令编辑一份文件：stu01_5.txt ，然后用 put 命令上传到 hdfs 的根目<br />	录下。</p>
<ul>
<li>	输入 mv 命令：hdfs dfs -mv /stu01_5.txt /user/stu01/</li>

</ul>
<p><strong>注意</strong>：可以看到/user/stu01 文件夹下已经有 stu01_5.txt 文件了，但是该文件在根目录下已经不存在，<br />被移走了。</p>
<p><strong>步骤 13 get 命令</strong></p>
<ul>
<li>	功能：等同于 copyToLocal，就是从 hdfs 下载文件到本地</li>

</ul>
<p>	首先删除 linux 本地的 stu01_5.txt 文件：</p>
<ul>
<li>	执行 copyToLocal 命令：hdfs dfs -copyToLocal /user/stu01/stu01_5.txt .</li>

</ul>
<p>可以看到在 linux 本地已经有 stu01_5.txt 文件了。<br /><strong>注意：</strong>hdfs 命令最后的.，表示当前目录，如果指 定其他目录，就可以指定文件保存的路径。</p>
<p><strong>步骤 14 getmerge 命令</strong></p>
<ul>
<li>	功能：合并下载多个文件</li>

</ul>
<p>	执行 ls 命令，在/user/stu01/目录下有多个文件存在</p>
<ul>
<li>	执行命令：hdfs dfs -getmerge /user/stu01/* ./merge.txt                 */</li>

</ul>
<p>可以看到当前目录下生成了一个 merge.txt 文件，里面的内容就是/user/stu01/下几个文件的合 集。</p>
<p><strong>步骤 15 rm 命令</strong></p>
<ul>
<li>	功能：删除 hdfs 文件或文件夹</li>
<li>	执行命令：hdfs dfs -rm /user/stu01/stu01_5.txt</li>

</ul>
<p>可以看到/user/stu01/目录下已经没有 stu01_5.txt 文件了。</p>
<p><strong>步骤 16 df 命令</strong></p>
<ul>
<li>	功能：统计文件系统的可用空间信息</li>
<li>	执行命令：hdfs dfs -df -h /</li>

</ul>
<p><strong>步骤 17 du 命令</strong></p>
<ul>
<li>	功能：统计文件夹的大小信息</li>
<li>	执行命令：hdfs dfs -du -s -h /user/stu01</li>

</ul>
<p><strong>步骤 18 count 命令</strong></p>
<ul>
<li>	功能：统计一个指定目录下的文件节点数量</li>
<li>	执行命令：hdfs dfs -count -v /user/stu01</li>

</ul>
<h3>4 回收站使用</h3>
<p>日常工作中，有时会误删文件。此时我们可以在 hdfs 的回收站中找到被误删的文件，回收站默认将被删除文件保存 7 天。例如误删了/user/stu01/stu01_5.txt 文件，此时 stu01_5.txt 文件被移动到回收站。</p>
<ul>
<li>	使用命令：hdfs dfs -ls /user/root/.Trash/Current/user/stu01/</li>

</ul>
<p>	可以查看到回收站中的 stu01_5.txt。<br /><strong>备注:</strong> 被删除数据默认<strong>保留 7 天</strong><br /><strong>使用 mv 命令</strong>，将文件移动回/user/stu01/目录文件即可使用。</p>
<p>&nbsp;</p>]]></description></item><item><title>大数据简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11251795.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 28 Jul 2019 08:14:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11251795.html</guid><description><![CDATA[<h1>FusionInsight大数据开发</h1>
<p><strong>FusionInsight HD是一个大数据全栈商用平台，支持各种通用大数据应用场景。</strong></p>
<p><strong>技能需求</strong></p>
<ul>
<li>扎实的编程基础</li>
<li>Java/Scala/python/SQL/shell常见命令</li>
<li>掌握FusionInsight</li>
<li>熟悉业务开发</li>
</ul>
<p><strong>大数据应用开发流程</strong></p>
<ul>
<li>业务分析和方案设计</li>
<li>应用开发</li>
<li>应用调试</li>
<li>应用部署</li>
</ul>
<p><strong>应用开发关键点</strong></p>
<ul>
<li>账号</li>
<li>安全认证</li>
<li>场景约束</li>
</ul>
<p><strong>应用开发指南--调试</strong></p>
<ul>
<li>常规手段</li>
<li>协助资料</li>
<li>保障团队</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><strong>认证是应用开发的关键点，要根据业务需求，申请合适账号，完成安全认证。</strong></li>
<li><strong>华为FusionInsight易集成开发，提供了包括应用开发指南，样例代码和支持团队等各类协助。</strong></li>
</ol>
<p><strong><a href="https://www.cnblogs.com/cainiao-chuanqi/p/11009077.html" target="_blank">更新中......</a></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>HDFS应用开发</h2>
<p><strong>HDFS(Dadoop Distributed File System)</strong></p>
<h3>HDFS概述</h3>
<ul>
<li>高容错性</li>
<li>高吞吐量</li>
<li>大文件存储</li>
</ul>
<h3>HDFS架构包含三部分</h3>
<ol>
<li>Name Node</li>
<li>DataNode</li>
<li>Client</li>
</ol>
<h3>HDFS数据写入流程</h3>
<p>&nbsp;</p>
<h3>HDFS应用开发方式</h3>
<ul>
<li><strong>HDFS Client</strong></li>
</ul>
<p>Java/shell/Web UI</p>
<ul>
<li><strong>Kerbors控制</strong></li>
</ul>
<h3>HDFSJava应用开发</h3>
<p><strong>下载客户端/获取样例工程/生产样例工程/导入eclipse/编码</strong></p>
<h3>Java开发流程</h3>
<ul>
<li>初始化</li>
<li>目录操作</li>
<li>文件读取</li>
<li>文件写入/追加（</li>
</ul>
<ol>
<li>初始化FSDataOutputstream对象</li>
<li>使用FSDataOutputStream对象初始化BufferedOutputStream.</li>
<li>使用BufferedOutputStream.write写入HDFS数据。</li>
<li>使用BufferedOutputStream.flush和FSDataOutputstream.hflush()将数据刷新到HDFS。</li>
<li>关闭数据流。)</li>
</ol>
<h3>应用开发规范</h3>
<p><strong>规范1：Java开发时，申请资源需要及时释放。</strong><br /><strong>规范2：HDFS不适用于存储大量小文件。</strong><br /><strong>规范3：HDFS中数据备份3份即可。</strong><br /><strong>规范4：如果有多线程进行login的操作，当第一次登陆成功后，所有线程再次登陆时应该使用relogin的方式。</strong></p>
<p>&nbsp;</p>
<p><a href="https://www.cnblogs.com/cainiao-chuanqi/p/11009077.html" target="_blank">更新中......</a></p>
<h2 style="text-align: left;">&nbsp;</h2>
<h2>HBase应用开发</h2>
<h3>HBase的定义</h3>
<p><strong>HBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统。</strong></p>
<ul>
<li>适合于存储大表数据，可以达到实时级别。</li>
<li>利用Hadoop HDFS 作为其文件存储系统，提供实时的读写的数据库系统。</li>
<li>利用ZooKeeper作为协同服务。</li>




</ul>
<h3>HBase架构</h3>
<h3>HBase的适用场景</h3>
<ul>
<li>海量数据</li>
<li>高吞吐量</li>
<li>需要在海量数据中实现高效的随机读取</li>
<li>需要很好的性能伸缩能力</li>
<li>能够同时处理结构化和非结构化的数据</li>
<li>不需要完全拥有传统关系型数据库所具备的ACID特性</li>




</ul>
<h3>HBase应用开发流程</h3>
<ul>
<li>制定业务目标</li>
<li>准备开发环境</li>
<li>下载并导入样例工程</li>
<li>
<h3><strong>设计HBase表</strong></h3>




</li>




</ul>
<p><strong>设计原则：</strong></p>
<p><strong>查询数据唯一</strong></p>
<p><strong>数据均匀分布</strong></p>
<p><strong>查询性能优化</strong></p>
<p><strong>其他因素（region的提前划分，冷热Family的使用</strong>)</p>
<ul>
<li>根据场景开发工程</li>
<li>编译并运行程序</li>
<li>查看结果与调试程序</li>




</ul>
<h3>HBase表设计-总体原则</h3>
<p>设计目标：提高吞吐量<br />设计原则：预分region，是region分布均匀，提高并发<br />实现方法：Rowkey范围和分布已知，建议预分region</p>
<p>设计目标：提高写入性能<br />设计原则：避免过多的热点region<br />设计方法：根据应用场景，可以考虑将时间因素引入Rowkey</p>
<p>设计目标：提高查询性能<br />设计原则：数据连续存储，频繁访问的数据存储一个地方，数据连续存储，离散度，信息冗余。<br />实现方法：同时读取的数据存放在同一行、cell，使用二级索引</p>
<h3>HBase表设计-设计内容</h3>
<p>设计内容通过不同维度，可分为：<br /><strong>Table设计（表粒度的设计）</strong></p>
<ul>
<li>建表方法</li>
<li>预分region</li>
<li>Family属性</li>
<li>系统并发能力、数据清洗能力</li>





</ul>
<h3><strong>RowKey设计</strong></h3>
<ul>
<li>原则：需要同时访问的数据，RowKey尽量连续</li>
<li>访问效率：分散写，连续读</li>
<li>属性内容：常用的查询场景属性</li>
<li>属性值顺序：枚举，访问权重</li>
<li>时间属性：循环Key+TTL，周期建表</li>
<li>二级索引</li>
<li>折中法</li>
<li>冗余法</li>





</ul>
<h3><strong>Family设计</strong></h3>
<p>可枚举数量少扩展性弱的属性作为Family</p>
<h3><strong>Qualifier设计</strong></h3>
<p>&nbsp;不可枚举、数量多且扩展性强的属性作为Qualifier</p>
<p>原则：同时访问的数据存放到同一个Cell，列名尽量简短</p>
<h2>HBase常用接口</h2>
<p>create（）</p>
<p>put（）</p>
<p>get（）</p>
<p>getScanner（Scan scan）</p>
<p>、、、</p>
<h3>创建Configuration实例以及Kerberos安全认证</h3>
<p>HBaseConfiguration方法</p>
<h3><strong>创建表</strong></h3>
<p>create Table方法</p>
<h3><strong>写入数据</strong></h3>
<p>put方法</p>
<h3><strong>读取一行数据</strong></h3>
<p>get方法</p>
<h3><strong>读取多行数据</strong></h3>
<p>scan方法</p>
<p><a href="https://www.cnblogs.com/cainiao-chuanqi/p/11009077.html" target="_blank">&nbsp;更新中.....</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>MapReduce&nbsp; 应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>&nbsp;MapReduce的基本定义及过程</li>
<li>搭建开发环境</li>
<li>代码实例及运行程序</li>
<li>MapReduce开发接口介绍</li>






</ol>
<p>&nbsp;</p>
<p><strong>1. MapReduce的基本定义及过程</strong><br />MapReduce是面向大数据并行处理的计算模型、框架和平台，其资源调度由Yarn完成，任务资源隐含了以下三层含义：</p>
<ul>
<li>	1）MapReduce是 一个基于集群的高性能并行计算平台（cluster Infrastructure）。</li>
<li>	2）MapReduce是 一个并行计算与运行软件框架（SoftWare Framework）</li>
<li>	3）MapReduce是 一个并行程序设计模型与方法（Programming Model &amp; Methodology）</li>











</ul>
<p><strong>MapReduce特点：</strong></p>
<ul>
<li>	易于编程</li>
<li>	良好的扩展性</li>
<li>	高容错性</li>











</ul>
<p><strong>MapReduce的过程：</strong></p>
<ol>
<li>把输入的数据（Input） 拆分为多个键值对（key-value对）</li>
<li>每一个键值对分别调用Map进行并行处理</li>
<li>每一个Map会产生多个新的键值对</li>
<li>对Map阶段产生的数据进行排序、组合</li>
<li>以键值对的形式输出最终结果</li>











</ol>
<p><br /><strong>2. 搭建开发环境</strong></p>
<ol>
<li>确认Yarn组件和MapReduce组件已经安装。</li>
<li>客户端安装Eclipse和JDK程序。</li>
<li>客户端机器的时间与FusInsight集群时间要保持一致，时间差要小于5分钟。</li>
<li>在Yarn服务页面下载MapReduce客户端程序到客户端机器中。</li>











</ol>
<ul>
<li>1.下载客户端</li>
<li>2.获取样例工程</li>
<li>3.生成样例工程</li>
<li>4.导入eclipse</li>
<li>5.编码</li>











</ul>
<p><br /><strong>开发相关类的总结</strong><br /><strong>1) InputFormat类</strong></p>
<ul>
<li>	将输入的数据分割成split，并将split拆分为&lt;key,value&gt;作为map的输入。</li>











</ul>
<p><strong>2） Mapper类</strong></p>
<ul>
<li>	实现map函数，根据输入的&lt;key,value&gt;对产生中间结果。</li>











</ul>
<p><strong>3）Combiner类</strong></p>
<ul>
<li>实现combiner函数，合并中间结果中具有相同key值的键值对。</li>











</ul>
<p><strong>4） Partitioner类</strong><br />实现getPartitioner函数，在Shuffle过程按照key值将中间数据分成R份，每一份由一个Reduce负责</p>
<p>5） Reduce类</p>
<ul>
<li>实现reduce函数，将中间结果合并，得到最终的结果。</li>











</ul>
<p><strong>6）OutputFormat类</strong></p>
<ul>
<li>该类负责输出最终的结果，MapReduce使用OutputFormat类将数据输出存入到文件中，每个Reduce将它的输出直接写到自己的文件中。</li>











</ul>
<p><br /><strong>调式代码</strong></p>
<ul>
<li>MapReduce开发调式采用的原理是Java的远程调式机制</li>











</ul>
<p>&nbsp;</p>
<h2><br />Hive应用开发</h2>
<ol>
<li>了解Hive的基本架构原理</li>
<li>&nbsp;掌握JDBC客户端开发流程</li>
<li>了解ODBC客户端的开发流程</li>
<li>了解python客户端的开发流程</li>
<li>了解Hcatalog/webHcat开发接口</li>
<li>&nbsp;掌握Hive开发规则</li>











</ol>
<p><strong>1. 了解Hive的基本架构原理</strong><br /><strong>守护进程：</strong></p>
<ol>
<li>HiveServer（Thrift/Compiler）</li>
<li>webHcat</li>
<li>MetaStore</li>











</ol>
<p><strong>Hive的应用场景</strong></p>
<ol>
<li>数据挖掘</li>
<li>非实时分析</li>
<li>数据汇总</li>
<li>作为数据仓库</li>











</ol>
<p><strong>2. 掌握JDBC客户端开发流程</strong><br /><strong>JDBC开发-参数初始化</strong></p>
<ol>
<li>设置ZooKeeper地址</li>
<li>krb5文件路径</li>
<li>设置JAAS配置</li>
<li>配置ZooKeeper Principal</li>
<li>执行登陆</li>











</ol>
<p><strong>JDBC开发-拼接URL</strong></p>
<ol>
<li>JDBC前缀设置</li>
<li>服务发现模式</li>
<li>安全配置：qop.auth.principal</li>
<li>非安全配置</li>











</ol>
<p><strong>JDBC开发-执行SQL</strong></p>
<ol>
<li>加载驱动类</li>
<li>建立连接</li>
<li>执行SQL</li>
<li>关闭连接</li>











</ol>
<p><strong>JDBC开发-SQL实现</strong></p>
<ol>
<li>创建preparedStatement</li>
<li>执行statement</li>
<li>关闭statement</li>











</ol>
<p><strong>规则建议：</strong><br />	<strong>开发调式：</strong>在开发程序时，可通过使用Hive的客户端Beeline先进行调试，检验语句与结果正确性，再部署基于JDBC等的应用程序。<br />	获取数据库连接：Hive的数据库URL再拼接时已经经过安全认证，所以Hive数据库的用户名和密码为null或空 。</p>
<p><br />	<strong>JDBC超时限制:</strong>Hive提供的JDBC实现的超时限制，默认是5分钟。</p>
<p><br />	<strong>执行HQL：</strong>再JAVA　JDBC应用开发中，拼装HQL语句，注意HQL语句不能以&ldquo;;&ldquo;结尾。</p>
<p><br /><strong>	HQL语法规则之判空：</strong>判断字段为空使用：&rdquo;is null&ldquo;，判断不为空，即有值，使用："is not null"</p>
<p><br />	<strong>UDF的管理：</strong>建议由管理员创建永久UDF，避免每次使用时都去add jar，和重新定义UDF。</p>
<p><br />	<strong>UDF的注解：</strong>Hive的UDF会有一些默认属性。@UDFType(deterministic = false)</p>
<p><br />	<strong>使用分区表：</strong>当数据量较大时，且经常需要按天统计时，建议使用分区表，按天存放数据。</p>
<p><br />	<strong>动态分区表</strong>：为了避免插入动态分区数据过程中，产生过多的小文件，在执行插入时，在分区字段上加distribut by。</p>
<p><br />	<strong>文件格式选择：</strong>Hive支持多种存储格式，比如TextFile,RCFile,ORC,Sequence,Parquet.</p>
<h2>&nbsp;</h2>
<h2>sorl应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Solr应用开发适用场景</li>
<li>熟悉Solr应用开发流程</li>
<li>熟悉并使用Solr常用API</li>
<li>理解Collection设计基本原则</li>
<li>应用开发实践</li>











</ol>
<p><strong>Solr简介</strong></p>
<ol>
<li>Solr是一个高性能，基于Lucene的全文检索服务，也可以作为NoSQL数据库使用。</li>
<li>Solr对Lucene进行了扩展，提供了比Lucene更为丰富的查询语句，同时实现了可配置、可扩展，并对查询性能进行了优化，还提供了一个完善的功能管理界面。</li>
<li>SolrCloud是从Solr 4.0 版本开始发出的具有开创意义的分布式索引和索引方案，基于Sorl和Zookeeper进行开发的。</li>











</ol>
<p><strong>Solr概念体系-总述</strong><br /><strong>常见术语：</strong></p>
<ul>
<li>Config Set:Solr Core提供一组配置文件 ,</li>
<li>Core:即Solr Core ，</li>
<li>Shard：Collection的逻辑分片</li>
<li>Replice：Shard下的实际存储索引的一个副本，与Core对应</li>
<li>Leader：赢得选举的Shard Peplicas</li>
<li>Zookeeper:它在Solr Core是必须的，提供分布式锁、处理Leader选举、管理配置等功能</li>











</ul>
<p><strong>Solr的常用应用场景</strong></p>
<ol>
<li>待检索数据类型复杂</li>
<li>检索条件多样化（如涉及字段太多），常规查询无法满足</li>
<li>读取远多于写入数据</li>











</ol>
<p><br /><strong>Solr应用开发流程-制定业务目标</strong><br /><strong>业务数据规模及数据模型</strong></p>
<ul>
<li>涉及Collection的Shard划分及Schema的定义</li>











</ul>
<p><strong>实时索引、查询性能要求</strong></p>
<ul>
<li>涉及Collection的Shard划分、索引存储位置</li>











</ul>
<p><strong>查询场景</strong></p>
<ul>
<li>涉及Collection的Schema定义</li>











</ul>
<p><br /><strong>Solr应用开发流程-初始化及安全认证</strong></p>
<ol>
<li>初始化并获取配置</li>
<li>安全认证</li>
<li>获取CloudSolrClient</li>
<li>调用Solr APL</li>











</ol>
<p><strong>Solr应用开发流程-设计Collection</strong></p>
<ol>
<li>根据业务数据的关系设计schema.xml</li>
<li>根据写入和查询场景设计uniqueKey字段</li>
<li>根据写入和查询性能要求设计solrconfig.xml</li>
<li>根据业务数据规模和Solr集群规模确定Shard数目</li>
<li>根据可靠性能要求设定Shard副本数</li>











</ol>
<p><strong>Collection设计-索引存储位置</strong><br /><strong>索引存储在HDFS</strong></p>
<p><strong>缺点:</strong></p>
<ol>
<li>与存储在本地磁盘相比，性能下降30%-50%</li>
<li>实时单节点写入速度&lt;=2MB/s </li>
<li>数据膨胀略高于存储在本地</li>











</ol>
<p><strong>优点：</strong></p>
<ol>
<li>	Sorl设置Replica即可，利用HDFS副本机制保障数据可靠性</li>
<li>	数据管理由HDFS完成，包括各节点数据balance、方便迁移</li>











</ol>
<p><strong>配置集Schema设计-Field</strong><br /><strong>dynamicField</strong></p>
<ul>
<li>	动态的字段设置，用于后期自定义字段，&rdquo;*&ldquo;号通配符。</li>











</ul>
<p><strong>copyField</strong></p>
<ul>
<li>	将多个字段集中到一个字段</li>











</ul>
<h2>&nbsp;</h2>
<h2><br />Kafka应用开发</h2>
<ol>
<li>了解Kafka应用开发适用场景</li>
<li>熟悉Kafka应用开发流程</li>
<li>熟悉并使用Kafka常用API</li>
<li>进行Kafka应用开发</li>











</ol>
<p><strong>Kafka的定义</strong><br /><strong>Kafka是一个高吞吐、分布式、基于发布订阅的消息系统</strong><br />Kafka有如下几个特点：</p>
<ol>
<li>高吞吐量</li>
<li>消息持久化到磁盘</li>
<li>分布式系统易扩展</li>
<li>容错性好 </li>











</ol>
<p><strong>Kafka的适用场景</strong></p>
<ol>
<li>适用于离线和在线的消息消费</li>
<li>已对接组件</li>
<li>	Streaming、Spark、Flume</li>











</ol>
<p><strong>使用Kafka的好处</strong></p>
<ul>
<li>解耦--使得消息生产、消费系统能够独立变更</li>
<li>可靠--有效解决单点故障引发系统不可用问题</li>
<li>易扩展--生产、消费系统扩展简单</li>
<li>可恢复--消息缓存下来，支持故障从故障点读取</li>
<li>异步通信--生产系统无需关心消费系统的消费时间</li>











</ul>
<p><strong>配置及开发准备--配置keytab文件到样例工程</strong></p>
<ol>
<li>配置Keytab到工程</li>
<li>安全认证</li>
<li>Topic订阅</li>
<li>消费获取</li>
<li>消费处理</li>











</ol>
<p><br /><strong>Kafka常用接口</strong></p>
<ul>
<li>Kafka集群安全访问端口默认为21007，非安全访问端口默认为21005</li>











</ul>
<p><strong>Kafka Producer接口</strong></p>
<ol>
<li>&nbsp;向管理员申请目标Topic的生产者权限</li>
<li>&nbsp;根据业务需求，配置发送相关配置参数</li>
<li>&nbsp;调用新Producer API接口发送数据</li>











</ol>
<p><strong>Kafka Consumer接口</strong></p>
<ol>
<li>向管理员申请目标Topic的消费者权限</li>
<li>根据业务需求，配置消费者相关配置参数</li>
<li>调用新Consumer API接口进行消息消费</li>











</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Spark应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Spark基本原理</li>
<li>搭建Spark开发环境</li>
<li>开发Spark应用程序</li>
<li>调试运行Spark应用程序</li>











</ol>
<p><br /><strong>YARN资源调度，可以和Hadoop集群无缝对接</strong></p>
<p><strong>Spark适用场景</strong><br />大多数现有集群计算框架如MapReduce等基于从稳定存储（文件系统）到稳定存储的非循环数据流，数据重用都是基于磁盘的，执行效率比较低。<br />与传统的MapReduce任务频繁读写磁盘数据相比，基于内存计算的Spark则更适合应用在迭代计算，交互式分析等场景。</p>
<p><br /><strong>Spark应用运行流程--关键角色</strong></p>
<ul>
<li>	Client：需求提出方，负责提交需求（应用）。</li>
<li>	Driver：负责应用的业务逻辑和运行规划（DAG）。</li>
<li>	ApplicationMaster：负责应用的资源管理，根据应用的需求，向资源管理部门（ResourceManager）申请资源。</li>
<li>	ResourceManager：资源管理部门，负责整个集群的资源统一调度和分配</li>
<li>	Executor：负责实际计算工作，一个应用会分拆给多个Executor来进行计算。</li>











</ul>
<p><strong>Spark核心概念--RDD</strong><br />RDD（Resilient Distributed Datasets)即弹性分布式数据集，指的是一个只读的，可分区的分布式数据集。这个数据集的全部或部分可以缓存在内存中，在多次计算间重用。<br /><strong>RDD的生成</strong></p>
<ol>
<li>从Hadoop文件系统（或与Hadoop兼容的其它存储系统）输入创建（如HDFS）</li>
<li>从集群创建（如sc.Parallelize）。</li>
<li>从夫RDD转换得到新的RDD。</li>











</ol>
<p><strong>RDD的存储和分区</strong></p>
<ol>
<li>用户可以选择不同的存储级别存储RDD以便重用（11种）</li>
<li>当前RDD默认存储于内存，但当内存不足时，RDD会溢出到磁盘中。</li>
<li>RDD在需要进行分区时会根据每条记录Key进行分区，以此保证两个数据集能高效进行Join操作。</li>











</ol>
<p><strong>	RDD的优点</strong></p>
<ol>
<li>RDD是只读的，可提供更高的容错能力</li>
<li>RDD的不可变性，可以实现Hadoop MapReduce的推测式执行</li>
<li>RDD的数据分区特性可以通过数据的本地性来提高性能。</li>
<li>RDD都是可序列化的，在内存不足时可自动降级为磁盘存储。</li>











</ol>
<p><strong>RDD的特点</strong></p>
<ol>
<li>在集群节点上时不可变的，是已分区的集合对象。</li>
<li>失败后自动重连</li>
<li>可以控制存储级别（内存、磁盘等）来进行重用。</li>
<li>必须是可序列化的</li>
<li>是静态类型。</li>











</ol>
<p><strong>RDD的创建</strong><br />	Spark所有操作都围绕弹性分布式数据集（RDD）进行，这是一个有容错机制并可以被并行操作的元素集合，具有只读，分区，容错，高效，无需物化，可以缓存，RDD依赖等特征。<br /><strong>目前有两种类型的基础RDD：</strong></p>
<ol>
<li>并行集合：接受一个已经存在的Scala集合，然后进行并行计算</li>
<li>Hadoop数据集：在一个文件的每条记录上运行函数。</li>











</ol>
<p><strong>RDD的创建--并行集合	</strong>	<br />并行集合是通过调用SparkContext的parallelize方法，在一个已经存在的Scala集合（一个Seq对象）上创建的。<br />集合的对象将会被拷贝，创建出一个可以被并行操作的分布式数据集。</p>
<p><strong>RDD依赖：宽依赖和窄依赖</strong><br /><strong>RDD父子依赖关系</strong></p>
<ul>
<li>窄依赖：（Narrow）指父RDD的每一个分区最多被一个子RDD的分区所用。</li>
<li>宽依赖：（Wide）指子RDD的分区依赖于父RDD的所有分区，是Stage划分的依据。</li>











</ul>
<p>&nbsp;</p>
<ul>
<li><strong>RDD常用Transformation算子</strong></li>
<li><strong>RDD常用Action算子</strong></li>











</ul>
<p><strong>Spark任务参数配置</strong></p>
<ul>
<li>Spark优先级是：<strong>配置文件&lt;动态参数&lt;代码配置</strong></li>











</ul>
<p><strong>相同的数据，只创建一个RDD</strong></p>
<p><strong>算法调优--RDD缓存</strong></p>
<ul>
<li>Spark可以使用persist和cache方法将任意RDD缓存到内存、磁盘文件系统中。</li>











</ul>
<p><strong>算法调优--避免使用Shuffle</strong></p>
<ul>
<li>Shuffle过程会有整个RDD数据的写和读的操作，成本非常高。</li>











</ul>
<p><strong>算法调优--使用广播变量</strong><br /><strong>外部变量：</strong></p>
<ul>
<li>	每个task都有一个变量副本。</li>











</ul>
<p><strong>广播变量：</strong></p>
<ul>
<li>	每个Executor保留一份。</li>











</ul>
<p><strong>编写代码</strong></p>
<ol>
<li>登陆</li>
<li>创建连接</li>
<li>执行SQL </li>
<li>获取结果</li>











</ol>
<p><strong>DataFrame介绍</strong><br /><strong>DataFrame：</strong>已RDD为基础，带有Schema信息，类似传统数据库的二维表。</p>
<p><br /><strong>编写代码</strong></p>
<ol>
<li>登陆</li>
<li>注册Table</li>
<li>执行SQL </li>
<li>过滤</li>











</ol>
<h2>&nbsp;</h2>
<h2><br />SparkStreaming概述</h2>
<p>SparkStreaming是Spark核心API的一个扩展，它对实时流式数据的处理具有可扩展性、高吞吐量、可容错性等特点。<br /><br /><strong>SparkStreaming原理</strong></p>
<ol>
<li>SparkStreaming接收实时的输入数据流，然后将这些数据切分为批数据供Spark引擎处理，Spark引擎将数据生成最终的结果数据。</li>
<li>使用DStream从Kafka和HDFS等源获取连接的数据流。DStream是一系列连续的RDD组成。</li>











</ol>
<p><strong>SparkStreaming数据源</strong></p>
<ol>
<li>基本源：HDFS等文件系统、Socket连接等</li>
<li>高级源：Kafka等</li>
<li>自定义源： 需要实现用户自定义receiver</li>











</ol>
<p><strong>可靠性（二次开发）</strong></p>
<ol>
<li>Reliable Receiver</li>
<li>设置CheckPoint</li>
<li>确保Driver可以自动启动</li>
<li>使用Write Ahead Log 功能</li>











</ol>
<p><strong>SparkStreaming代码流程</strong><br /><strong>常见业务代码逻辑</strong></p>
<ol>
<li>创建StreamingContext</li>
<li>定义输入源</li>
<li>准备应用计算逻辑</li>
<li>使用streamingContext.start()方法接受和处理数据。</li>
<li>使用streamingContext.stop()方法停止流计算。</li>











</ol>
<p><strong>窗口操作</strong><br />SparkStreaming支持窗口计算，允许用户在一个滑动窗口数据上应用transformation算子。<br />窗口在源DStream上滑动，合并和操作落入窗口RDDs，产生窗口化的DStream的RDDs。</p>
<p><strong>Checkpoint</strong><br />SparkStreaming可以checkpoint足够的信息到容错存储系统中，以使系统崩溃后从故障中恢复。</p>
<ol>
<li>Metadata checkpoint：保存流计算的定义信息到HDFS中</li>
<li>Data checkpoint：保存生成的RDD到HDFS中。</li>











</ol>
<p><strong>SparkStreaming性能调优</strong></p>
<ul>
<li>设置合理的批处理时间（batch Duration）</li>
<li>设置合理数据接收并行度</li>











</ul>
<ol>
<li>设置多个Receiver接受数据</li>
<li>设置合理的Receiver阻塞时间</li>











</ol>
<ul>
<li>设置合理数据处理并行度</li>
<li>使用Kryo系列化</li>
<li>内存调优</li>











</ul>
<ol>
<li>设置持久化级别减少GC开销</li>
<li>使用并发的标记-清理GC算法减少GC暂停时间</li>











</ol>
<p><br /><br /></p>
<p>&nbsp;</p>
<h2><br />Redis应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Redis应用场景</li>
<li>掌握Redis二次开发环境搭建</li>
<li>掌握Redis业务开发</li>











</ol>
<p><strong>Redis简介</strong></p>
<ul>
<li>	Redis是一个基于网络的，高性能key-value内存数据库</li>
<li>	Redis根memcached类似，不过数据可持久化，而且支持的数据类型很丰富。支持在服务端计算集合的并、交和补集等，还支持多种排序功能。</li>











</ul>
<p><strong>Redis使用场景有如下几个特点：</strong></p>
<ol>
<li>高性能</li>
<li>低延迟</li>
<li>丰富数据结构存取</li>
<li>支持持久化</li>











</ol>
<p><strong>Redis应用场景介绍</strong><br /><strong>Redis提供了灵活多变的数据结构和数据操作</strong>，主要应用于如下场景：</p>
<ol>
<li>取最新N个数据的操作，比如典型的取某网站的最新文章。</li>
<li>排行榜应用，取TOP N操作。</li>
<li>需要精准设定过期时间的应用。</li>
<li>计数器应用，比如记录用户访问网站的次数。</li>
<li>构建队列系统</li>
<li>缓存，如缓存关系数据库中的频繁访问的表数据。</li>











</ol>
<p><strong>架构回顾</strong></p>
<ol>
<li>无中心自组织的结构，节点之间使用Gossip协议来交换节点状态信息。</li>
<li>个节点维护Key-&gt;Server的映射关系。</li>
<li>Client可以向任意节点发起请求，节点不会转发请求，只是重定向Client</li>
<li>如果在Client第一次请求之间，Cluster拓扑发生改变，则第二次重定向请求将被再次重定向，直到找到正确的Server为止。</li>











</ol>
<p><strong>Redis应用开发</strong><br /><strong>设计Redis数据结构</strong></p>
<ol>
<li>取最新N个数据的操作：list</li>
<li>排行榜应用，取TOP N操作。以某个条件为权重，比如按顶的次数排行：sorted set。</li>
<li>利INCR，DECR命令来构建计数器系统。、</li>
<li>Uniq操作，获取某段时间所有数据排重值：set。</li>
<li>使用list可以构建队列系统</li>











</ol>
<p><strong>Redis应用开发</strong><br />根据场景开发工程</p>
<ol>
<li>梳理业务场景流</li>
<li>设计各模块接口</li>
<li>如果使用的是安全集群，需要进行安全认证</li>
<li>熟悉Redis提供的相应API</li>
<li>调用业务需要的API实现各功能</li>











</ol>
<p><strong>数据结构设计</strong></p>
<ul>
<li>	计算过程中使用的用户信息使用hash结构存取，KEY设计为userinfo-&lt;user id&gt;，</li>
<li>	field为用户的属性。</li>











</ul>
<p><strong>数据读写原则</strong></p>
<ul>
<li>	MR任务每天定时将用户信息从后端存储源（HBase）批量导入Redis中。</li>
<li>	业务系统获取数据时，先从Redis中获取，获取不到再取后端HBase获取即实时计算，并同步写入到Redis。</li>











</ul>
<p><strong>样例说明-String类型操作</strong></p>
<ol>
<li>set：将字符串值value关联到key</li>
<li>get：返回key所关联的字符串值，</li>
<li>setex：将字符串值value关联到key，并设置key的生存时间</li>
<li>append：将value追加到key原值的末尾，类似Java String类型的&ldquo;+&rdquo;操作。</li>











</ol>
<p><strong>样例说明-List类型操作</strong></p>
<ol>
<li>Ipush/rpush：往列表头/尾添加一个元素。</li>
<li>Irange：返回列表中start至end之间的元素</li>
<li>llen：返回列表的长度</li>
<li>lpop/rpop：从列表头/尾获取一个元素，并将其中列表中删除。</li>











</ol>
<p><strong>样例说明-Hash类型操作</strong></p>
<ul>
<li>hset</li>
<li>hget</li>
<li>hgettall</li>
<li>hmset</li>
<li>hincrby</li>
<li>hkeys</li>
<li>hvals</li>
<li>hmget</li>
<li>hexists</li>
<li>hdel</li>











</ul>
<h2><br />Streaming应用开发</h2>
<ol>
<li>掌握Streaming基本业务开发流</li>
<li>熟悉Streaming常用API接口使用</li>
<li>掌握Streaming业务设计基本原则</li>
<li>了解Streaming应用开发环境</li>
<li>了解CQL开发流及使用</li>






</ol>
<p><strong>Streaming的定义</strong></p>
<p>	Streaming基于开源Storm，是一个分布式、实时计算框架。Streaming在开源Storm的基础上增加了持续查询语言CQL、增强了安全性和可靠性。</p>
<ul>
<li>事件驱动</li>
<li>连续查询</li>
<li>数据不存储、先计算</li>
<li>实时响应，低延迟</li>






</ul>
<p><strong>CQL（Continuous Query Language），持续查询语言，是一种用于实时数据流上的查询语言。</strong><br />	它是一种<strong>SQL-like的语言，目前主要适配Storm。</strong><br />	相对于SQL，CQL中增加了（时序）窗口的概念，将待处理的数据保存在内存中，进行快速的内存计算，CQL的输出结果为数据流在某一时刻的计算结果。<br /><br /><strong>Streaming的适用场景</strong><br />Streaming主要应用于以下几种对<strong>响应时延</strong>有严重要求的场景：</p>
<ol>
<li>实时分析：如实时日志处理，交通流分析等</li>
<li>实时统计：如网站的实时访问统计、排序等</li>
<li>实时推荐：如实时广告定位、事件营销等</li>






</ol>
<p><strong>提交拓扑</strong><br />当前Streaming支持三种方式提交拓扑</p>
<ol>
<li>Linux命令行提交-CMD模式</li>
<li>Eclipse远程提交-Remote模式</li>
<li>本地模式提交-Local模式</li>






</ol>
<p><strong>Spout设计</strong></p>
<ol>
<li>数据接受</li>
<li>数据反序列化</li>
<li>数据拆分</li>
<li>数据筛选</li>
<li>数据缓存</li>
<li>数据发送</li>






</ol>
<p><strong>counting Bolt设计</strong><br /><strong>功能：</strong></p>
<ol>
<li>窗口定义</li>
<li>刷新窗口</li>
<li>发送数据</li>






</ol>
<p><strong>Storm提供接口</strong><br />1 REST接口</p>
<ul>
<li>	REST(Representational State Tansfer)表述性状态转移接口。</li>






</ul>
<p>2 Thrift接口</p>
<ul>
<li>	由Numbus提供。Thrift是一个基于静态代码生成的跨语言的RPC协议栈实现。</li>






</ul>
<p><strong>Spout接口</strong></p>
<ol>
<li>Spout的Ack开关</li>






</ol>
<p><strong>Bolt接口</strong></p>
<ol>
<li>Bolt的Ack开关</li>






</ol>
<ul>
<li><strong>创建输入流</strong></li>
<li><strong>Join</strong></li>
<li><strong>窗口</strong></li>
<li><strong>Split</strong></li>






</ul>
<p>&nbsp;</p>
<h2>Flume应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Flume应用开发适用场景</li>
<li>掌握Flume应用开发</li>






</ol>
<p><strong>Flume应用场景</strong><br />Flume的核心是把数据从数据源收集过来，在送到目的地。为了保证输送一定成功，发送到目的地之前，会先缓存数据，待数据真正的到达目的地后，删除自己缓存的数据。<br />Flume采用流式方法采集和传输数据，程序配置好后，不需要外部条件触发下，一直监控数据源，源源不断地采集、传送数据到目的地。</p>
<p><strong>主要应用于一下几种场景：</strong></p>
<ol>
<li>将分布式节点上大量数据实时采集、汇总和转移</li>
<li>将集群内、外地本地文件、实时数据流采集到FusionInsight集群内的HDFS、HBase,Kafka,Solr中。</li>
<li>将Avro、System,http,Thrift,JMS、Log4j协议发送过来地数据采集到FusionInsight集群内</li>






</ol>
<p><strong>Flume基本概念</strong></p>
<ol>
<li>Source：数据源，即是产生日志信息地源头，Flume会将原始数据建模抽象成自己处理地数据对象：event</li>
<li>Channel：通道，主要作用是临时缓存Source发过来地数据</li>
<li>Sink：主要是从channel中取出数据并将数据放到不同地目的地</li>
<li>event：一个数据单元，带有一个可选地消息头，Flume传输地数据地基本单位是event，如果是文本文件，通常是一行记录。event从Source，流向Channel，再到Sink,Sink将数据写入目的地</li>






</ol>
<p><strong>方案设计：</strong><br />1）首先确定数据源：<strong>集群外</strong><br />2）数据最终流向：<strong>KafKa(集群内)</strong></p>
<p>&nbsp;</p>
<h2>Oozie应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Oozie应用开发适用场景</li>
<li>掌握Oozie应用开发</li>
<li>熟悉并使用Oozie常用API</li>






</ol>
<p><strong>Oozie简介</strong></p>
<ol>
<li>Oozie是一个Hadoop作业的工作流调度管理系统</li>
<li>Oozie工作流（workflow）是放置在控制依赖DAG（有向无环图）中的一组动作(Action)集合，控制依赖可确保后续操作在见面的操作已经成功完成后才会启动。</li>
<li>Oozie的协调作业（Coordinator）是通过时间(频率)和有效数据来触发当前的Oozie工作流。</li>
<li>Oozie支持多种Hadoop作业（包括：HDFS，Map Reduce、Hive、Streaming MP、Loader、Spark、Distcp)以及系统类作业（Java和shell）</li>






</ol>
<p><strong>Oozie应用场景</strong><br />Oozie是一个工作流调度引擎，对各种类型的Hadoop作业进行编排与调度。</p>
<ol>
<li>编排与管理逻辑复杂的多种类型的Hadoop</li>
<li>基于时间（频率）触发工作流</li>
<li>基于数据有效性触发工作流</li>
<li>实时监控与管理集群的工作流，快速定位问题</li>






</ol>
<p>&nbsp;</p>
<h2>应用开发</h2>]]></description></item><item><title>FusionInsight大数据开发---Oozie应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11259348.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 28 Jul 2019 08:04:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11259348.html</guid><description><![CDATA[<h2>Oozie应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Oozie应用开发适用场景</li>
<li>掌握Oozie应用开发</li>
<li>熟悉并使用Oozie常用API</li>
</ol>
<p><strong>Oozie简介</strong></p>
<ol>
<li>Oozie是一个Hadoop作业的工作流调度管理系统</li>
<li>Oozie工作流（workflow）是放置在控制依赖DAG（有向无环图）中的一组动作(Action)集合，控制依赖可确保后续操作在见面的操作已经成功完成后才会启动。</li>
<li>Oozie的协调作业（Coordinator）是通过时间(频率)和有效数据来触发当前的Oozie工作流。</li>
<li>Oozie支持多种Hadoop作业（包括：HDFS，Map Reduce、Hive、Streaming MP、Loader、Spark、Distcp)以及系统类作业（Java和shell）</li>
</ol>
<p><strong>Oozie应用场景</strong><br />Oozie是一个工作流调度引擎，对各种类型的Hadoop作业进行编排与调度。</p>
<ol><ol>
<li>编排与管理逻辑复杂的多种类型的Hadoop</li>
<li>基于时间（频率）触发工作流</li>
<li>基于数据有效性触发工作流</li>
<li>实时监控与管理集群的工作流，快速定位问题</li>

</ol></ol>]]></description></item><item><title>FusionInsight大数据开发---Flume应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11259342.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 28 Jul 2019 08:02:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11259342.html</guid><description><![CDATA[<h2>Flume应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Flume应用开发适用场景</li>
<li>掌握Flume应用开发</li>
</ol>
<p><strong>Flume应用场景</strong><br />Flume的核心是把数据从数据源收集过来，在送到目的地。为了保证输送一定成功，发送到目的地之前，会先缓存数据，待数据真正的到达目的地后，删除自己缓存的数据。<br />Flume采用流式方法采集和传输数据，程序配置好后，不需要外部条件触发下，一直监控数据源，源源不断地采集、传送数据到目的地。</p>
<p><strong>主要应用于一下几种场景：</strong></p>
<ol>
<li>将分布式节点上大量数据实时采集、汇总和转移</li>
<li>将集群内、外地本地文件、实时数据流采集到FusionInsight集群内的HDFS、HBase,Kafka,Solr中。</li>
<li>将Avro、System,http,Thrift,JMS、Log4j协议发送过来地数据采集到FusionInsight集群内</li>

</ol>
<p><strong>Flume基本概念</strong></p>
<ol>
<li>Source：数据源，即是产生日志信息地源头，Flume会将原始数据建模抽象成自己处理地数据对象：event</li>
<li>Channel：通道，主要作用是临时缓存Source发过来地数据</li>
<li>Sink：主要是从channel中取出数据并将数据放到不同地目的地</li>
<li>event：一个数据单元，带有一个可选地消息头，Flume传输地数据地基本单位是event，如果是文本文件，通常是一行记录。event从Source，流向Channel，再到Sink,Sink将数据写入目的地</li>

</ol>
<p><strong>方案设计：</strong><br />1）首先确定数据源：<strong>集群外</strong><br />2）数据最终流向：<strong>KafKa(集群内)</strong></p>]]></description></item><item><title>FusionInsight大数据开发---Streaming应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11259328.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 28 Jul 2019 07:59:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/28/11259328.html</guid><description><![CDATA[<h2>Streaming应用开发</h2>
<ol>
<li>掌握Streaming基本业务开发流</li>
<li>熟悉Streaming常用API接口使用</li>
<li>掌握Streaming业务设计基本原则</li>
<li>了解Streaming应用开发环境</li>
<li>了解CQL开发流及使用</li>
</ol>
<p><strong>Streaming的定义</strong></p>
<p>Streaming基于开源Storm，是一个分布式、实时计算框架。Streaming在开源Storm的基础上增加了持续查询语言CQL、增强了安全性和可靠性。</p>
<ul>
<li>事件驱动</li>
<li>连续查询</li>
<li>数据不存储、先计算</li>
<li>实时响应，低延迟</li>
</ul>
<p><strong>CQL（Continuous Query Language），持续查询语言，是一种用于实时数据流上的查询语言。</strong><br />它是一种<strong>SQL-like的语言，目前主要适配Storm。</strong><br />相对于SQL，CQL中增加了（时序）窗口的概念，将待处理的数据保存在内存中，进行快速的内存计算，CQL的输出结果为数据流在某一时刻的计算结果。<br /><br /><strong>Streaming的适用场景</strong><br />Streaming主要应用于以下几种对<strong>响应时延</strong>有严重要求的场景：</p>
<ol>
<li>实时分析：如实时日志处理，交通流分析等</li>
<li>实时统计：如网站的实时访问统计、排序等</li>
<li>实时推荐：如实时广告定位、事件营销等</li>

</ol>
<p><strong>提交拓扑</strong><br />当前Streaming支持三种方式提交拓扑</p>
<ol>
<li>Linux命令行提交-CMD模式</li>
<li>Eclipse远程提交-Remote模式</li>
<li>本地模式提交-Local模式</li>

</ol>
<p><strong>Spout设计</strong></p>
<ol>
<li>数据接受</li>
<li>数据反序列化</li>
<li>数据拆分</li>
<li>数据筛选</li>
<li>数据缓存</li>
<li>数据发送</li>

</ol>
<p><strong>counting Bolt设计</strong><br /><strong>功能：</strong></p>
<ol>
<li>窗口定义</li>
<li>刷新窗口</li>
<li>发送数据</li>

</ol>
<p><strong>Storm提供接口</strong><br />1 REST接口</p>
<ul>
<li>REST(Representational State Tansfer)表述性状态转移接口。</li>

</ul>
<p>2 Thrift接口</p>
<ul>
<li>由Numbus提供。Thrift是一个基于静态代码生成的跨语言的RPC协议栈实现。</li>

</ul>
<p><strong>Spout接口</strong></p>
<ol>
<li>Spout的Ack开关</li>

</ol>
<p><strong>Bolt接口</strong></p>
<ol>
<li>Bolt的Ack开关</li>

</ol>
<ul>
<ul>
<li><strong>创建输入流</strong></li>
<li><strong>Join</strong></li>
<li><strong>窗口</strong></li>
<li><strong>Split</strong></li>

</ul>
</ul>]]></description></item><item><title>FusionInsight大数据开发---Redis应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251787.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 26 Jul 2019 09:31:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251787.html</guid><description><![CDATA[<h2>Redis应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Redis应用场景</li>
<li>掌握Redis二次开发环境搭建</li>
<li>掌握Redis业务开发</li>
</ol>
<p><strong>Redis简介</strong></p>
<ul>
<li>Redis是一个基于网络的，高性能key-value内存数据库</li>
<li>Redis根memcached类似，不过数据可持久化，而且支持的数据类型很丰富。支持在服务端计算集合的并、交和补集等，还支持多种排序功能。</li>
</ul>
<p><strong>Redis使用场景有如下几个特点：</strong></p>
<ol>
<li>高性能</li>
<li>低延迟</li>
<li>丰富数据结构存取</li>
<li>支持持久化</li>
</ol>
<p><strong>Redis应用场景介绍</strong><br /><strong>Redis提供了灵活多变的数据结构和数据操作</strong>，主要应用于如下场景：</p>
<ol>
<li>取最新N个数据的操作，比如典型的取某网站的最新文章。</li>
<li>排行榜应用，取TOP N操作。</li>
<li>需要精准设定过期时间的应用。</li>
<li>计数器应用，比如记录用户访问网站的次数。</li>
<li>构建队列系统</li>
<li>缓存，如缓存关系数据库中的频繁访问的表数据。</li>


</ol>
<p><strong>架构回顾</strong></p>
<ol>
<li>无中心自组织的结构，节点之间使用Gossip协议来交换节点状态信息。</li>
<li>个节点维护Key-&gt;Server的映射关系。</li>
<li>Client可以向任意节点发起请求，节点不会转发请求，只是重定向Client</li>
<li>如果在Client第一次请求之间，Cluster拓扑发生改变，则第二次重定向请求将被再次重定向，直到找到正确的Server为止。</li>


</ol>
<p><strong>Redis应用开发</strong><br /><strong>设计Redis数据结构</strong></p>
<ol>
<li>取最新N个数据的操作：list</li>
<li>排行榜应用，取TOP N操作。以某个条件为权重，比如按顶的次数排行：sorted set。</li>
<li>利INCR，DECR命令来构建计数器系统。、</li>
<li>Uniq操作，获取某段时间所有数据排重值：set。</li>
<li>使用list可以构建队列系统</li>


</ol>
<p><strong>Redis应用开发</strong><br />根据场景开发工程</p>
<ol>
<li>梳理业务场景流</li>
<li>设计各模块接口</li>
<li>如果使用的是安全集群，需要进行安全认证</li>
<li>熟悉Redis提供的相应API</li>
<li>调用业务需要的API实现各功能</li>


</ol>
<p><strong>数据结构设计</strong></p>
<ul>
<li>计算过程中使用的用户信息使用hash结构存取，KEY设计为userinfo-&lt;user id&gt;，</li>
<li>field为用户的属性。</li>


</ul>
<p><strong>数据读写原则</strong></p>
<ul>
<li>MR任务每天定时将用户信息从后端存储源（HBase）批量导入Redis中。</li>
<li>业务系统获取数据时，先从Redis中获取，获取不到再取后端HBase获取即实时计算，并同步写入到Redis。</li>


</ul>
<p><strong>样例说明-String类型操作</strong></p>
<ol>
<li>set：将字符串值value关联到key</li>
<li>get：返回key所关联的字符串值，</li>
<li>setex：将字符串值value关联到key，并设置key的生存时间</li>
<li>append：将value追加到key原值的末尾，类似Java String类型的&ldquo;+&rdquo;操作。</li>


</ol>
<p><strong>样例说明-List类型操作</strong></p>
<ol>
<li>Ipush/rpush：往列表头/尾添加一个元素。</li>
<li>Irange：返回列表中start至end之间的元素</li>
<li>llen：返回列表的长度</li>
<li>lpop/rpop：从列表头/尾获取一个元素，并将其中列表中删除。</li>


</ol>
<p><strong>样例说明-Hash类型操作</strong></p>
<ul>
<ul>
<li>hset</li>
<li>hget</li>
<li>hgettall</li>
<li>hmset</li>
<li>hincrby</li>
<li>hkeys</li>
<li>hvals</li>
<li>hmget</li>
<li>hexists</li>
<li>hdel</li>


</ul>

</ul>]]></description></item><item><title>FusionInsight大数据开发---SparkStreaming概述</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251740.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 26 Jul 2019 09:25:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251740.html</guid><description><![CDATA[<h2>SparkStreaming概述</h2>
<p>SparkStreaming是Spark核心API的一个扩展，它对实时流式数据的处理具有可扩展性、高吞吐量、可容错性等特点。<br /><br /><strong>SparkStreaming原理</strong></p>
<ol>
<li>SparkStreaming接收实时的输入数据流，然后将这些数据切分为批数据供Spark引擎处理，Spark引擎将数据生成最终的结果数据。</li>
<li>使用DStream从Kafka和HDFS等源获取连接的数据流。DStream是一系列连续的RDD组成。</li>

</ol>
<p><strong>SparkStreaming数据源</strong></p>
<ol>
<li>基本源：HDFS等文件系统、Socket连接等</li>
<li>高级源：Kafka等</li>
<li>自定义源： 需要实现用户自定义receiver</li>

</ol>
<p><strong>可靠性（二次开发）</strong></p>
<ol>
<li>Reliable Receiver</li>
<li>设置CheckPoint</li>
<li>确保Driver可以自动启动</li>
<li>使用Write Ahead Log 功能</li>

</ol>
<p><strong>SparkStreaming代码流程</strong><br /><strong>常见业务代码逻辑</strong></p>
<ol>
<li>创建StreamingContext</li>
<li>定义输入源</li>
<li>准备应用计算逻辑</li>
<li>使用streamingContext.start()方法接受和处理数据。</li>
<li>使用streamingContext.stop()方法停止流计算。</li>

</ol>
<p><strong>窗口操作</strong><br />SparkStreaming支持窗口计算，允许用户在一个滑动窗口数据上应用transformation算子。<br />窗口在源DStream上滑动，合并和操作落入窗口RDDs，产生窗口化的DStream的RDDs。</p>
<p><strong>Checkpoint</strong><br />SparkStreaming可以checkpoint足够的信息到容错存储系统中，以使系统崩溃后从故障中恢复。</p>
<ol>
<li>Metadata checkpoint：保存流计算的定义信息到HDFS中</li>
<li>Data checkpoint：保存生成的RDD到HDFS中。</li>

</ol>
<p><strong>SparkStreaming性能调优</strong></p>
<ul>
<li>设置合理的批处理时间（batch Duration）</li>
<li>设置合理数据接收并行度</li>

</ul>
<ol>
<li>设置多个Receiver接受数据</li>
<li>设置合理的Receiver阻塞时间</li>

</ol>
<ul>
<li>设置合理数据处理并行度</li>
<li>使用Kryo系列化</li>
<li>内存调优</li>

</ul>
<ol><ol>
<li>设置持久化级别减少GC开销</li>
<li>使用并发的标记-清理GC算法减少GC暂停时间</li>

</ol></ol>]]></description></item><item><title>FusionInsight大数据开发---Spark应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251666.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 26 Jul 2019 09:18:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251666.html</guid><description><![CDATA[<h2>Spark应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Spark基本原理</li>
<li>搭建Spark开发环境</li>
<li>开发Spark应用程序</li>
<li>调试运行Spark应用程序</li>
</ol>
<p><br /><strong>YARN资源调度，可以和Hadoop集群无缝对接</strong></p>
<p><strong>Spark适用场景</strong><br />大多数现有集群计算框架如MapReduce等基于从稳定存储（文件系统）到稳定存储的非循环数据流，数据重用都是基于磁盘的，执行效率比较低。<br />与传统的MapReduce任务频繁读写磁盘数据相比，基于内存计算的Spark则更适合应用在迭代计算，交互式分析等场景。</p>
<p><br /><strong>Spark应用运行流程--关键角色</strong></p>
<ul>
<li>Client：需求提出方，负责提交需求（应用）。</li>
<li>Driver：负责应用的业务逻辑和运行规划（DAG）。</li>
<li>ApplicationMaster：负责应用的资源管理，根据应用的需求，向资源管理部门（ResourceManager）申请资源。</li>
<li>ResourceManager：资源管理部门，负责整个集群的资源统一调度和分配</li>
<li>Executor：负责实际计算工作，一个应用会分拆给多个Executor来进行计算。</li>

</ul>
<p><strong>Spark核心概念--RDD</strong><br />RDD（Resilient Distributed Datasets)即弹性分布式数据集，指的是一个只读的，可分区的分布式数据集。这个数据集的全部或部分可以缓存在内存中，在多次计算间重用。<br /><strong>RDD的生成</strong></p>
<ol>
<li>从Hadoop文件系统（或与Hadoop兼容的其它存储系统）输入创建（如HDFS）</li>
<li>从集群创建（如sc.Parallelize）。</li>
<li>从夫RDD转换得到新的RDD。</li>

</ol>
<p><strong>RDD的存储和分区</strong></p>
<ol>
<li>用户可以选择不同的存储级别存储RDD以便重用（11种）</li>
<li>当前RDD默认存储于内存，但当内存不足时，RDD会溢出到磁盘中。</li>
<li>RDD在需要进行分区时会根据每条记录Key进行分区，以此保证两个数据集能高效进行Join操作。</li>

</ol>
<p><strong>RDD的优点</strong></p>
<ol>
<li>RDD是只读的，可提供更高的容错能力</li>
<li>RDD的不可变性，可以实现Hadoop MapReduce的推测式执行</li>
<li>RDD的数据分区特性可以通过数据的本地性来提高性能。</li>
<li>RDD都是可序列化的，在内存不足时可自动降级为磁盘存储。</li>

</ol>
<p><strong>RDD的特点</strong></p>
<ol>
<li>在集群节点上时不可变的，是已分区的集合对象。</li>
<li>失败后自动重连</li>
<li>可以控制存储级别（内存、磁盘等）来进行重用。</li>
<li>必须是可序列化的</li>
<li>是静态类型。</li>

</ol>
<p><strong>RDD的创建</strong><br />Spark所有操作都围绕弹性分布式数据集（RDD）进行，这是一个有容错机制并可以被并行操作的元素集合，具有只读，分区，容错，高效，无需物化，可以缓存，RDD依赖等特征。<br /><strong>目前有两种类型的基础RDD：</strong></p>
<ol>
<li>并行集合：接受一个已经存在的Scala集合，然后进行并行计算</li>
<li>Hadoop数据集：在一个文件的每条记录上运行函数。</li>

</ol>
<p><strong>RDD的创建--并行集合	</strong><br />并行集合是通过调用SparkContext的parallelize方法，在一个已经存在的Scala集合（一个Seq对象）上创建的。<br />集合的对象将会被拷贝，创建出一个可以被并行操作的分布式数据集。</p>
<p><strong>RDD依赖：宽依赖和窄依赖</strong><br /><strong>RDD父子依赖关系</strong></p>
<ul>
<li>窄依赖：（Narrow）指父RDD的每一个分区最多被一个子RDD的分区所用。</li>
<li>宽依赖：（Wide）指子RDD的分区依赖于父RDD的所有分区，是Stage划分的依据。</li>

</ul>
<p>&nbsp;</p>
<ul>
<li><strong>RDD常用Transformation算子</strong></li>
<li><strong>RDD常用Action算子</strong></li>

</ul>
<p><strong>Spark任务参数配置</strong></p>
<ul>
<li>Spark优先级是：<strong>配置文件&lt;动态参数&lt;代码配置</strong></li>

</ul>
<p><strong>相同的数据，只创建一个RDD</strong></p>
<p><strong>算法调优--RDD缓存</strong></p>
<ul>
<li>Spark可以使用persist和cache方法将任意RDD缓存到内存、磁盘文件系统中。</li>

</ul>
<p><strong>算法调优--避免使用Shuffle</strong></p>
<ul>
<li>Shuffle过程会有整个RDD数据的写和读的操作，成本非常高。</li>

</ul>
<p><strong>算法调优--使用广播变量</strong><br /><strong>外部变量：</strong></p>
<ul>
<li>每个task都有一个变量副本。</li>

</ul>
<p><strong>广播变量：</strong></p>
<ul>
<li>每个Executor保留一份。</li>

</ul>
<p><strong>编写代码</strong></p>
<ol>
<li>登陆</li>
<li>创建连接</li>
<li>执行SQL</li>
<li>获取结果</li>

</ol>
<p><strong>DataFrame介绍</strong><br /><strong>DataFrame：</strong>已RDD为基础，带有Schema信息，类似传统数据库的二维表。</p>
<p><br /><strong>编写代码</strong></p>
<ol><ol>
<li>登陆</li>
<li>注册Table</li>
<li>执行SQL</li>
<li>过滤</li>

</ol></ol>]]></description></item><item><title>FusionInsight大数据开发---Kafka应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251625.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 26 Jul 2019 09:12:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251625.html</guid><description><![CDATA[<h2>Kafka应用开发</h2>
<ol>
<li>了解Kafka应用开发适用场景</li>
<li>熟悉Kafka应用开发流程</li>
<li>熟悉并使用Kafka常用API</li>
<li>进行Kafka应用开发</li>
</ol>
<p><strong>Kafka的定义</strong><br /><strong>Kafka是一个高吞吐、分布式、基于发布订阅的消息系统</strong><br />Kafka有如下几个特点：</p>
<ol>
<li>高吞吐量</li>
<li>消息持久化到磁盘</li>
<li>分布式系统易扩展</li>
<li>容错性好</li>

</ol>
<p><strong>Kafka的适用场景</strong></p>
<ol>
<li>适用于离线和在线的消息消费</li>
<li>已对接组件</li>
<li>Streaming、Spark、Flume</li>

</ol>
<p><strong>使用Kafka的好处</strong></p>
<ul>
<li>解耦--使得消息生产、消费系统能够独立变更</li>
<li>可靠--有效解决单点故障引发系统不可用问题</li>
<li>易扩展--生产、消费系统扩展简单</li>
<li>可恢复--消息缓存下来，支持故障从故障点读取</li>
<li>异步通信--生产系统无需关心消费系统的消费时间</li>

</ul>
<p><strong>配置及开发准备--配置keytab文件到样例工程</strong></p>
<ol>
<li>配置Keytab到工程</li>
<li>安全认证</li>
<li>Topic订阅</li>
<li>消费获取</li>
<li>消费处理</li>

</ol>
<p><br /><strong>Kafka常用接口</strong></p>
<ul>
<li>Kafka集群安全访问端口默认为21007，非安全访问端口默认为21005</li>

</ul>
<p><strong>Kafka Producer接口</strong></p>
<ol>
<li>&nbsp;向管理员申请目标Topic的生产者权限</li>
<li>&nbsp;根据业务需求，配置发送相关配置参数</li>
<li>&nbsp;调用新Producer API接口发送数据</li>

</ol>
<p><strong>Kafka Consumer接口</strong></p>
<ol><ol>
<li>向管理员申请目标Topic的消费者权限</li>
<li>根据业务需求，配置消费者相关配置参数</li>
<li>调用新Consumer API接口进行消息消费</li>

</ol></ol>]]></description></item><item><title>FusionInsight大数据开发---sorl应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251594.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 26 Jul 2019 09:10:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251594.html</guid><description><![CDATA[<h2>sorl应用开发</h2>
<p><strong>要求：</strong></p>
<ol>
<li>了解Solr应用开发适用场景</li>
<li>熟悉Solr应用开发流程</li>
<li>熟悉并使用Solr常用API</li>
<li>理解Collection设计基本原则</li>
<li>应用开发实践</li>
</ol>
<p><strong>Solr简介</strong></p>
<ol>
<li>Solr是一个高性能，基于Lucene的全文检索服务，也可以作为NoSQL数据库使用。</li>
<li>Solr对Lucene进行了扩展，提供了比Lucene更为丰富的查询语句，同时实现了可配置、可扩展，并对查询性能进行了优化，还提供了一个完善的功能管理界面。</li>
<li>SolrCloud是从Solr 4.0 版本开始发出的具有开创意义的分布式索引和索引方案，基于Sorl和Zookeeper进行开发的。</li>
</ol>
<p><strong>Solr概念体系-总述</strong><br /><strong>常见术语：</strong></p>
<ul>
<li>Config Set:Solr Core提供一组配置文件 ,</li>
<li>Core:即Solr Core ，</li>
<li>Shard：Collection的逻辑分片</li>
<li>Replice：Shard下的实际存储索引的一个副本，与Core对应</li>
<li>Leader：赢得选举的Shard Peplicas</li>
<li>Zookeeper:它在Solr Core是必须的，提供分布式锁、处理Leader选举、管理配置等功能</li>

</ul>
<p><strong>Solr的常用应用场景</strong></p>
<ol>
<li>待检索数据类型复杂</li>
<li>检索条件多样化（如涉及字段太多），常规查询无法满足</li>
<li>读取远多于写入数据</li>

</ol>
<p><br /><strong>Solr应用开发流程-制定业务目标</strong><br /><strong>业务数据规模及数据模型</strong></p>
<ul>
<li>涉及Collection的Shard划分及Schema的定义</li>

</ul>
<p><strong>实时索引、查询性能要求</strong></p>
<ul>
<li>涉及Collection的Shard划分、索引存储位置</li>

</ul>
<p><strong>查询场景</strong></p>
<ul>
<li>涉及Collection的Schema定义</li>

</ul>
<p><br /><strong>Solr应用开发流程-初始化及安全认证</strong></p>
<ol>
<li>初始化并获取配置</li>
<li>安全认证</li>
<li>获取CloudSolrClient</li>
<li>调用Solr APL</li>

</ol>
<p><strong>Solr应用开发流程-设计Collection</strong></p>
<ol>
<li>根据业务数据的关系设计schema.xml</li>
<li>根据写入和查询场景设计uniqueKey字段</li>
<li>根据写入和查询性能要求设计solrconfig.xml</li>
<li>根据业务数据规模和Solr集群规模确定Shard数目</li>
<li>根据可靠性能要求设定Shard副本数</li>

</ol>
<p><strong>Collection设计-索引存储位置</strong><br /><strong>索引存储在HDFS</strong></p>
<p><strong>缺点:</strong></p>
<ol>
<li>与存储在本地磁盘相比，性能下降30%-50%</li>
<li>实时单节点写入速度&lt;=2MB/s</li>
<li>数据膨胀略高于存储在本地</li>

</ol>
<p><strong>优点：</strong></p>
<ol>
<li>Sorl设置Replica即可，利用HDFS副本机制保障数据可靠性</li>
<li>数据管理由HDFS完成，包括各节点数据balance、方便迁移</li>

</ol>
<p><strong>配置集Schema设计-Field</strong><br /><strong>dynamicField</strong></p>
<ul>
<li>动态的字段设置，用于后期自定义字段，&rdquo;*&ldquo;号通配符。</li>

</ul>
<p><strong>copyField</strong></p>
<ul>
<ul>
<li>将多个字段集中到一个字段</li>

</ul>
</ul>]]></description></item><item><title>FusionInsight大数据开发---Hive应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251556.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 26 Jul 2019 09:06:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251556.html</guid><description><![CDATA[<h2>Hive应用开发</h2>
<ol>
<li>了解Hive的基本架构原理</li>
<li>&nbsp;掌握JDBC客户端开发流程</li>
<li>了解ODBC客户端的开发流程</li>
<li>了解python客户端的开发流程</li>
<li>了解Hcatalog/webHcat开发接口</li>
<li>&nbsp;掌握Hive开发规则</li>
</ol>
<p><strong>1. 了解Hive的基本架构原理</strong><br /><strong>守护进程：</strong></p>
<ol>
<li>HiveServer（Thrift/Compiler）</li>
<li>webHcat</li>
<li>MetaStore</li>

</ol>
<p><strong>Hive的应用场景</strong></p>
<ol>
<li>数据挖掘</li>
<li>非实时分析</li>
<li>数据汇总</li>
<li>作为数据仓库</li>

</ol>
<p><strong>2. 掌握JDBC客户端开发流程</strong><br /><strong>JDBC开发-参数初始化</strong></p>
<ol>
<li>设置ZooKeeper地址</li>
<li>krb5文件路径</li>
<li>设置JAAS配置</li>
<li>配置ZooKeeper Principal</li>
<li>执行登陆</li>

</ol>
<p><strong>JDBC开发-拼接URL</strong></p>
<ol>
<li>JDBC前缀设置</li>
<li>服务发现模式</li>
<li>安全配置：qop.auth.principal</li>
<li>非安全配置</li>

</ol>
<p><strong>JDBC开发-执行SQL</strong></p>
<ol>
<li>加载驱动类</li>
<li>建立连接</li>
<li>执行SQL</li>
<li>关闭连接</li>

</ol>
<p><strong>JDBC开发-SQL实现</strong></p>
<ol>
<li>创建preparedStatement</li>
<li>执行statement</li>
<li>关闭statement</li>

</ol>
<p><strong>规则建议：</strong><br /><strong>开发调式：</strong>在开发程序时，可通过使用Hive的客户端Beeline先进行调试，检验语句与结果正确性，再部署基于JDBC等的应用程序。<br />获取数据库连接：Hive的数据库URL再拼接时已经经过安全认证，所以Hive数据库的用户名和密码为null或空 。</p>
<p><br /><strong>JDBC超时限制:</strong>Hive提供的JDBC实现的超时限制，默认是5分钟。</p>
<p><br /><strong>执行HQL：</strong>再JAVA　JDBC应用开发中，拼装HQL语句，注意HQL语句不能以&ldquo;;&ldquo;结尾。</p>
<p><br /><strong>HQL语法规则之判空：</strong>判断字段为空使用：&rdquo;is null&ldquo;，判断不为空，即有值，使用："is not null"</p>
<p><br /><strong>UDF的管理：</strong>建议由管理员创建永久UDF，避免每次使用时都去add jar，和重新定义UDF。</p>
<p><br /><strong>UDF的注解：</strong>Hive的UDF会有一些默认属性。@UDFType(deterministic = false)</p>
<p><br /><strong>使用分区表：</strong>当数据量较大时，且经常需要按天统计时，建议使用分区表，按天存放数据。</p>
<p><br /><strong>动态分区表</strong>：为了避免插入动态分区数据过程中，产生过多的小文件，在执行插入时，在分区字段上加distribut by。</p>
<p><br /><strong>文件格式选择：</strong>Hive支持多种存储格式，比如TextFile,RCFile,ORC,Sequence,Parquet.</p>]]></description></item><item><title>FusionInsight大数据开发---MapReduce与YARN应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251503.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 26 Jul 2019 09:01:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/26/11251503.html</guid><description><![CDATA[<h2>MapReduce</h2>
<ol>
<li>&nbsp;MapReduce的基本定义及过程</li>
<li>搭建开发环境</li>
<li>代码实例及运行程序</li>
<li>MapReduce开发接口介绍</li>
</ol>
<p>&nbsp;</p>
<h3><strong>1. MapReduce的基本定义及过程</strong></h3>
<p>MapReduce是面向大数据并行处理的计算模型、框架和平台，其资源调度由Yarn完成，任务资源隐含了以下三层含义：</p>
<ul>
<li>1）MapReduce是 一个基于集群的高性能并行计算平台（cluster Infrastructure）。</li>
<li>2）MapReduce是 一个并行计算与运行软件框架（SoftWare Framework）</li>
<li>3）MapReduce是 一个并行程序设计模型与方法（Programming Model &amp; Methodology）</li>
</ul>
<p><strong>MapReduce特点：</strong></p>
<ul>
<li>易于编程</li>
<li>良好的扩展性</li>
<li>高容错性</li>
</ul>
<p><strong>MapReduce的过程：</strong></p>
<ol>
<li>把输入的数据（Input） 拆分为多个键值对（key-value对）</li>
<li>每一个键值对分别调用Map进行并行处理</li>
<li>每一个Map会产生多个新的键值对</li>
<li>对Map阶段产生的数据进行排序、组合</li>
<li>以键值对的形式输出最终结果</li>
</ol>
<h3><br />2. 搭建开发环境</h3>
<ol>
<li>确认Yarn组件和MapReduce组件已经安装。</li>
<li>客户端安装Eclipse和JDK程序。</li>
<li>客户端机器的时间与FusInsight集群时间要保持一致，时间差要小于5分钟。</li>
<li>在Yarn服务页面下载MapReduce客户端程序到客户端机器中。</li>






</ol>
<ul>
<li>1.下载客户端</li>
<li>2.获取样例工程</li>
<li>3.生成样例工程</li>
<li>4.导入eclipse</li>
<li>5.编码</li>






</ul>
<h3><br />开发相关类的总结</h3>
<p><strong>1) InputFormat类</strong></p>
<ul>
<li>将输入的数据分割成split，并将split拆分为&lt;key,value&gt;作为map的输入。</li>






</ul>
<p><strong>2） Mapper类</strong></p>
<ul>
<li>实现map函数，根据输入的&lt;key,value&gt;对产生中间结果。</li>






</ul>
<p><strong>3）Combiner类</strong></p>
<ul>
<li>实现combiner函数，合并中间结果中具有相同key值的键值对。</li>






</ul>
<p><strong>4） Partitioner类</strong><br />实现getPartitioner函数，在Shuffle过程按照key值将中间数据分成R份，每一份由一个Reduce负责</p>
<p>5） Reduce类</p>
<ul>
<li>实现reduce函数，将中间结果合并，得到最终的结果。</li>






</ul>
<p><strong>6）OutputFormat类</strong></p>
<ul>
<li>该类负责输出最终的结果，MapReduce使用OutputFormat类将数据输出存入到文件中，每个Reduce将它的输出直接写到自己的文件中。</li>






</ul>
<p><br /><strong>调式代码</strong></p>
<ul>
<li>MapReduce开发调式采用的原理是Java的远程调式机制</li>




</ul>
<p>&nbsp;</p>
<h2>YARN</h2>
<h3><strong>一、YARN出现的背景</strong></h3>
<p>　　YARN作为一种协调机制，是在Hadoop 2.0版本才出现使用的。在1.0版本中，对数据的处理、资源的调度主要依赖于MapReduce算法。来看一下Hadoop 1.版本的应用处理机制：</p>
<p><img src="https://img2018.cnblogs.com/blog/1747630/201908/1747630-20190804132747905-1670811750.png" alt="" width="350" height="230" /></p>
<ol>
<li>一个需要用到Data A和Data C的应用提交给M/R</li>
<li>M/R为应用创建一个Job，Job将应用分片后提交给Job Tracker</li>
<li>Job Tracker根据应用所需的数据找到相应的DN节点，在DN节点上分配相应的Task Tracker执行任务</li>
<li>Task Tracker在执行任务时实时与Job Tracker进行交互，汇报任务执行情况</li>
<li>Job Tracker接受各Task Tracker的计算结果</li>
</ol>
<p>我们先理解一下Job Tracker和Task Tracker。应用在提交给Job Tracker时已经分好片，在Job Tracker接受到的仍是一个完整的应用。之后由Job Tracker将分片的应用下放到相应的DN节点，由Task Tracker具体执行，这个时候Task Tracker收到的时整个应用的一部分，可以成为任务。那么我们可以将Job Tracker理解为整个应用和整个DN集群的管理器，而Task Tracker则是分片任务的管理器。选择回顾整个处理机制，我们能发现两个突出的问题：</p>
<ol>
<li>Job Tracker的地位很重要，但负载也太大了。除了初始的应用分片不需要它处理，剩下的一切都需要它&rdquo;追踪&ldquo;，包括任务的具体执行情况也要它操个心。对整个系统来说，这不是好事。</li>
<li>Job Tracker时按照所需数据来进行分配，那么资源（主要指内存）就很容易分配不均。打个比方：一个Job被分成6个子Job，每个子Job需要的资源（内存）是1GB。但所有子Job所需要的数据全部集中在一台DN节点上，该节点内存只有4GB，一次只能接受4给子Job。剩下的2个子Job正能等内存释放后再进入执行。而在等待工程中，其他的DN节点是处于空闲状态的。</li>
</ol>
<p>这两个问题暴露了Hadoop 1.0版本的资源协调在处理大规模数据时会有些&rdquo;力不从心&ldquo;。而随着数据规模的快速扩大，Hadoop亟需一种更优化的资源协调解决方案，YARN就在这一背景下诞生。</p>
<p>&nbsp;</p>
<h3><strong>二、YARN的重要角色及概念</strong></h3>
<ol>
<li>ResourceManager（RM）</li>
</ol>
<p>　　　　RM是整个集群的资源管理器，负责整个集群的资源调度和管理。同时也负责与客户端交互，处理客户端的应用请求等。它主要有２个组建构成：</p>
<ul>
<li>①Resource　Scheduler：纯资源调度器，只负责为程序进程调度所需的资源</li>
<li>②Applications Manager(ASM)：与具体应用程序打交道，处理程序的请求，具体负责程序的分配</li>
</ul>
<ol>
<li>Node Manager（ＮＭ)：节点管理器，负责管理自己节点上的资源和使用，于RM交互，上报节点的状态，以便RM调用</li>
<li>Application Master(AM)：在DN节点上中，是每个子程序的管理者，负责管理由RM分发的任务，包括任务的资源申请和执行情况</li>
<li>Container：资源打包容器，AM向RM申请来的资源的集合，并利用这些资源负责具体执行任务。位于DN节点上。</li>
</ol>
<p>&nbsp;</p>
<h3><strong>三、YARN运行流程</strong></h3>
<p>　　还是要提一下，YARN作为资源的协调者，本身不提供应用程序和文件数据。应用程序由客户端发起，由Hadoop上层的算法转化成不同的任务，数据文件存储在HDFS上。所以说，YARN只是辅助任务去调用资源来计算这些数据，并不参与到计算中去。</p>
<p><img src="https://img2018.cnblogs.com/blog/1747630/201908/1747630-20190804161546426-502224604.png" alt="" width="438" height="274" /></p>
<ol>
<li>客户端向RM发送应用请求</li>
<li>RM根据NM的节点信息选择合适的DN节点</li>
<li>RM在选中的DN节点上创建并启动AM，将任务分发给AM</li>
<li>AM根据自己的任务情况向RM申请相应的资源</li>
<li>RM为AM分配相应的资源</li>
<li>AM得到资源后启动对应的资源容器（Container）执行任务并进行监控</li>
<li>Conrtainer将任务执行完毕报告给AM</li>
<li>AM将任务的执行结果上报给RM</li>
<li>RM向Client返回应用的执行结果</li>
</ol>
<p>现在我们再回顾一下Hadoop 1.0版本的局限性：</p>
<ul>
<li>Job Tracker既要调度又要监控，负载过高</li>
</ul>
<p>　　再YARN中，区别于1.0版本最主要的思想就是将调度和监控功能分离。RM主要负责资源的调度，具体任务监控则由AM来完成。RM只要在节点上启动AM并将任务发给AM就行，不用管任务具体是怎么执行的，当任务完成后由AM向RM报告一个结果就行了。且AM分布在各节点上，不占用RM本身资源，大大减少了RM的工作量，整个系统的稳定性就有了极大的提高。</p>
<ul>
<li>任务按数据需求分配，资源分配不均，效率低下</li>
</ul>
<p>　　AM在向RM申请资源时，不在局限于本节点的资源，而是由RM根据各节点信息选择合适的节点资源调配给AM使用。换句话说，&rdquo;AM你有什么需求尽管提，只要我有一定给你（哦吼，霸道总裁既视感）&ldquo;这个&rdquo;我&ldquo;指的就是整个集群了。</p>
<p>YARN的加入使得Hadoop 2.0系统有了一种高效、可靠的处理大规模数据的能力。但老样子，为保持整个Hadoop系统的高可靠性，YARM也需要一套高可靠性机制。</p>
<p>&nbsp;</p>
<h3><strong>四、YARN的高可靠性</strong></h3>
<p>高可靠性，主要就是对整个运行环节中的任一环节的出错情况有一套快速恢复的预案。我们结合YARN的角色看一下每个环节的解决方案</p>
<p>　1、任务执行出错（Container）</p>
<ul>
<li>Container作为任务的具体执行者，由任务管理器AM所监控。当Container出错时会向AM发送报告，随后释放自己的资源。AM收到失败报告后会重新启动该任务，一般会选在不同节点</li>
</ul>
<p>　2、任务管理器出错（AM）</p>
<ul>
<li>AM作为节点信息，会周期性的向RM发送心跳信息。当AM出错时，一般会尝试进行重启。重启失败后，RM会发现该AM不可用，则会在其他节点建立一个新的AM，用来接管原AM管理的Container</li>
</ul>
<p>　３、节点管理器出错（NM）</p>
<ul>
<li>节点管理器管理者整个节点的资源和信息，并与RM建立心跳联系。当NM出现问题，即表示该节点损坏，RM检测到之后，会将该节点从自己的节点池中移除，并将该节点上的进程加载到其他节点上运行</li>
</ul>
<p>　４、资源管理器出错（RM）</p>
<ul>
<li>RM作为整个集群的资源管理器，是YARN最核心的部分，一旦宕机将会丢失一切任务和资源信息。为保障其高可靠性，采取了主备机制。整个集群中会运行多个RM，通过ZooKeeper进行主备选举。主RM运行中的相关信息会保存在ZooKeeper的一个存储区内，当主RM宕机或算坏后，ZooKeeper会立即选举出新的主RM。新的主RM会从ZooKeeper中获取进程的运行信息和节点的信息，来接替主RM的工作</li>
</ul>
<p>&nbsp;</p>
<h3><strong>五、总结</strong></h3>
<p>　　YARN作为Hadoop的资源协调者，是Hadoop处理大规模数据的保障。在以后学习Hadoop的上层算法中，基本都会涉及到YARN的资源协调。换句话说，YARN为大数据的高效算法提供了优秀的协调机制。</p>]]></description></item><item><title>目录--Java基础（更新中...)</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/24/11238660.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 24 Jul 2019 08:02:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/24/11238660.html</guid><description><![CDATA[<h2>&nbsp;Java学习</h2>
<h3>第一阶段</h3>
<p><strong>语法基础</strong></p>
<ul>
<li><strong><a id="post_title_link_11041949" href="https://www.cnblogs.com/cainiao-chuanqi/p/11041949.html">Java学习：常量和变量 的定义和注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11045318" href="https://www.cnblogs.com/cainiao-chuanqi/p/11045318.html">Java学习：数据类型转换注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11046487" href="https://www.cnblogs.com/cainiao-chuanqi/p/11046487.html">Java学习：运算符的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11051843" href="https://www.cnblogs.com/cainiao-chuanqi/p/11051843.html">Java学习：switch语句使用的注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11052390" href="https://www.cnblogs.com/cainiao-chuanqi/p/11052390.html">java学习：循环结构的使用规则和注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11232732" href="https://www.cnblogs.com/cainiao-chuanqi/p/11232732.html">Java学习：构造方法</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11060933" href="https://www.cnblogs.com/cainiao-chuanqi/p/11060933.html">Java学习：方法的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11061116" href="https://www.cnblogs.com/cainiao-chuanqi/p/11061116.html">Java学习：方法重载的使用规则</a>&nbsp;</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11066350" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066350.html">Java学习：数组的使用和注意事项</a>&nbsp;</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223262" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223262.html">Java学习：Debug调试程序</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11066356" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066356.html">Java的内存需要划分成为5个部分</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11073993" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073993.html">局部变量和成员变量的区别</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11073989" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073989.html">一个标准的类通常要拥有下面四个组成部分</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210377" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210377.html">基本类型与字符串类型之间的相互转换</a></strong></li>
</ul>
<p><strong>面向对象</strong></p>
<ul>
<li><strong><a id="post_title_link_11073986" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073986.html">Java学习： 面向对象的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11232748" href="https://www.cnblogs.com/cainiao-chuanqi/p/11232748.html">Java学习：面向对象三大特征：封装、继承、多态之封装性</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11110165" href="https://www.cnblogs.com/cainiao-chuanqi/p/11110165.html">面向对象的三大特征：封装性、继承性、多态性之继承</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11110199" href="https://www.cnblogs.com/cainiao-chuanqi/p/11110199.html">Java学习：抽象方法和抽象类的使用</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11115251" href="https://www.cnblogs.com/cainiao-chuanqi/p/11115251.html">Java学习：接口（interface）的使用于注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11115399" href="https://www.cnblogs.com/cainiao-chuanqi/p/11115399.html">Java学习：面向对象三大特征：封装性、继承性、多态性之多态性。</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11129165" href="https://www.cnblogs.com/cainiao-chuanqi/p/11129165.html">Java学习：final关键字的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11129200" href="https://www.cnblogs.com/cainiao-chuanqi/p/11129200.html">Java四种权限修饰符 在创建类中的使用</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11129279" href="https://www.cnblogs.com/cainiao-chuanqi/p/11129279.html">Java学习：内部类的概念于分类</a></strong></li>
</ul>
<p>&nbsp;</p>
<h3><strong>第二阶段</strong></h3>
<p><strong>常用API&nbsp;</strong></p>
<ul>
<li><strong><a id="post_title_link_11090273" href="https://www.cnblogs.com/cainiao-chuanqi/p/11090273.html">常用Java API之Scanner：功能与使用方法</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11097312" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097312.html">Java中的匿名对象</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11097354" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097354.html">常用Java API之Ramdom--用代码模拟猜数小游戏</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11097439" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097439.html">Java学习：集合的使用与数组的区别</a>(ArraList集合)</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11104473" href="https://www.cnblogs.com/cainiao-chuanqi/p/11104473.html">Java学习：字符串概述与特点</a>(String类）</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11106671" href="https://www.cnblogs.com/cainiao-chuanqi/p/11106671.html">Java学习：static 关键字概述</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11107411" href="https://www.cnblogs.com/cainiao-chuanqi/p/11107411.html">Java学习：数组工具类Arrays</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11107896" href="https://www.cnblogs.com/cainiao-chuanqi/p/11107896.html">Java.util.Math类--数学相关的工具类</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210316" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210316.html">Java的常用API之Object类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210341" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210341.html">Java的常用API之Date类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210359" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210359.html">Java的常用API之System类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210367" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210367.html">Java的常用API之包装类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210381" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210381.html">Java的常用API</a></strong></li>
</ul>
<p><strong>集合</strong></p>
<ul>
<li><strong><a id="post_title_link_11215984" href="https://www.cnblogs.com/cainiao-chuanqi/p/11215984.html">Java学习：单列集合Collection</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216004" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216004.html">Java学习：迭代器简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216032" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216032.html">Java学习：泛型简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216046" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216046.html">斗地主案例的代码实现（单列）</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216058" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216058.html">集合单列--Colletion</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223084" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223084.html">Java学习：数据结构简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223151" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223151.html">Java学习：List接口</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223170" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223170.html">Java学习：Set接口与HashSet集合存储数据的结构（哈希表）</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223173" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223173.html">Java学习：可变参数</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223283" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223283.html">Java学习：双列集合Map</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223241" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223241.html">Java学习：Map接口</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223248" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223248.html">计算一个字符串中每一个字符出现的次数</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223279" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223279.html">JDK9对集合添加的优化</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223281" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223281.html">斗地主综合案例：有序版本（双列）</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2><strong>JDBC</strong></h2>
<ul>
<li><strong><a id="post_title_link_11131043" href="https://www.cnblogs.com/cainiao-chuanqi/p/11131043.html">Java学习：JDBC快速入门</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11146258" href="https://www.cnblogs.com/cainiao-chuanqi/p/11146258.html">Java学习：JDBC各类详解</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11146348" href="https://www.cnblogs.com/cainiao-chuanqi/p/11146348.html">Java学习：数据库连接池技术</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2>&nbsp;<strong>数据库</strong></h2>
<ul>
<li><strong><a id="post_title_link_11191647" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191647.html">数据库知识总结（全）</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_11190999" href="https://www.cnblogs.com/cainiao-chuanqi/p/11190999.html">数据库知识总结</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_11191112" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191112.html">什么是SQL ？</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191227" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191227.html">SQL分类之DDL：操作数据库表</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191360" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191360.html">SQL分类之DML：增删改表中的数据</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191387" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191387.html">SQL分类之DQL：查询表中的记录</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191639" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191639.html">SQL分类之DCL:管理用户、授权</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191539" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191539.html">数据库的查询语句的约束和范式</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191600" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191600.html">数据库的多表查询和事务</a></strong></li>
</ul>]]></description></item><item><title>将博客搬至CSDN</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/23/11233015.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 23 Jul 2019 09:09:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/23/11233015.html</guid><description><![CDATA[<p>https://www.cnblogs.com/cainiao-chuanqi/</p>]]></description></item><item><title>Java学习：面向对象三大特征：封装、继承、多态之封装性</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/23/11232748.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 23 Jul 2019 08:44:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/23/11232748.html</guid><description><![CDATA[<h3>面向对象三大特征：封装、继承、多态。</h3>
<p><strong>封装</strong>性在Java当中的体现：</p>
<ol>
<li>方法就是一种封装</li>
<li>关键字private也是一种封装</li>
</ol>
<p><strong>封装就是将一些细节信息隐藏起来，对于外界不可见。</strong></p>
<div class="cnblogs_code">
<pre><span>问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。
解决方案：用private关键字将需要保护的成员变量进行修饰</span></pre>
</div>
<p>一旦用了private进行修饰，那么本类当中任然可以随意访问。<br /><strong>但是：</strong>超出了本类范围之外就不能再直接访问了。</p>
<p>间接访问private成员变量，就是定义一对儿Getter/Setter方法</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>必须叫setXxx或者getXxx命名规则。</li>
<li>对于Getter来说，不能有参数，返回值类型和成员变量对应；</li>
<li>对于Setter来说，不能有返回值，参数类型和成员变量对应。</li>

</ul>
<h3><br />this关键字的定义：</h3>
<p>当方法的局部变量和类的成员变量重名的时候，<strong>根据&ldquo;就近原则&rdquo;，优先使用局部变量。</strong><br />如果需要访问本类当中的成员变量，需要使用格式：</p>
<div class="cnblogs_code">
<pre>this<span>.成员变量
&ldquo;通过谁调用的方法，谁就是this。</span></pre>
</div>]]></description></item><item><title>Java学习：构造方法</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/23/11232732.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 23 Jul 2019 08:43:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/23/11232732.html</guid><description><![CDATA[<h3>构造方法：</h3>
<p><strong>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是再调用构造函数。</strong></p>
<div class="cnblogs_code">
<pre><span>格式：
public<span> 类名称（参数类型 参数名称）{
方法体
}</span></span></pre>
</div>
<p><strong>注意事项：</strong></p>
<ol>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不需要写</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数，方法体什么事情都不做</li>
</ol>
<div class="cnblogs_code">
<pre>public Student（）{}</pre>
</div>
<p>　　5.一旦编写了至少一个构造方法，那么编译器将不再赠送。</p>
<p>　　6.构造方法也是可以进行重载的。</p>
<div class="cnblogs_code">
<pre>重载：方法名称相同，参数列表不同。</pre>
<p>&nbsp;</p>
</div>]]></description></item><item><title>Java学习：集合双列Map</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223283.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 15:04:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223283.html</guid><description><![CDATA[<h2>数据结构</h2>
<p><strong>数据结构：</strong></p>
<p><strong>数据结构_栈</strong>：先进后出</p>
<ul>
<li>入口和出口在同一侧</li>
</ul>
<p><strong>数据结构_队列：</strong>先进先出</p>
<ul>
<li>入口和出口在集合的两侧</li>
</ul>
<p><strong>数据结构_数组：</strong></p>
<ul>
<li>查询快：数组的地址是连续的，我们通过数组的首地址可以找到数组，通过数组的索引可以快速的查找某一个元素。</li>
<li>增删慢：数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个新数组，把原数组的数据复制过来</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">例：
</span><span style="color: #0000ff;">int</span>[] arr = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[]{1,2,3,4};</pre>
</div>
<p>要把数组索引是3的元素删除</p>
<ul>
<li>必须创建一个新的数组，<strong>长度是原数组的长度-1</strong></li>
<li>把原数组的其它元素复制到新数组中</li>
<li>在新数组的地址赋值给变量<strong>arr</strong></li>
<li>原数组会在内存中被销毁（垃回收收）</li>
</ul>
<p><br /><strong>数据结构_链表：</strong></p>
<ul>
<li>	查询慢：链表中地址不是连续的，每次查询元素，都必须从头开始查询。</li>
<li>	增删快：链结构，增加/删除一个元素，对链的整体结构没有影响，所以增删快</li>


</ul>
<p>链表中的每一个元素也称之为一个节点<br /><strong>一个节点包含了一个数据源</strong>(存储数组)，两指针域(存储地址)</p>
<ul>
<li>	单向链：链中只有一条链，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）</li>
<li>	双向链：链中有两链，有一条链是专门记录元素的顺序，是一个有序的集合</li>


</ul>
<p><br /><strong>二叉树：</strong>分支不能超过两</p>
<ul>
<li>排序树/查找树：在二叉树的基础上，元素是有大小顺序的（左子树小，右子树大）</li>
<li>平衡树:左孩子和右孩子相等</li>
<li>不平衡树:左孩子和右孩子不相等</li>


</ul>
<p><strong>红黑树：</strong><br /><strong>特点：</strong>趋近于平衡树，查询的速度非常的快，查询叶子节点最大次数和最小次数不能超过2倍<br /><strong>约束：</strong></p>
<ol>
<li>节点可以是红色的或者是黑色的</li>
<li>根节点是黑色的</li>
<li>叶子节点（空节点）是黑色的</li>
<li>每个红色的节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相等</li>


</ol>
<h2><br />List接口</h2>
<div class="cnblogs_code">
<pre>java.util.list接口 <span style="color: #0000ff;">extends</span> Collection接口</pre>
</div>
<p>&nbsp;</p>
<p><strong>List接口的特点：</strong></p>
<ol>
<li>有序的集合，存储元素和取出元素的顺序是一致的（存储123 取出123）</li>
<li>有索引，包含了一些带索引的方法</li>
<li>允许存储重复的元素</li>
</ol>
<p><strong>List接口中带索引的方法（特有）：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index,E element):将指定的元素，添加到该集合中的指定位置上。
</span><span style="color: #0000ff;">public</span> E get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index):返回集合中指定位置的元素。
</span><span style="color: #0000ff;">public</span> E remove(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index):移除列表中指定位置的元素，返回的是被移除的元素。
</span><span style="color: #0000ff;">public</span> E set(<span style="color: #0000ff;">int</span> index,E element):用指定元素替换集合中指定位置的元素，返回值的更新前的元素。</pre>
</div>
<p><strong>注意：</strong><br />	<strong>操作索引的时候，一定要防止索引越界异常</strong></p>
<ul>
<li>IndexOutOfBoundsException:索引越界异常，集合会报</li>
<li>	ArrayIndexOutOfBoundsException:数组索引越界异常</li>
<li>	StringIndexOutOfBoundsException:字符串索引越界异常</li>


</ul>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">创建一个List集合对象，多态</span>
    List&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">public void add(int index,E element):将指定的元素，添加到该集合中的指定位置上。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">在索引2和索引3之间添加一个cainiao</span>
        list.add(3,"cainiao");<span style="color: #008000;">//</span><span style="color: #008000;">{a,b,c,d}--&gt;{a,b,c,cainiao,d}
        </span><span style="color: #008000;">//</span><span style="color: #008000;">移除元素</span>
        String removeE = list.remove(2<span style="color: #000000;">)
        </span><span style="color: #008000;">//</span><span style="color: #008000;">替换元素</span>
        String setE = list.set(4,"A"<span style="color: #000000;">);
        }</span></pre>
</div>
<p>&nbsp;</p>
<h2><br />List的子类</h2>
<ul>
<li><strong>ArrayList集合</strong></li>


</ul>
<p>java.util.ArrayList集合数据存储的结构是<strong>数组结构</strong>。<strong>元素增删慢，查找快</strong>，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</p>
<ul>
<li><strong>LinkedList集合</strong></li>


</ul>
<p>java.util.LinkedList集合数据存储的结构是<strong>链结构。方便元素添加，删除的集合。</strong></p>
<div class="cnblogs_code">
<pre>java.util.LinkedList集合 <span style="color: #0000ff;">implements</span> List接口</pre>
</div>
<p><strong> ArrayList集合的特点：</strong></p>
<ol>
<li>底层是一个链的结构：查询慢，增删快</li>
<li>里边包含了大量操作首尾元素的方法</li>
</ol>
<p><strong>注意：</strong><br />	使用ArrayList集合特有的方法，<strong>不能使用多态</strong></p>
<ul>
<li>	public void addFirst(E e):将指定元素插入此列表的开头</li>
<li>	public void addLast(E e):将指定元素添加到此列表的结尾</li>
<li>	public void addpush(E e):将元素推如此列表所表示的推栈</li>
<li></li>
<li>	public E getFirst():返回此列表的第一个元素。</li>
<li>	public E getLast():返回此列表的最后一个元素。</li>
<li></li>
<li>	public E removeFirst():移除并返回此列表的第一个元素。</li>
<li>	public E removeLast():移除并返回此列表的最后一个元素。</li>
<li>	public E pop():从此列表所表示的推栈处弹出一个元素。相当于removeFirst</li>
<li></li>
<li>	public boolean isEmpty():如果列表不包含元素，则返回true</li>


</ul>
<p>&nbsp;</p>
<h2>Vector集合</h2>
<p>Vector 类可以实现可<strong>增长的对象数组。</strong><br />与新collection不同，<strong>Vector是同步的。</strong></p>
<p>&nbsp;</p>
<h2>Set接口</h2>
<div class="cnblogs_code">
<pre>java.util.Set接口 <span style="color: #0000ff;">extends</span> Collection接口</pre>
</div>
<p><strong>Set接口的特点：</strong></p>
<ol>
<li>不允许存储<strong>重复的元素</strong></li>
<li>没有索引，<strong>没有带索引的方法</strong>，也不能使用普通的for循环遍历</li>
</ol>
<div class="cnblogs_code">
<pre>java.util.HashSet集合 <span style="color: #0000ff;">implements</span> Set接口</pre>
</div>
<p><strong>HashSet特点：</strong></p>
<ol>
<li>不允许存储重复的元素</li>
<li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li>
<li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li>
<li>底层是一个哈希表结构(查询的速度非常快)</li>
</ol>
<div class="cnblogs_code">
<pre>Set&lt;Integer&gt; set = <span style="color: #0000ff;">new</span> HashSet&lt;&gt;<span style="color: #000000;">();
</span><span style="color: #008000;">//</span><span style="color: #008000;">使用add方法往集合中添加元素</span>
set.add(1<span style="color: #000000;">);
set.add(</span>3<span style="color: #000000;">);
set.add(</span>2<span style="color: #000000;">);
set.add(</span>1<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">使用迭代器遍历Set集合</span>
Iterator&lt;Integer&gt; it =<span style="color: #000000;"> set.iterator();
</span><span style="color: #0000ff;">while</span><span style="color: #000000;">(it.hasNext(){
    Iterator n </span>=<span style="color: #000000;"> it.next();
    System.out.println(n);</span><span style="color: #008000;">//</span><span style="color: #008000;">1,2,3 无序且不重复</span>
}</pre>
</div>
<p>&nbsp;</p>
<h2>HashSet集合存储数据的结构（哈希表）</h2>
<p><strong>哈希值：</strong>是一个<strong>十进制的整数，由系统随机给出</strong>（就是对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址）<br />在Object类有一个方法，可以获取对象的哈希值</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> hashCode() 返回该对象的哈希码值。</pre>
</div>
<p>HashCode方法的源码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">native</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> hashCode();
</span><span style="color: #0000ff;">native</span>:代表该方法调用的是本地操作系的的方法</pre>
</div>
<p>&nbsp;</p>
<h2><br />哈希表</h2>
<p><strong>哈希表：</strong>hashSet集合存储数据的结构<br />jdk1.8版本之前：<strong>哈希表 = 数组+链表</strong><br />jdk1.8版本之后：</p>
<ul>
<li>	<strong>哈希表 = 数组+链表；</strong></li>
<li><strong>	哈希表 = 数组+红黑树（提高查询的速度）</strong></li>


</ul>
<p>哈希表的特点：<strong>速度快</strong></p>
<p>存储数据到集合中，先计算元素的哈希值</p>
<ul>
<li>	abc:96354 在数组的存储位置</li>
<li><strong>	重地&mdash;&mdash;通话：</strong>1179395 两元素不同，但是哈希值相同 哈希冲突</li>


</ul>
<p><br /><strong>数组结构：</strong>把元素进行了分组（相同哈希值的元素是一组）</p>
<p><strong>链表/红黑树结构：</strong>把相同哈希值的元素连到一起（如何链表的长度超过了8位，那么就会把链转换位红黑树（提高查询的速度））</p>
<p>&nbsp;</p>
<h2>Set集合存储元素不重复的原理</h2>
<p>Set集合存储元素不重复的元素的<strong>前提：</strong></p>
<p>	<strong>前提:</strong>存储的元素<strong>必须重写hashCode方法和equals方法</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">创建HashSet集合对象</span>
HashSet&lt;String&gt; set = <span style="color: #0000ff;">new</span> HashSet&lt;&gt;();<span style="color: #008000;">//</span><span style="color: #008000;">哈希表：数组+链表/红黑树 </span>
String s1 = <span style="color: #0000ff;">new</span> String("abc"<span style="color: #000000;">);
String s2 </span>= <span style="color: #0000ff;">new</span> String("abc"<span style="color: #000000;">);

set.add(s1);
set.add(s2);
set.add(</span>"重地"<span style="color: #000000;">);
set.add(</span>"通话"<span style="color: #000000;">);
set.add(</span>"abc"<span style="color: #000000;">);
System.out.println(set);</span>/[重地，通话，abc]</pre>
</div>
<p>&nbsp;</p>
<p><strong>原因：</strong><br /><strong>Set集合在调用add方法的时候，add方法会调用元素hashCode方法和equals方法，判断元素是否重复</strong></p>
<h2><br />HashSet存储自定义类型元素</h2>
<p><strong>Set集合报错元素原因：</strong><br />	存储的元素（String，Integer,...Student,Person...),必须重写hashCode方法和equals方法</p>
<h2>LinkedHashSet集合</h2>
<div class="cnblogs_code">
<pre>java.util.LinkedHashSet集合 <span style="color: #0000ff;">extends</span> HashSet集合</pre>
</div>
<p>&nbsp;</p>
<p><strong>LinkedHashSet集合特点:</strong><br />	底层是一个哈希表（<strong>数组+链表/红黑树+链表：</strong>多了一条链（记录元素的存储顺序），<strong>保存元素有序</strong><br />	</p>
<div class="cnblogs_code">
<pre>HashSet&lt;String&gt; set = <span style="color: #0000ff;">new</span> HashSet&lt;&gt;();<span style="color: #008000;">//</span><span style="color: #008000;">[]无序，不允许重复</span>
LinkedHashSet&lt;String&gt; set = <span style="color: #0000ff;">new</span> LinkedHashSet&lt;&gt;();[]<span style="color: #008000;">//</span><span style="color: #008000;">有序，不允许重复</span></pre>
</div>
<p>&nbsp;</p>
<h2><br />可变参数</h2>
<p><strong>可变参数：</strong>是JDK1.5 之后出现的新特性</p>
<p><strong>使用前提：</strong></p>
<ul>
<li>	当方法的<strong>参数列表数据类型已经确定，但是参数的个数不确</strong>定，就可以使用可变参数。</li>


</ul>
<p><strong>使用格式：</strong>定义方法时使用</p>
<ul>
<li>	修饰符 返回值类型 方法名（数据类型...变量名){}</li>


</ul>
<p><strong>可变参数的原理：</strong></p>
<ul>
<li>	可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数</li>
<li>	传递的参数个数，可以是0个 （不传递），1，2...多个</li>


</ul>
<p><br /><strong>可变参数的注意事项：</strong></p>
<ol>
<li>一个方法的参数列表，只能有一个可变参数</li>
<li>如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</li>


</ol>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> method(String b, <span style="color: #0000ff;">double</span> c ,<span style="color: #0000ff;">int</span> d ,<span style="color: #0000ff;">int</span><span style="color: #000000;">...a){}

</span><span style="color: #008000;">//</span><span style="color: #008000;">可变参数的特殊（终极）写法</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(Object...obj){}

Collections集合工具类的方法
java.util.Collections是集合工具类，用来对集合进行操作。部分方法如下：
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> &lt;T&gt; <span style="color: #0000ff;">void</span> sort(List&lt;T&gt; List ,Comparator&lt;? <span style="color: #0000ff;">super</span> T&gt;<span style="color: #000000;">):将集合中元素按照指定规则排序。
    
    Comparator和Comparable的区别
        Comparable：自己（</span><span style="color: #0000ff;">this</span><span style="color: #000000;">）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法
        Comparator:相当于找一个第三方的裁判，比较两
        
    Comparator的排序规则：
        o1</span>-o2:升序</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><br />Map集合</h2>
<p><strong>Collection接口:</strong> 定义了单列集合规范 Collection&lt;E&gt;</p>
<ul>
<li>	每次存储一个元素 单个元素</li>


</ul>
<p><strong>Map接口：</strong>定义了双列集合的规范 Map&lt;K,V&gt;</p>
<ul>
<li>	每次存储一对元素</li>


</ul>
<h2><br />java.util.Map&lt;K,V&gt;集合</h2>
<p><strong> Map集合的特点：</strong></p>
<ol>
<li>Map集合是一个<strong>双列集合</strong>，一个元素包含两值（一个key，一个value）</li>
<li>Map集合中的元素，key和value的数据类型<strong>可以相同，也可以不同</strong></li>
<li>Map集合中的元素，<strong>key是不允许重复的，value是可以重复的</strong></li>
<li>Map集合中的元素，key和value是<strong>一一对应的</strong></li>


</ol>
<div class="cnblogs_code">
<pre>java.util.HashMap&lt;K,V&gt;集合 <span style="color: #0000ff;">implements</span> Map&lt;K,V&gt;接口</pre>
</div>
<p><strong>HashMap集合的特点：</strong><br />	1.HashMap集合底层是哈希值：查询的速度特别的快</p>
<ul>
<li>		JDK.8之前：数组+单向链表</li>
<li>		JDK.8之后：数组+单向链表/红黑树<strong>（链表的长度超过8）</strong>：提高查询的速度</li>


</ul>
<p> 2.HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致</p>
<div class="cnblogs_code">
<pre>java.util.LinkedHashMap&lt;k,v&gt;集合 <span style="color: #0000ff;">extends</span> HashMap&lt;K,V&gt;集合</pre>
</div>
<p><strong>LinkedHashMap的特点：</strong></p>
<ol>
<li>LinkedHashMap集合底层是<strong>哈希表+链表（保证迭代的顺序）</strong></li>
<li>LinkedHashMap集合是一个<strong>有序的集合</strong>，存储元素和取出元素的顺序是一致的</li>
</ol>
<h2><br />Map接口中的常用方法</h2>
<p><strong>public V put (K key,V value):</strong>把指定的键与指定的值添加到Map集合中。</p>
<p><strong>	返回值：v</strong></p>
<ul>
<li>		存储键值对的时候，key不重复，返回值V是null</li>
<li>		存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值</li>


</ul>
<p><strong>public V remove（Object key）：</strong>把指定的值 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。<br /><strong>返回值：V</strong></p>
<ul>
<li>		key存在，v返回被删除的值</li>
<li>		key不存在，v返回null</li>


</ul>
<p><strong>public V get(Object key)</strong>根据指定的键，在Map集合中获取对应的值。<br /><strong>返回值：</strong></p>
<ul>
<li>		key存在，返回对应的value值</li>
<li>		key不存在，返回null</li>


</ul>
<p><br /><strong>boolean containsKey(Object key)</strong> 判断集合中是否包含指定的键</p>
<ul>
<li>包含返回true，不包含返回false</li>


</ul>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><strong>Map集合的第一种遍历方式：通过键找值的方式</strong></span></p>
<p><strong>Map集合中的方法：</strong></p>
<ul>
<li>	Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。</li>


</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li>使用Map集合中的方法<strong>keySet(),</strong>把Map集合所有的key取出来，存储到一个Set集合中。</li>
<li><strong>遍历Set集合</strong>，获取Map集合中的每一个Key</li>
<li>通过Map集合中的方法<strong>get（key），通</strong>过key找到value</li>


</ol>
<h2><br />Entry键值对对象</h2>
<p>Map.Entry&lt;K,V&gt;:在Map接口中有一个<strong>内部接口Entry</strong><br /><strong>作用：</strong>当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象,键与值的映射关系)</p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><strong>Map集合遍历的第二种方式：使用Entry对象遍历</strong></span></p>
<p><strong>	Set&lt;Map.Entry&lt;K,V&gt; entrySet()</strong> 返回此映射中包含的键的 Set 视图。<br /><strong>实现步骤：</strong></p>
<ol>
<li><strong>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():</strong> 把Map集合内部的多个Entry对象取出来存储到一个Set集合中</li>
<li><strong>遍历Set集合：</strong>获取Set集合中的每一个Enter对象</li>
<li>获取Entry对象中的方法：<strong>getKey()获取key，getValue() 获取value</strong></li>


</ol>
<p>&nbsp;</p>
<h2>HashMap存储自定义类型键值</h2>
<p><strong>key：</strong>Person类型</p>
<ul>
<li>	Person类型必须重写hashCode方法和equals方法，以保证key唯一</li>


</ul>
<p><strong>value：</strong>String类型</p>
<ul>
<li>	可以重复</li>


</ul>
<div class="cnblogs_code">
<pre>java.util.linkedHashMap&lt;K,V&gt; <span style="color: #0000ff;">extends</span> HashMap&lt;K,V&gt;</pre>
</div>
<p>&nbsp;</p>
<p>Map 接口的哈希表和链表列表实现，<strong>具有可预知的迭代顺序。</strong></p>
<p><strong>底层原理：</strong></p>
<ul>
<li>哈希表+链表（记录元素的顺序）</li>
</ul>
<h2><br />Hashtable集合</h2>
<div class="cnblogs_code">
<pre>java.util.Hashtable&lt;K,V&gt;集合 <span style="color: #0000ff;">implements</span> Map&lt;k,V&gt;接口</pre>
</div>
<p>&nbsp;</p>
<ul>
<li>Hashtable：底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢</li>
<li>HashMap：底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快</li>
<li>HashMap集合（之前学的所有集合）：可以存储null值，null键</li>
<li>Hashtable集合：不能存储null值，null键</li>
<li>Hashtable集合和Vector集合一样，在jdk1.2版本之后被更先进的集合（HashMap，ArrayList)取代了</li>
<li>Hashtable的子类properties依然活跃在历舞台</li>
<li>Properties集合是一个唯一和I/O流相结合的集合</li>
</ul>
<h2><br />练习：</h2>
<ul>
<li>	<strong>计算一个字符串中每一个字符出现的次数</strong></li>


</ul>
<p>分析：<br />	1.使用Scanner获取用户输入的字符串<br />	2.创建Map集合，key是字符串中的字符，value是字符的个数<br />	3.遍历字符串，获取每一个字符<br />	4.使用获取到的字符，去Map集合判断key是否存在</p>
<ul>
<li>		key存在：</li>


</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">通过字符（key），获取value（字符个数）
value</span>++<span style="color: #000000;">
put(key,value)把新的value存储到Map集合中</span></pre>
</div>
<p>&nbsp;</p>
<ul>
<li>Key不存在：</li>
</ul>
<div class="cnblogs_code">
<pre>put（key，1）</pre>
</div>
<p>&nbsp;</p>
<p><br />	5.遍历Map集合，输出结果</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">1.使用Scanner获取用户输入的字符串</span>
            Scanner sc = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
            System.out.println(</span>"请输入一个字符串："<span style="color: #000000;">);
            String str </span>=<span style="color: #000000;"> sc.next();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">2.创建Map集合，key是字符串中的字符，value是字符的个数</span>
            HashMap&lt;Character.Integer&gt; map = <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">3.遍历字符串，获取每一个字符</span>
            <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : str.toCharArray()){
                </span><span style="color: #008000;">//</span><span style="color: #008000;">4.使用获取到的字符，去Map集合判断key是否存在</span>
                <span style="color: #0000ff;">if</span><span style="color: #000000;">(map.containsKey(c)){
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">key存在 </span>
                    Integer value =<span style="color: #000000;"> map.get(c);
                    value</span>++<span style="color: #000000;">;
                    map.put(c,value);
                }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">key不存在 </span>
                    map.put(c,1<span style="color: #000000;">);
                }
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">5.遍历Map集合，输出结果</span>
            <span style="color: #0000ff;">for</span><span style="color: #000000;">(Character key : map.keySet(){
                Integer value </span>=<span style="color: #000000;"> map.get(key);
                System.out.println(key</span>+"="+<span style="color: #000000;">value);
            }    
        }
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>JDK9对集合添加的优化</h2>
<p><strong>JDK9的新特性：</strong></p>
<ul>
<li>list接口，Set接口，Map接口：里边增加了一个静态的方法of，可以给集合一次性添加多个元素</li>
<li>static &lt;E&gt; List&lt;E&gt; of (E... elements)</li>
</ul>
<p><strong> 使用前提：</strong></p>
<ul>
<li>当集合中存储的元素的个数已经确定了，不在改变时使用</li>
</ul>
<p><strong> 注意：</strong></p>
<ol>
<li>of方法只适用于list接口，set接口，Map接口，不适用于接口的实现类</li>
<li>2of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常</li>
<li>3Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常</li>
</ol>
<p>&nbsp;</p>
<h2>Debug追踪</h2>
<p><strong>Debug调试程序： </strong></p>
<ul>
<li>可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug</li>
</ul>
<p><strong>使用方式：</strong></p>
<ul>
<li>在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里）</li>
<li>右键，选择Debug执行程序</li>
<li>程序就会停留在添加的第一个断点处</li>
</ul>
<p><strong>执行程序：</strong></p>
<ul>
<li>f8:逐行执行程序</li>
<li>f7:进入到方法中</li>
<li>shift + f8:跳出方法</li>
<li>f9：跳到下一个断点，如果没有下一个断点，那么就结束程序</li>
<li>ctrl + f2：退出debug模式，停止程序</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><br />斗地主综合案例：有序版本（双列）</h2>
<ul>
<li>	1.准备牌</li>
<li>	2.洗牌</li>
<li>	3.发牌</li>
<li>	4.排序 </li>
<li>	5.看牌</li>


</ul>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201907/1444343-20190721230134614-1009942220.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.HashMap;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.List;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">1.准备牌
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个Map集合，存储牌的索引和组装好的牌</span>
    HashMap&lt;Integer,String&gt; poker = <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个List集合，存储花色和牌索引</span>
    ArrayList&lt;Integer&gt; pokerIndex = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义两个数组，一个数组存储牌的花色，一个数组存储牌的序号</span>
    String[] colors = {"?","?","?","??"<span style="color: #000000;">};
    String[] numbers </span>= {"2","A","K","Q","J","10","9","8","7","6","5","4","3"<span style="color: #000000;">};
    </span><span style="color: #008000;">//</span><span style="color: #008000;">先把大王和小王存储到集合中
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义一个牌的索引</span>
    <span style="color: #0000ff;">int</span> index = 0<span style="color: #000000;">;
    poker.put(index,</span>"大王"<span style="color: #000000;">);
    pokerIndex.add(index);
    index</span>++<span style="color: #000000;">;
    poker.put(index,</span>"小王"<span style="color: #000000;">);
    pokerIndex.add(index);
    index</span>++<span style="color: #000000;">;

    </span><span style="color: #008000;">//</span><span style="color: #008000;">循环嵌套遍历两个数组，组装52张牌</span>
    <span style="color: #0000ff;">for</span><span style="color: #000000;">(String numbers:numbers){
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String color : colors){
            poker.put(index.color</span>+<span style="color: #000000;">number);
            pokerIndex.add(index);
            index</span>++<span style="color: #000000;">;
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">    System.out.println(poker);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">    System.out.println(pokerIndex);</span>
    
    <span style="color: #008000;">/*</span><span style="color: #008000;">
    2.洗牌
    使用集合的工具类Collections中的方法
    static void shuffle(List&lt;?&gt; list) 使用默认的随机源对指定列表进行置换。
    
    </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    Collections.shuffle(poker);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println(poker)；</span>
    
    <span style="color: #008000;">/*</span><span style="color: #008000;">
    3.发牌
    </span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">定义4 个集合，存储玩家的牌和底牌</span>
    ArrayList&lt;String&gt; player01 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    ArrayList</span>&lt;String&gt; player02 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    ArrayList</span>&lt;String&gt; player03 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    ArrayList</span>&lt;String&gt; dipai = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
    遍历poker集合，获取每一张牌
    使用poker集合的索引%3给3个玩家轮流发牌
    剩余3张牌给底牌
    注意：
        先判断底牌(i&gt;51),否则牌就发没了
    
    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;poker.size();i++<span style="color: #000000;">){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取每一张牌</span>
        String p =<span style="color: #000000;"> poker.get(i);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">轮流发牌</span>
        <span style="color: #0000ff;">if</span>(i&gt;=51<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给底牌发牌</span>
<span style="color: #000000;">            diPai.add(p);
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i%3==0<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给玩家1发牌</span>
<span style="color: #000000;">            player01.add(p);
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i%3==1<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给玩家2发牌</span>
<span style="color: #000000;">            player02.add(p);
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(i%3==2<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给玩家3发牌</span>
<span style="color: #000000;">            player03.add(p);
        }
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
        4.排序
        使用Collectio中的方法sort(List)
        默认是升序排序
    </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    Collection.sort(player01);
    Collection.sort(player02);
    Collection.sort(player03);
    Collection.sort(dipai);
    
    
    
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5.看牌</span>
    lookpoker("刘德华："<span style="color: #000000;">,poker,player01);
    lookpoker(</span>"周润发："<span style="color: #000000;">,poker,player02);
    lookpoker(</span>"周星驰："<span style="color: #000000;">,poker,player03);
    lookpoker(</span>"底牌 ："<span style="color: #000000;">,poker,dipai);

    }
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
        定义一个看牌方法，提高代码的复用性
        参数：
            String name:玩家名称
            HashMap&lt;Integer，String&gt; poker:存储牌的poker集合
            ArrayList&lt;Integer&gt; List:存储玩家和底牌的list集合
        查表法：
            遍历玩家或者底牌集合，获取牌的索引
            使用牌的索引，去Map集合中，找到对应的牌

    </span><span style="color: #008000;">*/</span>
    
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> lookpoker(String name ,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt;<span style="color: #000000;"> list){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">输出玩家名称，不换行</span>
        System.out.println(name + "；"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历玩家或者底牌集合，获取牌的索引</span>
        <span style="color: #0000ff;">for</span><span style="color: #000000;">(Integer key : list){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">使用牌的索引，去Map集合中，找到对应的牌</span>
            String value =<span style="color: #000000;"> poker.get(key);
            System.out.println(value</span>+""<span style="color: #000000;">);
        }
        System.out.println();</span><span style="color: #008000;">//</span><span style="color: #008000;">打印完每一个玩家的牌，换行</span>
<span style="color: #000000;">    }
    

}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>斗地主综合案例：有序版本（双列）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223281.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 15:03:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223281.html</guid><description><![CDATA[<h2>斗地主综合案例：有序版本（双列）</h2>
<ul>
<li>1.准备牌</li>
<li>2.洗牌</li>
<li>3.发牌</li>
<li>4.排序</li>
<li>5.看牌</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201907/1444343-20190721230134614-1009942220.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>import<span> java.util.ArrayList;
import<span> java.util.HashMap;
import<span> java.util.List;

public class<span> CaiNiao{
    public static void<span> main(String[] args){
    //1.准备牌
    //创建一个Map集合，存储牌的索引和组装好的牌
    HashMap&lt;Integer,String&gt; poker = new HashMap&lt;&gt;<span>();    
    //创建一个List集合，存储花色和牌索引
    ArrayList&lt;Integer&gt; pokerIndex = new ArrayList&lt;&gt;<span>();
    //定义两个数组，一个数组存储牌的花色，一个数组存储牌的序号
    String[] colors = {"?","?","?","??"<span>};
    String[] numbers = {"2","A","K","Q","J","10","9","8","7","6","5","4","3"<span>};
    //先把大王和小王存储到集合中
    //定义一个牌的索引
    int index = 0<span>;
    poker.put(index,"大王"<span>);
    pokerIndex.add(index);
    index++<span>;
    poker.put(index,"小王"<span>);
    pokerIndex.add(index);
    index++<span>;

    //循环嵌套遍历两个数组，组装52张牌
    for<span>(String numbers:numbers){
        for<span> (String color : colors){
            poker.put(index.color+<span>number);
            pokerIndex.add(index);
            index++<span>;
        }
    }
    //    System.out.println(poker);
    //    System.out.println(pokerIndex);
    
    /*
    2.洗牌
    使用集合的工具类Collections中的方法
    static void shuffle(List&lt;?&gt; list) 使用默认的随机源对指定列表进行置换。
    
    */<span>
    Collections.shuffle(poker);
    //System.out.println(poker)；
    
    /*
    3.发牌
    */
    //定义4 个集合，存储玩家的牌和底牌
    ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;<span>();
    ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;<span>();
    ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;<span>();
    ArrayList&lt;String&gt; dipai = new ArrayList&lt;&gt;<span>();
    /*
    遍历poker集合，获取每一张牌
    使用poker集合的索引%3给3个玩家轮流发牌
    剩余3张牌给底牌
    注意：
        先判断底牌(i&gt;51),否则牌就发没了
    
    */
    for(int i = 0;i&lt;poker.size();i++<span>){
        //获取每一张牌
        String p =<span> poker.get(i);
        //轮流发牌
        if(i&gt;=51<span>){
            //给底牌发牌
<span>            diPai.add(p);
        }else if (i%3==0<span>){
            //给玩家1发牌
<span>            player01.add(p);
        }else if (i%3==1<span>){
            //给玩家2发牌
<span>            player02.add(p);
        }else if(i%3==2<span>){
            //给玩家3发牌
<span>            player03.add(p);
        }
    }
    
    /*
        4.排序
        使用Collectio中的方法sort(List)
        默认是升序排序
    */<span>
    Collection.sort(player01);
    Collection.sort(player02);
    Collection.sort(player03);
    Collection.sort(dipai);
    
    
    
        //5.看牌
    lookpoker("刘德华："<span>,poker,player01);
    lookpoker("周润发："<span>,poker,player02);
    lookpoker("周星驰："<span>,poker,player03);
    lookpoker("底牌 ："<span>,poker,dipai);

    }
    /*
        定义一个看牌方法，提高代码的复用性
        参数：
            String name:玩家名称
            HashMap&lt;Integer，String&gt; poker:存储牌的poker集合
            ArrayList&lt;Integer&gt; List:存储玩家和底牌的list集合
        查表法：
            遍历玩家或者底牌集合，获取牌的索引
            使用牌的索引，去Map集合中，找到对应的牌

    */
    
    public static void lookpoker(String name ,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt;<span> list){
        //输出玩家名称，不换行
        System.out.println(name + "；"<span>);
        //遍历玩家或者底牌集合，获取牌的索引
        for<span>(Integer key : list){
            //使用牌的索引，去Map集合中，找到对应的牌
            String value =<span> poker.get(key);
            System.out.println(value+""<span>);
        }
        System.out.println();//打印完每一个玩家的牌，换行
<span>    }
    

}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>JDK9对集合添加的优化</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223279.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 15:02:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223279.html</guid><description><![CDATA[<h2>JDK9对集合添加的优化</h2>
<p><strong>JDK9的新特性：</strong></p>
<ul>
<li>list接口，Set接口，Map接口：里边增加了一个静态的方法of，可以给集合一次性添加多个元素</li>
<li>static &lt;E&gt; List&lt;E&gt; of (E... elements)</li>
</ul>
<p><strong>使用前提：</strong></p>
<ul>
<li>当集合中存储的元素的个数已经确定了，不在改变时使用</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>of方法只适用于list接口，set接口，Map接口，不适用于接口的实现类</li>
<li>2of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常</li>
<li>3Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常</li>
</ol>]]></description></item><item><title>Java学习：Debug调试程序</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223262.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 14:56:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223262.html</guid><description><![CDATA[<h2>Debug追踪</h2>
<p><strong>Debug调试程序： </strong></p>
<ul>
<li>可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug</li>
</ul>
<p><strong>使用方式：</strong></p>
<ul>
<li>在行号的右边，鼠标左键单击，添加断点（每个方法的第一行，哪里有bug添加到哪里）</li>
<li>右键，选择Debug执行程序</li>
<li>程序就会停留在添加的第一个断点处</li>
</ul>
<p><strong>执行程序：</strong></p>
<ul>
<li>f8:逐行执行程序</li>
<li>f7:进入到方法中</li>
<li>shift + f8:跳出方法</li>
<li>f9：跳到下一个断点，如果没有下一个断点，那么就结束程序</li>
<li>ctrl + f2：退出debug模式，停止程序</li>
</ul>]]></description></item><item><title>计算一个字符串中每一个字符出现的次数</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223248.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 14:53:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223248.html</guid><description><![CDATA[<h2>练习：</h2>
<ul>
<li><strong>计算一个字符串中每一个字符出现的次数</strong></li>
</ul>
<p>分析：<br />1.使用Scanner获取用户输入的字符串<br />2.创建Map集合，key是字符串中的字符，value是字符的个数<br />3.遍历字符串，获取每一个字符<br />4.使用获取到的字符，去Map集合判断key是否存在</p>
<ul>
<li>key存在：</li>

</ul>
<div class="cnblogs_code">
<pre><span>通过字符（key），获取value（字符个数）
value++<span>
put(key,value)把新的value存储到Map集合中</span></span></pre>
</div>
<p>&nbsp;</p>
<ul>
<li>Key不存在：</li>
</ul>
<div class="cnblogs_code">
<pre>put（key，1）</pre>
</div>
<p>&nbsp;</p>
<p><br />5.遍历Map集合，输出结果</p>
<div class="cnblogs_code">
<pre>    public class<span> CaiNiao{
        public static void<span> main(String[] args){
            //1.使用Scanner获取用户输入的字符串
            Scanner sc = new<span> Scanner(System.in);
            System.out.println("请输入一个字符串："<span>);
            String str =<span> sc.next();
            //2.创建Map集合，key是字符串中的字符，value是字符的个数
            HashMap&lt;Character.Integer&gt; map = new HashMap&lt;&gt;<span>();
            //3.遍历字符串，获取每一个字符
            for(char<span> c : str.toCharArray()){
                //4.使用获取到的字符，去Map集合判断key是否存在
                if<span>(map.containsKey(c)){
                    //key存在 
                    Integer value =<span> map.get(c);
                    value++<span>;
                    map.put(c,value);
                }else<span>{
                    //key不存在 
                    map.put(c,1<span>);
                }
            }
            //5.遍历Map集合，输出结果
            for<span>(Character key : map.keySet(){
                Integer value =<span> map.get(key);
                System.out.println(key+"="+<span>value);
            }    
        }
    }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：Map接口</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223241.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 14:52:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223241.html</guid><description><![CDATA[<h2>Map集合</h2>
<p><strong>Collection接口:</strong>&nbsp;定义了单列集合规范 Collection&lt;E&gt;</p>
<ul>
<li>每次存储一个元素 单个元素</li>
</ul>
<p><strong>Map接口：</strong>定义了双列集合的规范 Map&lt;K,V&gt;</p>
<ul>
<li>每次存储一对元素</li>
</ul>
<h2><br />java.util.Map&lt;K,V&gt;集合</h2>
<p><strong>Map集合的特点：</strong></p>
<ol>
<li>Map集合是一个<strong>双列集合</strong>，一个元素包含两值（一个key，一个value）</li>
<li>Map集合中的元素，key和value的数据类型<strong>可以相同，也可以不同</strong></li>
<li>Map集合中的元素，<strong>key是不允许重复的，value是可以重复的</strong></li>
<li>Map集合中的元素，key和value是<strong>一一对应的</strong></li>

</ol>
<div class="cnblogs_code">
<pre>java.util.HashMap&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口</pre>
</div>
<p><strong>HashMap集合的特点：</strong><br />1.HashMap集合底层是哈希值：查询的速度特别的快</p>
<ul>
<li>JDK.8之前：数组+单向链表</li>
<li>JDK.8之后：数组+单向链表/红黑树<strong>（链表的长度超过8）</strong>：提高查询的速度</li>

</ul>
<p>2.HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致</p>
<div class="cnblogs_code">
<pre>java.util.LinkedHashMap&lt;k,v&gt;集合 extends HashMap&lt;K,V&gt;集合</pre>
</div>
<p><strong>LinkedHashMap的特点：</strong></p>
<ol>
<li>LinkedHashMap集合底层是<strong>哈希表+链表（保证迭代的顺序）</strong></li>
<li>LinkedHashMap集合是一个<strong>有序的集合</strong>，存储元素和取出元素的顺序是一致的</li>
</ol>
<h2><br />Map接口中的常用方法</h2>
<p><strong>public V put (K key,V value):</strong>把指定的键与指定的值添加到Map集合中。</p>
<p><strong>返回值：v</strong></p>
<ul>
<li>存储键值对的时候，key不重复，返回值V是null</li>
<li>存储键值对的时候，key重复，会使用新的value替换map中重复的value，返回被替换的value值</li>

</ul>
<p><strong>public V remove（Object key）：</strong>把指定的值 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。<br /><strong>返回值：V</strong></p>
<ul>
<li>key存在，v返回被删除的值</li>
<li>key不存在，v返回null</li>

</ul>
<p><strong>public V get(Object key)</strong>根据指定的键，在Map集合中获取对应的值。<br /><strong>返回值：</strong></p>
<ul>
<li>key存在，返回对应的value值</li>
<li>key不存在，返回null</li>

</ul>
<p><br /><strong>boolean containsKey(Object key)</strong>&nbsp;判断集合中是否包含指定的键</p>
<ul>
<li>包含返回true，不包含返回false</li>

</ul>
<p>&nbsp;</p>
<p><strong>Map集合的第一种遍历方式：通过键找值的方式</strong></p>
<p><strong>Map集合中的方法：</strong></p>
<ul>
<li>Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。</li>

</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li>使用Map集合中的方法<strong>keySet(),</strong>把Map集合所有的key取出来，存储到一个Set集合中。</li>
<li><strong>遍历Set集合</strong>，获取Map集合中的每一个Key</li>
<li>通过Map集合中的方法<strong>get（key），通</strong>过key找到value</li>

</ol>
<h2><br />Entry键值对对象</h2>
<p>Map.Entry&lt;K,V&gt;:在Map接口中有一个<strong>内部接口Entry</strong><br /><strong>作用：</strong>当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象,键与值的映射关系)</p>
<p>&nbsp;</p>
<p><strong>Map集合遍历的第二种方式：使用Entry对象遍历</strong></p>
<p><strong>Set&lt;Map.Entry&lt;K,V&gt; entrySet()</strong>&nbsp;返回此映射中包含的键的 Set 视图。<br /><strong>实现步骤：</strong></p>
<ol>
<li><strong>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():</strong>&nbsp;把Map集合内部的多个Entry对象取出来存储到一个Set集合中</li>
<li><strong>遍历Set集合：</strong>获取Set集合中的每一个Enter对象</li>
<li>获取Entry对象中的方法：<strong>getKey()获取key，getValue() 获取value</strong></li>

</ol>
<p>&nbsp;</p>
<h2>HashMap存储自定义类型键值</h2>
<p><strong>key：</strong>Person类型</p>
<ul>
<li>Person类型必须重写hashCode方法和equals方法，以保证key唯一</li>

</ul>
<p><strong>value：</strong>String类型</p>
<ul>
<li>可以重复</li>

</ul>
<div class="cnblogs_code">
<pre>java.util.linkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;</pre>
</div>
<p>&nbsp;</p>
<p>Map 接口的哈希表和链表列表实现，<strong>具有可预知的迭代顺序。</strong></p>
<p><strong>底层原理：</strong></p>
<ul>
<li>哈希表+链表（记录元素的顺序）</li>
</ul>
<h2><br />Hashtable集合</h2>
<div class="cnblogs_code">
<pre>java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;k,V&gt;接口</pre>
</div>
<p>&nbsp;</p>
<ul>
<li>Hashtable：底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢</li>
<li>HashMap：底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快</li>
<li>HashMap集合（之前学的所有集合）：可以存储null值，null键</li>
<li>Hashtable集合：不能存储null值，null键</li>
<li>Hashtable集合和Vector集合一样，在jdk1.2版本之后被更先进的集合（HashMap，ArrayList)取代了</li>
<li>Hashtable的子类properties依然活跃在历舞台</li>
<li>Properties集合是一个唯一和I/O流相结合的集合</li>
<li></li>
</ul>]]></description></item><item><title>Java学习：可变参数</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223173.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 14:39:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223173.html</guid><description><![CDATA[<h1>可变参数</h1>
<p>可变参数：是JDK1.5 之后出现的新特性</p>
<p>使用前提：</p>
<ul>
<li>当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数。</li>
</ul>
<p>使用格式：定义方法时使用</p>
<ul>
<li>修饰符 返回值类型 方法名（数据类型...变量名){}</li>
</ul>
<p>可变参数的原理：</p>
<ul>
<li>可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数</li>
<li>传递的参数个数，可以是0个 （不传递），1，2...多个</li>
</ul>
<p>&nbsp;</p>
<p>可变参数的注意事项：</p>
<ol>
<li>一个方法的参数列表，只能有一个可变参数</li>
<li>如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</li>
</ol>
<pre>public static void method(String b, double c ,int d ,int...a){}
//可变参数的特殊（终极）写法
public static void method(Object...obj){}
Collections集合工具类的方法
java.util.Collections是集合工具类，用来对集合进行操作。部分方法如下：
    public static &lt;T&gt; void sort(List&lt;T&gt; List ,Comparator&lt;? super T&gt;):将集合中元素按照指定规则排序。
    
    Comparator和Comparable的区别
        Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法
        Comparator:相当于找一个第三方的裁判，比较两
        
    Comparator的排序规则：
        o1-o2:升序
</pre>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：Set接口与HashSet集合存储数据的结构（哈希表）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223170.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 14:38:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223170.html</guid><description><![CDATA[<h2>Set接口</h2>
<div class="cnblogs_code">
<pre>java.util.Set接口 extends Collection接口</pre>
</div>
<p><strong>Set接口的特点：</strong></p>
<ol>
<li>不允许存储<strong>重复的元素</strong></li>
<li>没有索引，<strong>没有带索引的方法</strong>，也不能使用普通的for循环遍历</li>
</ol>
<div class="cnblogs_code">
<pre>java.util.HashSet集合 implements Set接口</pre>
</div>
<p><strong>HashSet特点：</strong></p>
<ol>
<li>不允许存储重复的元素</li>
<li>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</li>
<li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li>
<li>底层是一个哈希表结构(查询的速度非常快)</li>
</ol>
<div class="cnblogs_code">
<pre>Set&lt;Integer&gt; set = new HashSet&lt;&gt;<span>();
//使用add方法往集合中添加元素
set.add(1<span>);
set.add(3<span>);
set.add(2<span>);
set.add(1<span>);
//使用迭代器遍历Set集合
Iterator&lt;Integer&gt; it =<span> set.iterator();
while<span>(it.hasNext(){
    Iterator n =<span> it.next();
    System.out.println(n);//1,2,3 无序且不重复
}</span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<h2>HashSet集合存储数据的结构（哈希表）</h2>
<p><strong>哈希值：</strong>是一个<strong>十进制的整数，由系统随机给出</strong>（就是对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址）<br />在Object类有一个方法，可以获取对象的哈希值</p>
<div class="cnblogs_code">
<pre>int hashCode() 返回该对象的哈希码值。</pre>
</div>
<p>HashCode方法的源码：</p>
<div class="cnblogs_code">
<pre>public native int<span> hashCode();
native:代表该方法调用的是本地操作系的的方法</span></pre>
</div>
<p>&nbsp;</p>
<h2><br />哈希表</h2>
<p><strong>哈希表：</strong>hashSet集合存储数据的结构<br />jdk1.8版本之前：<strong>哈希表 = 数组+链表</strong><br />jdk1.8版本之后：</p>
<ul>
<li><strong>哈希表 = 数组+链表；</strong></li>
<li><strong>哈希表 = 数组+红黑树（提高查询的速度）</strong></li>

</ul>
<p>哈希表的特点：<strong>速度快</strong></p>
<p>存储数据到集合中，先计算元素的哈希值</p>
<ul>
<li>abc:96354 在数组的存储位置</li>
<li><strong>重地&mdash;&mdash;通话：</strong>1179395 两元素不同，但是哈希值相同 哈希冲突</li>

</ul>
<p><br /><strong>数组结构：</strong>把元素进行了分组（相同哈希值的元素是一组）</p>
<p><strong>链表/红黑树结构：</strong>把相同哈希值的元素连到一起（如何链表的长度超过了8位，那么就会把链转换位红黑树（提高查询的速度））</p>
<p>&nbsp;</p>
<h2>Set集合存储元素不重复的原理</h2>
<p>Set集合存储元素不重复的元素的<strong>前提：</strong></p>
<p><strong>前提:</strong>存储的元素<strong>必须重写hashCode方法和equals方法</strong></p>
<div class="cnblogs_code">
<pre>//创建HashSet集合对象
HashSet&lt;String&gt; set = new HashSet&lt;&gt;();//哈希表：数组+链表/红黑树 
String s1 = new String("abc"<span>);
String s2 = new String("abc"<span>);

set.add(s1);
set.add(s2);
set.add("重地"<span>);
set.add("通话"<span>);
set.add("abc"<span>);
System.out.println(set);/[重地，通话，abc]</span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p><strong>原因：</strong><br /><strong>Set集合在调用add方法的时候，add方法会调用元素hashCode方法和equals方法，判断元素是否重复</strong></p>
<h2><br />HashSet存储自定义类型元素</h2>
<p><strong>Set集合报错元素原因：</strong><br />存储的元素（String，Integer,...Student,Person...),必须重写hashCode方法和equals方法</p>
<h2>LinkedHashSet集合</h2>
<div class="cnblogs_code">
<pre>java.util.LinkedHashSet集合 extends HashSet集合</pre>
</div>
<p>&nbsp;</p>
<p><strong>LinkedHashSet集合特点:</strong><br />底层是一个哈希表（<strong>数组+链表/红黑树+链表：</strong>多了一条链（记录元素的存储顺序），<strong>保存元素有序</strong></p>
<div class="cnblogs_code">
<pre>HashSet&lt;String&gt; set = new HashSet&lt;&gt;();//[]无序，不允许重复
LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;&gt;();[]//有序，不允许重复</pre>
</div>
<p>&nbsp;</p>
<h2><br />可变参数</h2>
<p><strong>可变参数：</strong>是JDK1.5 之后出现的新特性</p>
<p><strong>使用前提：</strong></p>
<ul>
<li>当方法的<strong>参数列表数据类型已经确定，但是参数的个数不确</strong>定，就可以使用可变参数。</li>

</ul>
<p><strong>使用格式：</strong>定义方法时使用</p>
<ul>
<li>修饰符 返回值类型 方法名（数据类型...变量名){}</li>

</ul>
<p><strong>可变参数的原理：</strong></p>
<ul>
<li>可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数</li>
<li>传递的参数个数，可以是0个 （不传递），1，2...多个</li>

</ul>
<p><br /><strong>可变参数的注意事项：</strong></p>
<ol>
<li>一个方法的参数列表，只能有一个可变参数</li>
<li>如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</li>

</ol>
<div class="cnblogs_code">
<pre>public static void method(String b, double c ,int d ,int<span>...a){}

//可变参数的特殊（终极）写法
public static void<span> method(Object...obj){}

Collections集合工具类的方法
java.util.Collections是集合工具类，用来对集合进行操作。部分方法如下：
    public static &lt;T&gt; void sort(List&lt;T&gt; List ,Comparator&lt;? super T&gt;<span>):将集合中元素按照指定规则排序。
    
    Comparator和Comparable的区别
        Comparable：自己（this<span>）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法
        Comparator:相当于找一个第三方的裁判，比较两
        
    Comparator的排序规则：
        o1-o2:升序</span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：List接口</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223151.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 14:35:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223151.html</guid><description><![CDATA[<h2><br />List接口</h2>
<div class="cnblogs_code">
<pre>java.util.list接口 extends Collection接口</pre>
</div>
<p>&nbsp;</p>
<p><strong>List接口的特点：</strong></p>
<ol>
<li>有序的集合，存储元素和取出元素的顺序是一致的（存储123 取出123）</li>
<li>有索引，包含了一些带索引的方法</li>
<li>允许存储重复的元素</li>
</ol>
<p><strong>List接口中带索引的方法（特有）：</strong></p>
<div class="cnblogs_code">
<pre>public void add(int<span> index,E element):将指定的元素，添加到该集合中的指定位置上。
public E get(int<span> index):返回集合中指定位置的元素。
public E remove(int<span> index):移除列表中指定位置的元素，返回的是被移除的元素。
public E set(int index,E element):用指定元素替换集合中指定位置的元素，返回值的更新前的元素。</span></span></span></pre>
</div>
<p><strong>注意：</strong><br /><strong>操作索引的时候，一定要防止索引越界异常</strong></p>
<ul>
<li>IndexOutOfBoundsException:索引越界异常，集合会报</li>
<li>ArrayIndexOutOfBoundsException:数组索引越界异常</li>
<li>StringIndexOutOfBoundsException:字符串索引越界异常</li>

</ul>
<div class="cnblogs_code">
<pre>//创建一个List集合对象，多态
    List&lt;String&gt; list = new ArrayList&lt;&gt;<span>();
    {
        //public void add(int index,E element):将指定的元素，添加到该集合中的指定位置上。
        //在索引2和索引3之间添加一个cainiao
        list.add(3,"cainiao");//{a,b,c,d}--&gt;{a,b,c,cainiao,d}
        //移除元素
        String removeE = list.remove(2<span>)
        //替换元素
        String setE = list.set(4,"A"<span>);
        }</span></span></span></pre>
</div>
<p>&nbsp;</p>
<h2><br />List的子类</h2>
<ul>
<li><strong>ArrayList集合</strong></li>

</ul>
<p>java.util.ArrayList集合数据存储的结构是<strong>数组结构</strong>。<strong>元素增删慢，查找快</strong>，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</p>
<ul>
<li><strong>LinkedList集合</strong></li>

</ul>
<p>java.util.LinkedList集合数据存储的结构是<strong>链结构。方便元素添加，删除的集合。</strong></p>
<div class="cnblogs_code">
<pre>java.util.LinkedList集合 implements List接口</pre>
</div>
<p><strong>ArrayList集合的特点：</strong></p>
<ol>
<li>底层是一个链的结构：查询慢，增删快</li>
<li>里边包含了大量操作首尾元素的方法</li>
</ol>
<p><strong>注意：</strong><br />使用ArrayList集合特有的方法，<strong>不能使用多态</strong></p>
<ul>
<li>public void addFirst(E e):将指定元素插入此列表的开头</li>
<li>public void addLast(E e):将指定元素添加到此列表的结尾</li>
<li>public void addpush(E e):将元素推如此列表所表示的推栈</li>
<li></li>
<li>public E getFirst():返回此列表的第一个元素。</li>
<li>public E getLast():返回此列表的最后一个元素。</li>
<li></li>
<li>public E removeFirst():移除并返回此列表的第一个元素。</li>
<li>public E removeLast():移除并返回此列表的最后一个元素。</li>
<li>public E pop():从此列表所表示的推栈处弹出一个元素。相当于removeFirst</li>
<li></li>
<li>public boolean isEmpty():如果列表不包含元素，则返回true</li>

</ul>
<p>&nbsp;</p>
<h2>Vector集合</h2>
<p>Vector 类可以实现可<strong>增长的对象数组。</strong><br />与新collection不同，<strong>Vector是同步的。</strong></p>]]></description></item><item><title>Java学习：数据结构简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223084.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 21 Jul 2019 14:20:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/21/11223084.html</guid><description><![CDATA[<h2>数据结构</h2>
<p><strong>数据结构：</strong></p>
<p><strong>数据结构_栈</strong>：先进后出</p>
<ul>
<li>入口和出口在同一侧</li>
</ul>
<p><strong>数据结构_队列：</strong>先进先出</p>
<ul>
<li>入口和出口在集合的两侧</li>
</ul>
<p><strong>数据结构_数组：</strong></p>
<ul>
<li>查询快：数组的地址是连续的，我们通过数组的首地址可以找到数组，通过数组的索引可以快速的查找某一个元素。</li>
<li>增删慢：数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个新数组，把原数组的数据复制过来</li>
</ul>
<div class="cnblogs_code">
<pre><span>例：
int[] arr = new int[]{1,2,3,4};</span></pre>
</div>
<p>要把数组索引是3的元素删除</p>
<ul>
<li>必须创建一个新的数组，<strong>长度是原数组的长度-1</strong></li>
<li>把原数组的其它元素复制到新数组中</li>
<li>在新数组的地址赋值给变量<strong>arr</strong></li>
<li>原数组会在内存中被销毁（垃回收收）</li>
</ul>
<p><br /><strong>数据结构_链表：</strong></p>
<ul>
<li>查询慢：链表中地址不是连续的，每次查询元素，都必须从头开始查询。</li>
<li>增删快：链结构，增加/删除一个元素，对链的整体结构没有影响，所以增删快</li>

</ul>
<p>链表中的每一个元素也称之为一个节点<br /><strong>一个节点包含了一个数据源</strong>(存储数组)，两指针域(存储地址)</p>
<ul>
<li>单向链：链中只有一条链，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）</li>
<li>双向链：链中有两链，有一条链是专门记录元素的顺序，是一个有序的集合</li>

</ul>
<p><br /><strong>二叉树：</strong>分支不能超过两</p>
<ul>
<li>排序树/查找树：在二叉树的基础上，元素是有大小顺序的（左子树小，右子树大）</li>
<li>平衡树:左孩子和右孩子相等</li>
<li>不平衡树:左孩子和右孩子不相等</li>

</ul>
<p><strong>红黑树：</strong><br /><strong>特点：</strong>趋近于平衡树，查询的速度非常的快，查询叶子节点最大次数和最小次数不能超过2倍<br /><strong>约束：</strong></p>
<ol><ol>
<li>节点可以是红色的或者是黑色的</li>
<li>根节点是黑色的</li>
<li>叶子节点（空节点）是黑色的</li>
<li>每个红色的节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相等</li>

</ol></ol>]]></description></item><item><title>集合单列--Colletion</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216058.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 19 Jul 2019 14:30:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216058.html</guid><description><![CDATA[<h1 style="text-align: center;">&nbsp;集合</h1>
<p><strong>学习集合的目标：</strong></p>
<ol>
<li>会使用集合存储数据</li>
<li>会遍历集合，把数据取出来</li>
<li><strong>掌</strong>握每种集合的特性</li>
</ol>
<p><strong>集合和数组的区别</strong></p>
<ol>
<li>数组的长度是<strong>固定</strong>的。集合的长度是<strong>可变</strong>的。</li>
<li>数组中存储的是<strong>同一类型</strong>的元素，可以存储基本数据类型值。集合存储的都是<strong>对象</strong>。而且<strong>对象的类型可以不一致</strong>，在开发中一般当对象多的时候使用集合进行存储。</li>
</ol>
<h2>集合框架</h2>
<p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两，分别是<strong>单列集合 java.util.Collection</strong>和<strong>双列集合java.util.Map,</strong></p>
<p>&nbsp;</p>
<h2>Collection</h2>
<p>Collection：<strong>单列集合类的根接口，</strong>用于存储一系列符合某种规则的元素。</p>
<p>它有两个重要的子接口，分别是<strong>java.util.List和java.util.Set。</strong></p>
<p>其中，</p>
<ul>
<li>List的特点是元素有序、元素可重复。</li>
<li>Set的特点是元素无序，而且不可重复。</li>
</ul>
<p><strong>List接口</strong>的主要实现类有：</p>
<div class="cnblogs_code">
<pre><span>java.util.ArrayList
java.util.LinkedList</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>Set接口</strong>的主要实现类有：</p>
<div class="cnblogs_code">
<pre><span>java.util.HashSet
java.util.TreeSet</span></pre>
</div>
<p>&nbsp;</p>
<p>如图所示：</p>
<p><strong><img src="https://img2018.cnblogs.com/blog/1444343/201907/1444343-20190719220531951-383517640.png" alt="" /></strong></p>
<h2>Collection常用功能</h2>
<p>Collection是<strong>所有单列集合的父接口，</strong>因此在Collection中定义了<strong>单列集合（List和Set）</strong>通用的一些方法，这些方法可用于操作所有的单列集合。</p>
<p>方法如下：</p>
<div class="cnblogs_code">
<pre>public boolean<span> add(E e):把给定的对象添加到当前集合中。
public void<span> clear():清空集合中所有的元素。
public boolean<span> remove(E e):把给定的对象在当前集合中删除。
public boolean<span> contains(E e):判断当前集合中是否包含给定的对象。
public boolean<span> isEmpty():判断当前集合是否为空。
public int<span> size():返回集合中元素的个数。
public Object[] toArray():把集合中的元素，存储到数组中。</span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>迭代器</h2>
<p>java.util.Iterator接口：迭代器<strong>（对集合进行遍历）</strong></p>
<p>有两个常用的方法</p>
<ul>
<li><strong> boolean hasNext()</strong> 如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>判断集合中还有没有下一个元素，有就返回true，没有就返回false。</p>
<ul>
<li><strong> E next()</strong> 返回迭代的下一个元素</li>
</ul>
<p> 取出集合中的下一个元素<br /><br />Iterator迭代器<strong>，是一个接口</strong>，我们无法直接使用，需要使用Iterator<strong>接口的实现类对象</strong>，获取实现类的方式比较特殊</p>
<p>Collection接口中有一个方法，叫<strong>iterator(),</strong>这个方法返回的就是迭代器的实现类对象</p>
<ul>
<li>	Iterator&lt;E&gt; interator() 返回在此 collection的元素上进行迭代的迭代器。</li>




</ul>
<p><br /><strong>	迭代器的使用步骤（重点）：</strong></p>
<ol>
<li>使用集合中的方法<strong>iterator()获取迭代器的实现类对象</strong>，<strong>使用Iterator接口Iterator接口接受（多态）</strong></li>
<li>使用Iterator接口中的方法<strong>hasNext判断</strong>还没有没有下一个元素</li>
<li>使用Iterator接口中的方法<strong>next取出</strong>集合中的下一个元素</li>




</ol>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">创建一个集合对象    </span>
Collection&lt;String&gt; coll = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
</span><span style="color: #008000;">//</span><span style="color: #008000;">向集合中添加元素</span>
coll.add("cai"<span style="color: #000000;">);
coll.add(</span>"niao"<span style="color: #000000;">);
</span><span style="color: #008000;">/*</span><span style="color: #008000;">
1.使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口Iterator接口接收（多态）

注意：
    Iterator&lt;E&gt;接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型

</span><span style="color: #008000;">*/</span>
<span style="color: #008000;">//</span><span style="color: #008000;">多态 接口 实现类对象</span>
Iterator&lt;String&gt; it =<span style="color: #000000;"> cool.interator
</span><span style="color: #0000ff;">while</span>(it.hasNext()){<span style="color: #008000;">//</span><span style="color: #008000;">判断集合有没有下一个元素，从-1开始</span>
    String e = it.next();<span style="color: #008000;">//</span><span style="color: #008000;">取出下一个元素并把指针后移一位</span>
<span style="color: #000000;">    System.out.println(e);
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>增强for循环</h2>
<p>增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写<br /><strong>是JDK1.5之后出现的新特性</strong></p>
<ul>
<li>Collection&lt;E&gt; extends Iterator&lt;E&gt;:所有的单列集合都可以使用增强for</li>
<li>public interface Iterable&lt;T&gt; 实现这个接口允许对象成为&ldquo;foreach&rdquo;语句目标。</li>




</ul>
<p>增强for循环：<strong>用来遍历集合和数组</strong></p>
<p><strong>格式</strong>：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">for</span> (集合/数组的数据类型 变量名 : 集合名/<span style="color: #000000;">数组名){
　　System.out.println(变量名)；
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>泛型</h2>
<p>泛型：<strong>是一种未知的数据类型，</strong>当我们不知道使用什么数据类型的时候，可以使用泛型</p>
<p>泛型也可以看出是一个<strong>变量，用来接受数据类型</strong></p>
<ul>
<li>E e ： Element 元素</li>
<li>T t : Type 类型</li>
</ul>
<p>ArrayList集合在定义的时候，不知道集合中都会存储什么类型的数据，所以类型使用泛型</p>
<ul>
<li><strong>E：未知的数据类型</strong></li>
</ul>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ArrayList&lt;E&gt;<span style="color: #000000;">{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(E e){}
    </span><span style="color: #0000ff;">public</span> E get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index){}
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ArrayList&lt;String&gt;<span style="color: #000000;">{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> add(String e){}<span style="color: #008000;">//</span><span style="color: #008000;">会把数据类型作为参数传递，把String赋值给泛型</span>
    <span style="color: #0000ff;">public</span> String get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index){}
}</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>创建集合对象，使用泛型</strong><br /><strong>好处：</strong></p>
<ol>
<li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li>
<li>把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候会报错）</li>




</ol>
<p><strong>弊端：</strong></p>
<ol>
<li>	泛型是什么类型，只能存储什么类型的数据</li>




</ol>
<p><strong>创建集合对象，不使用泛型</strong><br /><strong>好处：</strong></p>
<ol>
<li>	集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据</li>




</ol>
<p><strong>弊端:</strong></p>
<ol>
<li>	不安全，会引发异常</li>




</ol>
<h2><br />定义和使用泛型的类</h2>
<p>定义含有泛型的方法：泛型定义在方法的<strong>修饰符和返回值类型之间</strong></p>
<p>格式：</p>
<div class="cnblogs_code">
<pre>修饰符 &lt;泛型&gt;<span style="color: #000000;"> 返回值类型 方法名（参数列表（使用泛型））{
　　方法体；
}</span></pre>
</div>
<p>&nbsp;</p>
<p>含有泛型的方法，在调用方法的时候确定泛型的数据类型<br /><strong>传递什么类型的参数，泛型就是什么类型</strong></p>
<p><br />含有泛型的接口，<strong>第一种使用方式：</strong>定义接口的实现类，实现接口，指定接口的泛型</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> Iterator&lt;E&gt;<span style="color: #000000;">{
    E next();
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br />Scanner类实现了Iterator接口，并指定接口的泛型为String，所以重写的next方法泛型默认就是String</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span> Scanner <span style="color: #0000ff;">implements</span> Iterator&lt;String&gt;<span style="color: #000000;">{
　　publc String next(){}
}</span></pre>
</div>
<p>&nbsp;</p>
<p>含有泛型的接口<strong>第二种使用方式：</strong>接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</p>
<p>就相当于定义一个含有泛型的类，创建对象的时候确定泛型的类型</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> List&lt;E&gt;<span style="color: #000000;">{
    </span><span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(E e);
    E get (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> index);
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ArrayList&lt;E&gt; <span style="color: #0000ff;">implements</span> List&lt;E&gt;<span style="color: #000000;">{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> add(E e){}
    </span><span style="color: #0000ff;">public</span> E get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index){}
}</span></pre>
</div>
<p>&nbsp;</p>
<h2><br />泛型的通配符</h2>
<p>泛型的通配符：</p>
<ul>
<li><strong>	？：代表任意的数据类型</strong></li>




</ul>
<p>使用方式：</p>
<ul>
<li>	不能创建对象使用</li>
<li>	只能作为方法的参数使用</li>




</ul>
<p>泛型的上限限定:<strong>? extends E</strong> 代表使用的泛型只能是E类型的子类/本身<br />泛型的下限限定:<strong>? super E</strong> 代表使用的泛型只能是E类型的父类/本身</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">泛型的上限：此时的泛型？，必须是Number类型或者Number类型的子类</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> getElement1(Collection&lt;？ <span style="color: #0000ff;">extends</span> Number&gt;<span style="color: #000000;"> coll){}
</span><span style="color: #008000;">//</span><span style="color: #008000;">泛型的下限：此时的泛型？，必须是Number类型或者Number类型的父类</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> getElement2(Collection&lt;？ <span style="color: #0000ff;">super</span> Number&gt; coll){}</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>斗地主案例的代码实现（单列）</h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Collection;

</span><span style="color: #008000;">/*</span><span style="color: #008000;">  
斗地主综合案例：
    1.准备牌
    2.洗牌
    3.发配
    4.看牌
</span><span style="color: #008000;">*/</span>

<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">1.准备牌
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义一个存储54张牌的ArrayList集合，泛型使用String</span>
    ArrayList&lt;String&gt; poker = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义两个数组，一个数组存储牌的花色，一个数组存储牌的序号</span>
    String[] colors = {"&hearts;","&diams;","&clubs;","🍄"<span style="color: #000000;">};
    String[] numbers </span>= {"2","A","K","Q","J","10","9","8","7","6","5","4","3"<span style="color: #000000;">};
    </span><span style="color: #008000;">//</span><span style="color: #008000;">先把大王和小王存储到poker集合中</span>
    poker.add("大王"<span style="color: #000000;">);
    poker.add(</span>"小王"<span style="color: #000000;">);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">循环嵌套遍历两个数组，组装52张牌</span>
    <span style="color: #0000ff;">for</span><span style="color: #000000;">(String numbers:numbers){
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String color : colors){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println(color + numbers);
            </span><span style="color: #008000;">//</span><span style="color: #008000;">把组装好的牌存储到poker集合中</span>
            poker.add(color +<span style="color: #000000;"> number);
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">    System.out.println(poker);</span>
    <span style="color: #008000;">/*</span><span style="color: #008000;">
    2.洗牌
    使用集合的工具类Collections中的方法
    static void shuffle(List&lt;?&gt; list) 使用默认的随机源对指定列表进行置换。
    
    </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    Collections.shuffle(poker);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">System.out.println(poker)；</span>
    <span style="color: #008000;">/*</span><span style="color: #008000;">
    3.发牌
    </span><span style="color: #008000;">*/</span>
    <span style="color: #008000;">//</span><span style="color: #008000;">定义4 个集合，存储玩家的牌和底牌</span>
    ArrayList&lt;String&gt; player01 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    ArrayList</span>&lt;String&gt; player02 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    ArrayList</span>&lt;String&gt; player03 = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    ArrayList</span>&lt;String&gt; dipai = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">
    遍历poker集合，获取每一张牌
    使用poker集合的索引%3给3个玩家轮流发牌
    剩余3张牌给底牌
    注意：
        先判断底牌(i&gt;51),否则牌就发没了
    
    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;poker.size();i++<span style="color: #000000;">){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取每一张牌</span>
        String p =<span style="color: #000000;"> poker.get(i);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">轮流发牌</span>
        <span style="color: #0000ff;">if</span>(i&gt;=51<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给底牌发牌</span>
<span style="color: #000000;">            diPai.add(p);
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i%3==0<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给玩家1发牌</span>
<span style="color: #000000;">            player01.add(p);
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i%3==1<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给玩家2发牌</span>
<span style="color: #000000;">            player02.add(p);
        }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(i%3==2<span style="color: #000000;">){
            </span><span style="color: #008000;">//</span><span style="color: #008000;">给玩家3发牌</span>
<span style="color: #000000;">            player03.add(p);
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">4.看牌</span>
    System.out.println("刘德华："+<span style="color: #000000;">player01);
    System.out.println(</span>"周润发："+<span style="color: #000000;">player02);
    System.out.println(</span>"周星驰："+<span style="color: #000000;">player03);
    System.out.println(</span>"底牌 ："+<span style="color: #000000;">dipai);
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>斗地主案例的代码实现（单列）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216046.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 19 Jul 2019 14:28:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216046.html</guid><description><![CDATA[<h2>斗地主案例的代码实现（单列）</h2>
<div class="cnblogs_code">
<pre>import<span> java.util.ArrayList;
import<span> java.util.Collection;

/*  
斗地主综合案例：
    1.准备牌
    2.洗牌
    3.发配
    4.看牌
*/

public class<span> CaiNiao{
    public static void<span> main(String[] args){
    //1.准备牌
    //定义一个存储54张牌的ArrayList集合，泛型使用String
    ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;<span>();
    //定义两个数组，一个数组存储牌的花色，一个数组存储牌的序号
    String[] colors = {"&hearts;","&diams;","&clubs;","&spades;"<span>};
    String[] numbers = {"2","A","K","Q","J","10","9","8","7","6","5","4","3"<span>};
    //先把大王和小王存储到poker集合中
    poker.add("大王"<span>);
    poker.add("小王"<span>);
    //循环嵌套遍历两个数组，组装52张牌
    for<span>(String numbers:numbers){
        for<span> (String color : colors){
            //System.out.println(color + numbers);
            //把组装好的牌存储到poker集合中
            poker.add(color +<span> number);
        }
    }
    //    System.out.println(poker);
    /*
    2.洗牌
    使用集合的工具类Collections中的方法
    static void shuffle(List&lt;?&gt; list) 使用默认的随机源对指定列表进行置换。
    
    */<span>
    Collections.shuffle(poker);
    //System.out.println(poker)；
    /*
    3.发牌
    */
    //定义4 个集合，存储玩家的牌和底牌
    ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;<span>();
    ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;<span>();
    ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;<span>();
    ArrayList&lt;String&gt; dipai = new ArrayList&lt;&gt;<span>();
    /*
    遍历poker集合，获取每一张牌
    使用poker集合的索引%3给3个玩家轮流发牌
    剩余3张牌给底牌
    注意：
        先判断底牌(i&gt;51),否则牌就发没了
    
    */
    for(int i = 0;i&lt;poker.size();i++<span>){
        //获取每一张牌
        String p =<span> poker.get(i);
        //轮流发牌
        if(i&gt;=51<span>){
            //给底牌发牌
<span>            diPai.add(p);
        }else if (i%3==0<span>){
            //给玩家1发牌
<span>            player01.add(p);
        }else if (i%3==1<span>){
            //给玩家2发牌
<span>            player02.add(p);
        }else if(i%3==2<span>){
            //给玩家3发牌
<span>            player03.add(p);
        }
    }
    //4.看牌
    System.out.println("刘德华："+<span>player01);
    System.out.println("周润发："+<span>player02);
    System.out.println("周星驰："+<span>player03);
    System.out.println("底牌 ："+<span>dipai);
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：泛型简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216032.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 19 Jul 2019 14:23:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216032.html</guid><description><![CDATA[<h2>泛型</h2>
<p>泛型：<strong>是一种未知的数据类型，</strong>当我们不知道使用什么数据类型的时候，可以使用泛型</p>
<p>泛型也可以看出是一个<strong>变量，用来接受数据类型</strong></p>
<ul>
<li>E e ： Element 元素</li>
<li>T t : Type 类型</li>
</ul>
<p>ArrayList集合在定义的时候，不知道集合中都会存储什么类型的数据，所以类型使用泛型</p>
<ul>
<li><strong>E：未知的数据类型</strong></li>
</ul>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>public class ArrayList&lt;E&gt;<span>{
    public boolean<span> add(E e){}
    public E get(int<span> index){}
}

public class ArrayList&lt;String&gt;<span>{
    public boolean add(String e){}//会把数据类型作为参数传递，把String赋值给泛型
    public String get(int<span> index){}
}</span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p><strong>创建集合对象，使用泛型</strong><br /><strong>好处：</strong></p>
<ol>
<li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li>
<li>把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候会报错）</li>

</ol>
<p><strong>弊端：</strong></p>
<ol>
<li>泛型是什么类型，只能存储什么类型的数据</li>

</ol>
<p><strong>创建集合对象，不使用泛型</strong><br /><strong>好处：</strong></p>
<ol>
<li>集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据</li>

</ol>
<p><strong>弊端:</strong></p>
<ol>
<li>不安全，会引发异常</li>

</ol>
<h2><br />定义和使用泛型的类</h2>
<p>定义含有泛型的方法：泛型定义在方法的<strong>修饰符和返回值类型之间</strong></p>
<p>格式：</p>
<div class="cnblogs_code">
<pre>修饰符 &lt;泛型&gt;<span> 返回值类型 方法名（参数列表（使用泛型））{
　　方法体；
}</span></pre>
</div>
<p>&nbsp;</p>
<p>含有泛型的方法，在调用方法的时候确定泛型的数据类型<br /><strong>传递什么类型的参数，泛型就是什么类型</strong></p>
<p><br />含有泛型的接口，<strong>第一种使用方式：</strong>定义接口的实现类，实现接口，指定接口的泛型</p>
<div class="cnblogs_code">
<pre>public interface Iterator&lt;E&gt;<span>{
    E next();
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br />Scanner类实现了Iterator接口，并指定接口的泛型为String，所以重写的next方法泛型默认就是String</p>
<div class="cnblogs_code">
<pre>public final class Scanner implements Iterator&lt;String&gt;<span>{
　　publc String next(){}
}</span></pre>
</div>
<p>&nbsp;</p>
<p>含有泛型的接口<strong>第二种使用方式：</strong>接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</p>
<p>就相当于定义一个含有泛型的类，创建对象的时候确定泛型的类型</p>
<div class="cnblogs_code">
<pre>public interface List&lt;E&gt;<span>{
    boolean<span> add(E e);
    E get (int<span> index);
}

public class ArrayList&lt;E&gt; implements List&lt;E&gt;<span>{
    public boolean<span> add(E e){}
    public E get(int<span> index){}
}</span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<h2><br />泛型的通配符</h2>
<p>泛型的通配符：</p>
<ul>
<li><strong>？：代表任意的数据类型</strong></li>

</ul>
<p>使用方式：</p>
<ul>
<li>不能创建对象使用</li>
<li>只能作为方法的参数使用</li>

</ul>
<p>泛型的上限限定:<strong>? extends E</strong>&nbsp;代表使用的泛型只能是E类型的子类/本身<br />泛型的下限限定:<strong>? super E</strong>&nbsp;代表使用的泛型只能是E类型的父类/本身</p>
<div class="cnblogs_code">
<pre>//泛型的上限：此时的泛型？，必须是Number类型或者Number类型的子类
public static void getElement1(Collection&lt;？ extends Number&gt;<span> coll){}
//泛型的下限：此时的泛型？，必须是Number类型或者Number类型的父类
public static void getElement2(Collection&lt;？ super Number&gt; coll){}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：迭代器简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216004.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 19 Jul 2019 14:16:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11216004.html</guid><description><![CDATA[<h2>迭代器</h2>
<p>java.util.Iterator接口：迭代器<strong>（对集合进行遍历）</strong></p>
<p>有两个常用的方法</p>
<ul>
<li><strong>boolean hasNext()</strong>&nbsp;如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>判断集合中还有没有下一个元素，有就返回true，没有就返回false。</p>
<ul>
<li><strong>E next()</strong>&nbsp;返回迭代的下一个元素</li>
</ul>
<p>取出集合中的下一个元素<br /><br />Iterator迭代器<strong>，是一个接口</strong>，我们无法直接使用，需要使用Iterator<strong>接口的实现类对象</strong>，获取实现类的方式比较特殊</p>
<p>Collection接口中有一个方法，叫<strong>iterator(),</strong>这个方法返回的就是迭代器的实现类对象</p>
<ul>
<li>Iterator&lt;E&gt; interator() 返回在此 collection的元素上进行迭代的迭代器。</li>

</ul>
<p><br /><strong>迭代器的使用步骤（重点）：</strong></p>
<ol>
<li>使用集合中的方法<strong>iterator()获取迭代器的实现类对象</strong>，<strong>使用Iterator接口Iterator接口接受（多态）</strong></li>
<li>使用Iterator接口中的方法<strong>hasNext判断</strong>还没有没有下一个元素</li>
<li>使用Iterator接口中的方法<strong>next取出</strong>集合中的下一个元素</li>

</ol>
<div class="cnblogs_code">
<pre>//创建一个集合对象    
Collection&lt;String&gt; coll = new<span> ArrayList();
//向集合中添加元素
coll.add("cai"<span>);
coll.add("niao"<span>);
/*
1.使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口Iterator接口接收（多态）

注意：
    Iterator&lt;E&gt;接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型

*/
//多态 接口 实现类对象
Iterator&lt;String&gt; it =<span> cool.interator
while(it.hasNext()){//判断集合有没有下一个元素，从-1开始
    String e = it.next();//取出下一个元素并把指针后移一位
<span>    System.out.println(e);
}</span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>增强for循环</h2>
<p>增强for循环：底层使用的也是迭代器，使用for循环的格式，简化了迭代器的书写<br /><strong>是JDK1.5之后出现的新特性</strong></p>
<ul>
<li>Collection&lt;E&gt; extends Iterator&lt;E&gt;:所有的单列集合都可以使用增强for</li>
<li>public interface Iterable&lt;T&gt; 实现这个接口允许对象成为&ldquo;foreach&rdquo;语句目标。</li>

</ul>
<p>增强for循环：<strong>用来遍历集合和数组</strong></p>
<p><strong>格式</strong>：</p>
<div class="cnblogs_code">
<pre>for (集合/数组的数据类型 变量名 : 集合名/<span>数组名){
　　System.out.println(变量名)；
}</span></pre>
</div>]]></description></item><item><title>Java学习：单列集合Collection</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11215984.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 19 Jul 2019 14:11:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/19/11215984.html</guid><description><![CDATA[<h2>集合</h2>
<p><strong>学习集合的目标：</strong></p>
<ol>
<li>会使用集合存储数据</li>
<li>会遍历集合，把数据取出来</li>
<li><strong>掌</strong>握每种集合的特性</li>
</ol>
<p><strong>集合和数组的区别</strong></p>
<ol>
<li>数组的长度是<strong>固定</strong>的。集合的长度是<strong>可变</strong>的。</li>
<li>数组中存储的是<strong>同一类型</strong>的元素，可以存储基本数据类型值。集合存储的都是<strong>对象</strong>。而且<strong>对象的类型可以不一致</strong>，在开发中一般当对象多的时候使用集合进行存储。</li>
</ol>
<h2>集合框架</h2>
<p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两，分别是<strong>单列集合 java.util.Collection</strong>和<strong>双列集合java.util.Map,</strong></p>
<p>&nbsp;</p>
<h2>Collection</h2>
<p>Collection：<strong>单列集合类的根接口，</strong>用于存储一系列符合某种规则的元素。</p>
<p>它有两个重要的子接口，分别是<strong>java.util.List和java.util.Set。</strong></p>
<p>其中，</p>
<ul>
<li>List的特点是元素有序、元素可重复。</li>
<li>Set的特点是元素无序，而且不可重复。</li>
</ul>
<p><strong>List接口</strong>的主要实现类有：</p>
<div class="cnblogs_code">
<pre><span>java.util.ArrayList
java.util.LinkedList</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>Set接口</strong>的主要实现类有：</p>
<div class="cnblogs_code">
<pre><span>java.util.HashSet
java.util.TreeSet</span></pre>
</div>
<p>&nbsp;</p>
<p>如图所示：</p>
<p><strong><img src="https://img2018.cnblogs.com/blog/1444343/201907/1444343-20190719220531951-383517640.png" alt="" /></strong></p>
<h2>Collection常用功能</h2>
<p>Collection是<strong>所有单列集合的父接口，</strong>因此在Collection中定义了<strong>单列集合（List和Set）</strong>通用的一些方法，这些方法可用于操作所有的单列集合。</p>
<p>方法如下：</p>
<div class="cnblogs_code">
<pre>public boolean<span> add(E e):把给定的对象添加到当前集合中。
public void<span> clear():清空集合中所有的元素。
public boolean<span> remove(E e):把给定的对象在当前集合中删除。
public boolean<span> contains(E e):判断当前集合中是否包含给定的对象。
public boolean<span> isEmpty():判断当前集合是否为空。
public int<span> size():返回集合中元素的个数。
public Object[] toArray():把集合中的元素，存储到数组中。</span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>基本类型与字符串类型之间的相互转换</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210377.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 18 Jul 2019 14:13:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210377.html</guid><description><![CDATA[<h2><strong>基本类型与字符串类型之间的相互转换</strong></h2>
<p><strong>基本类型-&gt;字符串（String）</strong></p>
<p>1.基本类型的值<strong>+""</strong>&nbsp;最简单的方法（工作中常用）<br />2.包装类的静态方法<strong>toString(参数)</strong>，是Object类的toString()重载</p>
<ul>
<li>static String toString(int i) ：返回一个表示指定整数的String对象。</li>

</ul>
<p>3.String类的静态方法<strong>valueOf(参数)</strong></p>
<ul>
<li>static String valueOf(int i) ：返回int参数的字符串表示形式。</li>

</ul>
<p><strong>字符串(String)-&gt;基本类型</strong><br />使用包装类的静态方法parseXXX("字符串");</p>
<ul>
<ul>
<li><strong>Integer类</strong>：static int parseInt(String s)</li>
<li><strong>Double类：</strong>static double parseDouble(String s)</li>

</ul>
</ul>]]></description></item><item><title>Java的常用API</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210381.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 18 Jul 2019 14:13:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210381.html</guid><description><![CDATA[<h2>Object类</h2>
<p><strong>1.toString方法</strong><br />在我们直接使用输出语句输出对象的时候，其实通过该对象调用了其toString()方法。</p>
<p><strong>2.equals方法</strong><br /><strong>方法摘要：</strong><br />类默认继承了Object类，所以可以使用Object类的equals方法<br />boolean equals(Object obj)指示其他某个对象是否与此对象<strong>&ldquo;相等&rdquo;</strong>。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">equalse方法源码：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> equals(Object obj){
    </span><span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">this</span> ==<span style="color: #000000;"> obj);
}</span></pre>
</div>
<p><strong>参数：</strong></p>
<ul>
<li>Object obj:可以传递任意的对象</li>
<li>== 比较运算符，返回的是一个布尔值 true false</li>
<li>基本数据类型：比较的是值</li>
<li>引用数据类型：计较的是两个对象的地址值　</li>
</ul>
<p>&nbsp;</p>
<h2>Data类</h2>
<p>java.util.Date:表示<strong>日期和时间</strong>的类<br />类Date 表示<strong>特定的瞬间，精确到毫秒。</strong><br />毫秒：千分之一秒 1000毫秒=1秒</p>
<p>把日期转换成毫秒：</p>
<ul>
<li>	当前的日期:2019-07-18</li>
<li><strong>	时间原点（0毫秒）：1970-01-01 00：00：00（英国格林威治）</strong></li>
<li>	就是计算当前日期到时间原点之间一共经历了多少毫秒</li>




</ul>
<p><strong>注意：</strong><br />中国属于东八区，会把时间<strong>增加8个小时</strong></p>
<ul>
<li>1970-01-01 08：00：00</li>




</ul>
<p>把毫秒转换为日期：</p>
<ul>
<li>	1天 = 24*60*60 = 86400秒 = 86400*1000=86400000毫秒</li>




</ul>
<p><strong>使用：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Date类的带参数构造方法
Date date </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
Date();</span><span style="color: #008000;">//</span><span style="color: #008000;">获取当前系统的时间和日期</span>
---------<span style="color: #000000;">
Date date </span>= <span style="color: #0000ff;">new</span> Date(0L<span style="color: #000000;">);
Date(</span><span style="color: #0000ff;">long</span> date);<span style="color: #008000;">//</span><span style="color: #008000;">传递毫秒值，把毫秒值转化成Date日期</span>
-----------<span style="color: #000000;">
Date date </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
</span><span style="color: #0000ff;">long</span> time =<span style="color: #000000;"> date.getTime();
</span><span style="color: #0000ff;">long</span><span style="color: #000000;"> getTime() 把日期转换成毫秒(相当于System.currentTimeMillis()方法)
返回自1970年1月1日 </span>00-00-00GMT 以来此Date 对象表示的毫秒数。</pre>
</div>
<p>&nbsp;</p>
<h2>&nbsp;</h2>
<h2>DateFormat类</h2>
<p>java.text.DateFormat:是<strong>日期/时间格式化</strong>子类的抽象类</p>
<p><strong>作用：</strong></p>
<ul>
<li>格式化（也就是日期 -&gt; 文本），解析（文本-&gt;日期）</li>
</ul>
<p><strong>成员方法：</strong></p>
<ul>
<li>String format(Date date) 按照指定的模式，把Date日期，格式化为符合模式的字符串</li>
<li>Date parse(String source) 把符合模式的字符串，解析为Date日期</li>
<li>DateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat类的子类</li>
</ul>
<div class="cnblogs_code">
<pre>java.text.SimpleDateFormat <span style="color: #0000ff;">extends</span> DateFormat</pre>
</div>
<p>&nbsp;</p>
<p>使用DateFormat类中的<strong>方法format，把日期格式化为文本</strong></p>
<p><strong>使用步骤:</strong></p>
<ol>
<li>创建simpleDateFormat对象，构造方法中传递指定的模式</li>
<li>调用SimpleDateFormat对象中的方法format，按照构造方法指定的模式，把Date日期格式化为符合模式的字符串<strong>（文本）</strong></li>
</ol>
<div class="cnblogs_code">
<pre>SimpleDateFormat sdf = <span style="color: #0000ff;">new</span> SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒"<span style="color: #000000;">);
Date date </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
String d </span>= sdf.format(date);</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Calendar类</h2>
<p><strong>介绍：</strong><br />java.util.Calendar类；<strong>日历类</strong></p>
<ul>
<li>Calendar类是一个抽象类，里边提供了很多操作日历字段的方法<strong>（YEAR、MONTH、DAY_OF_MONTH、HOUR)</strong></li>
<li>Calendar类无法直接创建对象使用，里边有一个静态方法叫<strong>getInstance(),</strong>该方法返回了Calendar类的子类对象</li>
<li>static Calendar getInstance() 使用默认时区和语言环境获得一个日历。</li>




</ul>
<div class="cnblogs_code">
<pre>Calendar c = Calendar.getInstance();<span style="color: #008000;">//</span><span style="color: #008000;">多态</span></pre>
</div>
<p>&nbsp;</p>
<p>Calendar类的<strong>常用成员方法：</strong></p>
<ul>
<li>public int get(int field);返回给定日历字段的值。</li>
<li>public void set(int field,int value);将给定的日历字段设置为给定值</li>
<li>public abstract void add(int field, int amount);根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li>public Data getTime();返回一个表示次Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">public int get(int field);返回给定日历字段的值。</span>
Calendar c =<span style="color: #000000;"> Calendar.getInstance();
</span><span style="color: #0000ff;">int</span> year =<span style="color: #000000;"> c.get(Calendar.YEAR);
</span><span style="color: #0000ff;">int</span> month =<span style="color: #000000;"> c.get(Calendar.MONTH);

</span><span style="color: #008000;">//</span><span style="color: #008000;">/public void set(int field,int value);将给定的日历字段设置为给定值
</span><span style="color: #008000;">//</span><span style="color: #008000;">设置年为9999
</span><span style="color: #008000;">//</span><span style="color: #008000;">设置月为9月</span>
c.set(Calendar.YEAR,9999<span style="color: #000000;">);
c.set(Calendar.MONTH,</span>9<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;">增加年</span>
c.add(Calendar.YEAR,2<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;">把日历对象，转换为日期对象</span>
Date date=c.getTime();</pre>
</div>
<p>&nbsp;</p>
<h2><br />Syetem类</h2>
<p>java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有；</p>
<ul>
<li>	public static long<strong> currentTimeMillis();</strong>返回以毫秒为单位的当前时间。</li>
<li>	public static void arraycopy(<strong>Object src, int srcPos, Object dest, int destPos, int Length</strong>);将数组中指定的数据拷贝到另一个数组中。</li>




</ul>
<p><strong>参数：</strong></p>
<ul>
<li>	src - 源数据</li>
<li>	srcPos - 源数据中的起始位置（起始索引）。</li>
<li>	dest - 目标数组。</li>
<li>	destPos - 目标数据中的起始位置</li>
<li>	Length - 要复制的数组元素的数量。</li>




</ul>
<h2>StringBuilder类</h2>
<p><strong>StringBuilder类</strong></p>
<p><strong> 字符串缓冲区</strong>，可以提高字符串的操作效率（看成一个<strong>长度可以变化</strong>的字符串）<br />	底层也是一个数组，但是没有被final修饰，可以改变长度</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">byte</span>[] value = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[16];</pre>
</div>
<p> StringBuilder在内存中始终是一个<strong>数组</strong>，占用空间少，效率高<br />	如果超出了StringBuilder的容量，<strong>会自动的扩展。</strong></p>
<p>&nbsp;</p>
<p><strong>比较与：String类</strong><br />	字符串是<strong>常量</strong>；它们的值在创建之后<strong>不能更改。</strong><br />	字符串的底层是一个被<strong>final修饰的数组</strong>，不能改变，是一个常量</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">byte</span>[] value;</pre>
</div>
<p>进行字符串的相加，内存中就会有多少个字符串，占用空间多 <strong>，效率低下</strong></p>
<p>&nbsp;</p>
<p>java.lang.StringBuilder类：<strong>字符串缓冲区</strong>，可以提高字符串的效率<br /><strong>构造方法:</strong></p>
<ul>
<li>		StringBuilder()构造一个不带任何字符的字符串生成器，其初始容量为16个字符。</li>
<li>		StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。</li>




</ul>
<p><strong>StringBuilder的常用方法：</strong></p>
<ul>
<li>	public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象自身。</li>




</ul>
<p><strong>StringBuilder和String可以相互转换；</strong></p>
<ul>
<li>String -&gt; StringBuilder:可以使用StringBuilder的构造方法</li>
<li>
<div class="cnblogs_code">
<pre>StringBuilder(String str)</pre>
</div>
<p>&nbsp;</p>
</li>
<li>StringBuilder-&gt; String:可以使用StringBuilder中的toString方法</li>
<li>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> String toString();&nbsp;</pre>
</div>
</li>
</ul>
<p>&nbsp;</p>
<h2><strong>包装类</strong></h2>
<p><strong>包装类：</strong></p>
<p> 基本数据类型，使用起来非常方便，但是没有对应的方法来操作这些基本类型的数据<br />	可以使用一个类，<strong>把基本类型的数据装起来，</strong>在类中定义一些方法，这个类叫做包装类，<br />	我们可以使用类中的方法来操作这些基本类型的数据。<br /><br /><strong>装箱：</strong>把基本类型的数据，包装到包装类中（基本类型的数据-&gt;包装类）<br />	<strong>构造方法：</strong></p>
<ul>
<li>		Integer(int value)构造一个新分配的 Integer对象，它表示指定的 int值。</li>
<li>		Integer(String s)构造一个新分配的 Integer对象， 它表示String参数所指示的 int值。</li>




</ul>
<p>			传递的字符串，必须是<strong>基本类型的字符串</strong>，否则会抛出异常"<strong>100"正确 "a"抛异常</strong><br /><strong>静态方法：</strong></p>
<ul>
<li>		static Integer valueOf(int i)返回一个表示指定的int值的Integer实例。</li>
<li>		static Integer valueOf(String s)返回保存指定的String的值的Integer对象。</li>




</ul>
<p><br /><strong>拆箱：</strong>在包装类中取出基本类型的数据（包装类-&gt;基本类型的数据）<br /><strong>成员方法：</strong></p>
<ul>
<li>		int intValue()以int 类型返回该Integer的值。</li>




</ul>
<p><br /><strong>自动装箱和自动拆箱：</strong>基本类型的数据和包装类之间可以自动的相互转换<br /><strong>JDK1.5 之后出现的新特性</strong></p>
<p><strong>自动装箱：</strong>直接把int类型的整数赋值包装类</p>
<ul>
<li>Integer in = 1； 就相当于 Integer in = new Integer(1);</li>




</ul>
<p><strong>自动拆箱：</strong>in是包装类，无法直接参与运算，可以自动转换为基本数据类型，在进行计算</p>
<ul>
<li>int + 2;就相当于 in.inVale() + 2=3</li>




</ul>
<p><strong>in = in.intVale() + 2 = 3 又是一个自动装箱</strong></p>
<p><strong>注意：</strong></p>
<ul>
<li>ArrayList集合无法直接存储整数，可以存储Integer包装类</li>
<li>list.add(1);--&gt;自动装箱 list.add(new Integer(1));</li>
<li>int a = list.get(0);//--&gt;自动拆箱 list.get(0).intValue();</li>




</ul>
<p>&nbsp;</p>
<h2><strong>基本类型与字符串类型之间的相互转换</strong></h2>
<p><strong>基本类型-&gt;字符串（String）</strong></p>
<p>	1.基本类型的值<strong>+""</strong> 最简单的方法（工作中常用）<br />	2.包装类的静态方法<strong>toString(参数)</strong>，是Object类的toString()重载</p>
<ul>
<li>		static String toString(int i) ：返回一个表示指定整数的String对象。</li>




</ul>
<p>	3.String类的静态方法<strong>valueOf(参数)</strong></p>
<ul>
<li>		static String valueOf(int i) ：返回int参数的字符串表示形式。</li>




</ul>
<p><strong>	字符串(String)-&gt;基本类型</strong><br />		使用包装类的静态方法parseXXX("字符串");</p>
<ul>
<li><strong>			Integer类</strong>：static int parseInt(String s)</li>
<li><strong>			Double类：</strong>static double parseDouble(String s)</li>




</ul>
<p>&nbsp;</p>]]></description></item><item><title>Java的常用API之包装类简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210367.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 18 Jul 2019 14:12:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210367.html</guid><description><![CDATA[<h2><strong>包装类</strong></h2>
<p><strong>包装类：</strong></p>
<p>基本数据类型，使用起来非常方便，但是没有对应的方法来操作这些基本类型的数据<br />可以使用一个类，<strong>把基本类型的数据装起来，</strong>在类中定义一些方法，这个类叫做包装类，<br />我们可以使用类中的方法来操作这些基本类型的数据。<br /><br /><strong>装箱：</strong>把基本类型的数据，包装到包装类中（基本类型的数据-&gt;包装类）<br /><strong>构造方法：</strong></p>
<ul>
<li>Integer(int value)构造一个新分配的 Integer对象，它表示指定的 int值。</li>
<li>Integer(String s)构造一个新分配的 Integer对象， 它表示String参数所指示的 int值。</li>

</ul>
<p>传递的字符串，必须是<strong>基本类型的字符串</strong>，否则会抛出异常"<strong>100"正确 "a"抛异常</strong><br /><strong>静态方法：</strong></p>
<ul>
<li>static Integer valueOf(int i)返回一个表示指定的int值的Integer实例。</li>
<li>static Integer valueOf(String s)返回保存指定的String的值的Integer对象。</li>

</ul>
<p><br /><strong>拆箱：</strong>在包装类中取出基本类型的数据（包装类-&gt;基本类型的数据）<br /><strong>成员方法：</strong></p>
<ul>
<li>int intValue()以int 类型返回该Integer的值。</li>

</ul>
<p><br /><strong>自动装箱和自动拆箱：</strong>基本类型的数据和包装类之间可以自动的相互转换<br /><strong>JDK1.5 之后出现的新特性</strong></p>
<p><strong>自动装箱：</strong>直接把int类型的整数赋值包装类</p>
<ul>
<li>Integer in = 1； 就相当于 Integer in = new Integer(1);</li>

</ul>
<p><strong>自动拆箱：</strong>in是包装类，无法直接参与运算，可以自动转换为基本数据类型，在进行计算</p>
<ul>
<li>int + 2;就相当于 in.inVale() + 2=3</li>

</ul>
<p><strong>in = in.intVale() + 2 = 3 又是一个自动装箱</strong></p>
<p><strong>注意：</strong></p>
<ul>
<ul>
<li>ArrayList集合无法直接存储整数，可以存储Integer包装类</li>
<li>list.add(1);--&gt;自动装箱 list.add(new Integer(1));</li>
<li>int a = list.get(0);//--&gt;自动拆箱 list.get(0).intValue();</li>

</ul>
</ul>]]></description></item><item><title>Java的常用API之System类简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210359.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 18 Jul 2019 14:09:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210359.html</guid><description><![CDATA[<h2>Syetem类</h2>
<p>java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有；</p>
<ul>
<li>public static long<strong>&nbsp;currentTimeMillis();</strong>返回以毫秒为单位的当前时间。</li>
<li>public static void arraycopy(<strong>Object src, int srcPos, Object dest, int destPos, int Length</strong>);将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p><strong>参数：</strong></p>
<ul>
<li>src - 源数据</li>
<li>srcPos - 源数据中的起始位置（起始索引）。</li>
<li>dest - 目标数组。</li>
<li>destPos - 目标数据中的起始位置</li>
<li>Length - 要复制的数组元素的数量。</li>
</ul>
<h2>StringBuilder类</h2>
<p><strong>StringBuilder类</strong></p>
<p><strong>字符串缓冲区</strong>，可以提高字符串的操作效率（看成一个<strong>长度可以变化</strong>的字符串）<br />底层也是一个数组，但是没有被final修饰，可以改变长度</p>
<div class="cnblogs_code">
<pre>byte[] value = new byte[16];</pre>
</div>
<p>StringBuilder在内存中始终是一个<strong>数组</strong>，占用空间少，效率高<br />如果超出了StringBuilder的容量，<strong>会自动的扩展。</strong></p>
<p>&nbsp;</p>
<p><strong>比较与：String类</strong><br />字符串是<strong>常量</strong>；它们的值在创建之后<strong>不能更改。</strong><br />字符串的底层是一个被<strong>final修饰的数组</strong>，不能改变，是一个常量</p>
<div class="cnblogs_code">
<pre>private final byte[] value;</pre>
</div>
<p>进行字符串的相加，内存中就会有多少个字符串，占用空间多&nbsp;<strong>，效率低下</strong></p>
<p>&nbsp;</p>
<p>java.lang.StringBuilder类：<strong>字符串缓冲区</strong>，可以提高字符串的效率<br /><strong>构造方法:</strong></p>
<ul>
<li>StringBuilder()构造一个不带任何字符的字符串生成器，其初始容量为16个字符。</li>
<li>StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。</li>

</ul>
<p><strong>StringBuilder的常用方法：</strong></p>
<ul>
<li>public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象自身。</li>

</ul>
<p><strong>StringBuilder和String可以相互转换；</strong></p>
<ul>
<li>String -&gt; StringBuilder:可以使用StringBuilder的构造方法</li>
<li>
<div class="cnblogs_code">
<pre>StringBuilder(String str)</pre>
</div>
</li>
<li>StringBuilder-&gt; String:可以使用StringBuilder中的toString方法</li>
<li>
<div class="cnblogs_code">
<pre>public String toString();&nbsp;</pre>
</div>
</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>Java的常用API之Date类简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210341.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 18 Jul 2019 14:06:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210341.html</guid><description><![CDATA[<h2>Data类</h2>
<p>java.util.Date:表示<strong>日期和时间</strong>的类<br />类Date 表示<strong>特定的瞬间，精确到毫秒。</strong><br />毫秒：千分之一秒 1000毫秒=1秒</p>
<p>把日期转换成毫秒：</p>
<ul>
<li>当前的日期:2019-07-18</li>
<li><strong>时间原点（0毫秒）：1970-01-01 00：00：00（英国格林威治）</strong></li>
<li>就是计算当前日期到时间原点之间一共经历了多少毫秒</li>

</ul>
<p><strong>注意：</strong><br />中国属于东八区，会把时间<strong>增加8个小时</strong></p>
<ul>
<li>1970-01-01 08：00：00</li>

</ul>
<p>把毫秒转换为日期：</p>
<ul>
<li>1天 = 24*60*60 = 86400秒 = 86400*1000=86400000毫秒</li>

</ul>
<p><strong>使用：</strong></p>
<div class="cnblogs_code">
<pre><span>Date类的带参数构造方法
Date date = new<span> Date();
Date();//获取当前系统的时间和日期
---------<span>
Date date = new Date(0L<span>);
Date(long date);//传递毫秒值，把毫秒值转化成Date日期
-----------<span>
Date date = new<span> Date();
long time =<span> date.getTime();
long<span> getTime() 把日期转换成毫秒(相当于System.currentTimeMillis()方法)
返回自1970年1月1日 00-00-00GMT 以来此Date 对象表示的毫秒数。</span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<h2>DateFormat类</h2>
<p>java.text.DateFormat:是<strong>日期/时间格式化</strong>子类的抽象类</p>
<p><strong>作用：</strong></p>
<ul>
<li>格式化（也就是日期 -&gt; 文本），解析（文本-&gt;日期）</li>
</ul>
<p><strong>成员方法：</strong></p>
<ul>
<li>String format(Date date) 按照指定的模式，把Date日期，格式化为符合模式的字符串</li>
<li>Date parse(String source) 把符合模式的字符串，解析为Date日期</li>
<li>DateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat类的子类</li>
</ul>
<div class="cnblogs_code">
<pre>java.text.SimpleDateFormat extends DateFormat</pre>
</div>
<p>使用DateFormat类中的<strong>方法format，把日期格式化为文本</strong></p>
<p><strong>使用步骤:</strong></p>
<ol>
<li>创建simpleDateFormat对象，构造方法中传递指定的模式</li>
<li>调用SimpleDateFormat对象中的方法format，按照构造方法指定的模式，把Date日期格式化为符合模式的字符串<strong>（文本）</strong></li>
</ol>
<div class="cnblogs_code">
<pre>SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒"<span>);
Date date = new<span> Date();
String d = sdf.format(date);</span></span></pre>
</div>
<p>&nbsp;</p>
<h2>Calendar类</h2>
<p><strong>介绍：</strong><br />java.util.Calendar类；<strong>日历类</strong></p>
<ul>
<li>Calendar类是一个抽象类，里边提供了很多操作日历字段的方法<strong>（YEAR、MONTH、DAY_OF_MONTH、HOUR)</strong></li>
<li>Calendar类无法直接创建对象使用，里边有一个静态方法叫<strong>getInstance(),</strong>该方法返回了Calendar类的子类对象</li>
<li>static Calendar getInstance() 使用默认时区和语言环境获得一个日历。</li>

</ul>
<div class="cnblogs_code">
<pre>Calendar c = Calendar.getInstance();//多态</pre>
</div>
<p>Calendar类的<strong>常用成员方法：</strong></p>
<ul>
<li>public int get(int field);返回给定日历字段的值。</li>
<li>public void set(int field,int value);将给定的日历字段设置为给定值</li>
<li>public abstract void add(int field, int amount);根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li>public Data getTime();返回一个表示次Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<div class="cnblogs_code">
<pre>//public int get(int field);返回给定日历字段的值。
Calendar c =<span> Calendar.getInstance();
int year =<span> c.get(Calendar.YEAR);
int month =<span> c.get(Calendar.MONTH);

///public void set(int field,int value);将给定的日历字段设置为给定值
//设置年为9999
//设置月为9月
c.set(Calendar.YEAR,9999<span>);
c.set(Calendar.MONTH,9<span>);

//增加年
c.add(Calendar.YEAR,2<span>);

//把日历对象，转换为日期对象
Date date=c.getTime();</span></span></span></span></span></span></pre>
<p>&nbsp;</p>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java的常用API之Object类简介</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210316.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 18 Jul 2019 14:03:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/18/11210316.html</guid><description><![CDATA[<h2>Object类</h2>
<p><strong>1.toString方法</strong><br />在我们直接使用输出语句输出对象的时候，其实通过该对象调用了其toString()方法。</p>
<p><strong>2.equals方法</strong><br /><strong>方法摘要：</strong><br />类默认继承了Object类，所以可以使用Object类的equals方法<br />boolean equals(Object obj)指示其他某个对象是否与此对象<strong>&ldquo;相等&rdquo;</strong>。</p>
<div class="cnblogs_code">
<pre><span>equalse方法源码：
public boolean<span> equals(Object obj){
    return (this ==<span> obj);
}</span></span></span></pre>
</div>
<p><strong>参数：</strong></p>
<ul>
<li>Object obj:可以传递任意的对象</li>
<li>== 比较运算符，返回的是一个布尔值 true false</li>
<li>基本数据类型：比较的是值</li>
<li>引用数据类型：计较的是两个对象的地址值　</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>数据库知识总结（全）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191647.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 13:27:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191647.html</guid><description><![CDATA[<h1 style="text-align: center;">数据库知识总结</h1>
<h2>本节内容</h2>
<p><strong>1.数据库的基本概念</strong></p>
<p><strong>2.MySQL数据库软</strong></p>
<ol>
<li>安装</li>
<li>卸载</li>
<li>配置</li>
</ol>
<p><strong>3.SQL</strong></p>
<p>&nbsp;</p>
<h2>数据库的基本概念</h2>
<p>1.数据库的英文单词：<strong>DataBase 简称：DB</strong><br />2.什么是数据库？</p>
<ul>
<li>	用于存储和管理数据的仓库</li>





</ul>
<p>3.数据库的特点：</p>
<ol>
<li>持久化存储数据。其实数据库就是一个文件系统</li>
<li>方便存储和管理数据</li>
<li>使用了统一的方式操作数据库 -- SQL</li>





</ol>
<p>4.常见的数据库软件</p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201907/1444343-20190715193843077-1841892066.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>MySQL数据库软件</h2>
<p>MySQL的安装在博客中比较多也比较全，这里就不一一截图。<br /><strong>主要讲解下MySQL的卸载</strong></p>
<p>1.安装<br />参见博客</p>
<p><strong>2.卸载</strong><br />	1.去mysql的安装目录找到my.ini文件并打开</p>
<ul>
<li>		复制datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"</li>




</ul>
<p>	2.卸载MySQL<br />	3.删除C:/ProgramData目录下的MySQL文件夹 （隐藏文件）<br /><strong>3.配置</strong><br />MySQL服务启动</p>
<ol>
<li>手动。</li>
<li>cmd--&gt; services.msc 打开服务的窗口</li>
<li>使用管理员打开cmd</li>
</ol>
<div class="cnblogs_code">
<pre><span style="color: #000000;">net start mysql :启动mysql的服务
net stop mysql :关闭mysql的服务</span></pre>
</div>
<p>MySQL登陆</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span>.mysql -uroot -<span style="color: #000000;">p密码
</span><span style="color: #800080;">2</span>.mysql -hip -uroot -<span style="color: #000000;">p 连目标的密码
</span><span style="color: #800080;">3</span>.mysql --host=ip --user=root --password=连接目标的密码</pre>
</div>
<p>MySQL退出</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span><span style="color: #000000;">.exit
</span><span style="color: #800080;">2</span>.quit</pre>
</div>
<p><strong>MySQL目录结构</strong><br />	1.MySQL安装目录<br />	 配置文件 <strong>my.ini</strong><br />	2.MySQL数据目录<br />	 几个概念</p>
<ol>
<li>数据库:文件夹</li>
<li>表：文件</li>
<li>数据:数据</li>




</ol>
<p>&nbsp;</p>
<h1><br />SQL</h1>
<p><strong>1.什么是SQL ？</strong></p>
<ul>
<li>Structured Query Languange：<strong>结构化查询语言</strong></li>




</ul>
<p>其实就是定义了操作所有<strong>关系型</strong>数据库的<strong>规则</strong>。每一种数据库操作的方式存在不一样的地方，称为&ldquo;方言&rdquo;。</p>
<p><strong>2.SQL通用语法</strong></p>
<ol>
<li>SQL语句可以单行或多行书写，以分号结尾。</li>
<li>可使用空格和缩进来增强语句的可读性。</li>
<li>MySQL数据库的SQL 语言不区分大小写，关键字建议使用大写。</li>
<li>3种 注释</li>




</ol>
<ul>
<li>单行注释： -- 注释内容 或 # 注释内容（mysql特有）</li>
<li>多行注释： /*注释*/</li>




</ul>
<p><strong>3.SQL分类</strong><br />	1.DDL(Data Definition Language)<strong>数据定义语言</strong></p>
<ul>
<li>		用来定义数据库对象：数据库、表、列等。关键字：create，drop，alter等</li>
</ul>
<p>	2.DML(Data Manipulatio Language)<strong>数据操作语言</strong></p>
<ul>
<li>		用来对数据库中表的数据进行增删改。关键字：insert，delete，update 等</li>
</ul>
<p>	3.DQL(Data Query Language)<strong>数据库查询语言</strong></p>
<ul>
<li>		用来查询数据库中表的记录（数据）。关键字：select，where 等</li>
</ul>
<p>	4.DCL(Data Control Language)<strong>数据控制语言</strong>（了解）</p>
<ul>
<li>		用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANY，REVOKE 等。</li>




</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>DDL：操作数据库表</h2>
<h3>1.操作数据库：CRUD</h3>
<p><strong>	1.C(Create):创建</strong></p>
<ul>
<li>创建数据库：</li>




</ul>
<div class="cnblogs_code">
<pre>create database 数据库名称</pre>
</div>
<ul>
<li>创建数据库，判断不存在，再创建：</li>
</ul>
<div class="cnblogs_code">
<pre>create database <span style="color: #0000ff;">if</span> not exists 数据库名称；</pre>
</div>
<ul>
<li>创建数据库，并指定字符集</li>
</ul>
<div class="cnblogs_code">
<pre>create database 数据库名称 character <span style="color: #0000ff;">set</span> 字符集名；</pre>
</div>
<ul>
<li>练习：创建db3数据库，判断是否存在，并指定字符集为gbk</li>
</ul>
<div class="cnblogs_code">
<pre>create database <span style="color: #0000ff;">if</span> not exists db3 character <span style="color: #0000ff;">set</span> gbk;</pre>
</div>
<p><strong> 2.R(Retrieve):查询</strong></p>
<ul>
<li>询所有数据库的名称：</li>
</ul>
<div class="cnblogs_code">
<pre>show database；</pre>
</div>
<ul>
<li>查询某个数据库的字符集：查询某个数据库的创建语句</li>
</ul>
<div class="cnblogs_code">
<pre>show create database 数据库名称；</pre>
</div>
<p><strong>3.U(Update):修改</strong></p>
<ul>
<li>修改数据库的字符集</li>
</ul>
<div class="cnblogs_code">
<pre>alter database 数据库名称 character <span style="color: #0000ff;">set</span> 字符集名称：</pre>
</div>
<p><strong>4.D(Delete):删除</strong></p>
<ul>
<li>删除数据库</li>
</ul>
<div class="cnblogs_code">
<pre>drop database 数据库名称；</pre>
</div>
<ul>
<li>判断数据库存在，存在再删除</li>
</ul>
<div class="cnblogs_code">
<pre>drop database <span style="color: #0000ff;">if</span> exists 数据库名称；</pre>
</div>
<p><strong>5:使用数据库</strong></p>
<ul>
<li>查询当前正在使用的数据库名称</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">select</span> database();</pre>
</div>
<ul>
<li>使用数据库</li>
</ul>
<div class="cnblogs_code">
<pre>use 数据库名称；</pre>
</div>
<h3>2.操作表</h3>
<p><strong> 1.C(Create):创建 </strong></p>
<ul>
<li>语法;</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">create table 表名(
列名1 数据类型1，
列名2 数据类型2，
...
列名n 数据类型n
);</span></pre>
</div>
<p><strong>注意：最后一列，不需要加逗号（，）</strong></p>
<ul>
<li>数据类型：</li>
</ul>
<p><strong> 1.int：</strong>整数类型</p>
<div class="cnblogs_code">
<pre>age <span style="color: #0000ff;">int</span>，</pre>
</div>
<p><strong> 2.double：</strong>小数类型</p>
<div class="cnblogs_code">
<pre>score duoble （<span style="color: #800080;">3</span>，<span style="color: #800080;">7</span>）</pre>
</div>
<p><strong> 3.data：</strong>日期，只包含年月日，yyyy-MM-dd<br />				<strong>4.datatime：</strong>日期，包含年月日时分秒 ，yyyy-MM-dd HH：mm；ss<br />				<strong>5.timestamp：</strong>时间类型 包含年月日时分秒 yyyy-MM-dd HH：mm；ss</p>
<div class="cnblogs_code">
<pre>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</pre>
</div>
<p><strong> 6.varchar：</strong>字符串</p>
<div class="cnblogs_code">
<pre>name varchar(<span style="color: #800080;">20</span><span style="color: #000000;">):姓名最大20的字符
cainiao 7个字符 张三 2个字符</span></pre>
</div>
<ul>
<li>创建表</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">create table student(
id </span><span style="color: #0000ff;">int</span><span style="color: #000000;">,
name varchar(</span><span style="color: #800080;">37</span><span style="color: #000000;">),
age </span><span style="color: #0000ff;">int</span><span style="color: #000000;">,
score </span><span style="color: #0000ff;">double</span>(<span style="color: #800080;">4.1</span><span style="color: #000000;">),
birthday data,
insert_time timestamp
);</span></pre>
</div>
<ul>
<li>复制表：</li>
</ul>
<div class="cnblogs_code">
<pre>create table 表名 like 被复制的表名</pre>
</div>
<p><strong>2.R(Retrieve):查询</strong></p>
<ul>
<li>查询某个数据库中所有的表名称</li>
</ul>
<div class="cnblogs_code">
<pre>show tables；</pre>
</div>
<ul>
<li>查询表结构</li>
</ul>
<div class="cnblogs_code">
<pre>desc 表名；</pre>
</div>
<p><strong>3.U(Update):修改</strong></p>
<ul>
<li>1.修改表名</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 rename to 新的表名；</pre>
</div>
<ul>
<li>2.修改表的字符集</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 character <span style="color: #0000ff;">set</span> 字符集名称；</pre>
</div>
<ul>
<li>3.添加一列</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 add 列名 数据类型；</pre>
</div>
<ul>
<li>4.修改列名称 类型</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">alter table 表名 change 列名 新列名 新列别 新数据类型；
alter table 表名 modify 列名 新数据类型；</span></pre>
</div>
<ul>
<li>5.删除列</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 drop 列名；</pre>
</div>
<p><strong>4.D(Delete):删除</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">drop table 表名；
</span>drop table <span style="color: #0000ff;">if</span> exists 表名；</pre>
</div>
<p><br /><strong>*客户端图形化工具：SQLYog</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>DML：增删改表中的数据</h1>
<p><strong>1.添加数据：</strong></p>
<ul>
<li>语法：</li>




</ul>
<div class="cnblogs_code">
<pre>insert into 表名(列名1，列名2，...列名n) values(值1，值2，...值n)；</pre>
</div>
<ul>
<li>注意：</li>
</ul>
<p>1.列名和值要一一对应。</p>
<p>2.如果表名后，不定义列名，则默认给所有列添加值。</p>
<div class="cnblogs_code">
<pre>insert into 表名 values(值1，值2，...值n)；</pre>
</div>
<p>3.除了数字类型，其他类型需要使用引号（单双都可以）引起来</p>
<p><strong>2.删除数据：</strong></p>
<ul>
<li>语法：</li>
</ul>
<div class="cnblogs_code">
<pre>delete <span style="color: #0000ff;">from</span> 表名 [<span style="color: #0000ff;">where</span> 条件]</pre>
</div>
<ul>
<li>注意：</li>
</ul>
<ol>
<li>如果不加条件，则删除表中所有记录。</li>
<li>如果要删除所有记录</li>
</ol>
<ul>
<li><strong>delete from 表名；</strong>-- 不推荐使用。有多少条记录就会执行多少次删除操作。</li>
<li><strong>TRUNCATE TABLE 表名；</strong> -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</li>
</ul>
<p><strong>3.修改数据</strong></p>
<ul>
<li>*语法：</li>
</ul>
<div class="cnblogs_code">
<pre>update 表名 <span style="color: #0000ff;">set</span> 列名1 = 值1，列名2 = 值2，...[<span style="color: #0000ff;">where</span> 条件];</pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>如果不加任何条件，则会将表中所有记录全部修改。</li>
</ul>
<p>&nbsp;</p>
<h1><br />DQL：查询表中的记录</h1>
<p><strong>select * from 表名；</strong></p>
<p><strong>1.语法</strong></p>
<p>select <br />		　　字段列表<br />	from<br />		　　表名列表<br />	where <br />		　　条件列表<br />	group by<br />		　　分组字段<br />	having<br />		　　分组之后的条件<br />	order by<br />		　　排序<br />	limit <br />		　　分页限定<br />		<br /><strong>2.基础查询</strong><br />	　　1.多个字段的查询</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">select</span> 字段名1，字段名2... <span style="color: #0000ff;">from</span> 表名；</pre>
</div>
<p>注意：</p>
<ul>
<li><strong>如果查询所有字段，则可以使用*来替代字段列表。</strong></li>
</ul>
<p>　　2.去除重复</p>
<div class="cnblogs_code">
<pre>distinct</pre>
</div>
<p> 　　3.计算列<br />	一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</p>
<div class="cnblogs_code">
<pre>ifnull(表达式1，表达式2);</pre>
</div>
<ul>
<li>表达式1：那个字段需要判断是否为null</li>
<li>如果改字段为null后的替换值。</li>
</ul>
<p>　　4.起别名</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">as</span> ：as也可以省略</pre>
</div>
<p><strong>3.条件查询</strong></p>
<div class="cnblogs_code">
<pre>1.where子句后跟条件</pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #800080;">2</span><span style="color: #000000;">.运算符

</span>&gt;,&lt;,&gt;=,&lt;=,=,&lt;&gt;<span style="color: #000000;">
BETWEEN...AND
IN(集合)
LIKE
IS NULL
and or </span>&amp;&amp;<span style="color: #000000;">
or or </span>||<span style="color: #000000;">
not or </span>!</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><br />本节内容</h2>
<p><strong>1.DQL：查询语句</strong></p>
<ol>
<li>排序查询</li>
<li>聚合函数</li>
<li>分组查询</li>
<li>分页查询</li>




</ol>
<p><strong>2.约束</strong><br /><strong>3.多表之间的关系</strong><br /><strong>4.范式</strong><br /><strong>5.数据库的备份和还原</strong></p>
<h2>DQL：查询语句</h2>
<p><strong>1.排序查询</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">语法：order by 子句
order by 排序字段1 排序方式1，排序字段2 排序方式2...</span></pre>
</div>
<p><strong>排序方式：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">ASC：升序，默认的
DESC：降序</span></pre>
</div>
<p>注意：<br /><strong>如果有多个排序条件，则当前的条件值一样时，才会判断第二条件。</strong><br /><br /><strong>2.聚合函数：将一列数据作为一个整体，进行纵向的计算。</strong><br /><strong>　　1.count：计算个数</strong></p>
<ol>
<li>一般选择非空的列<strong>：主键</strong></li>
<li><strong>count(*)</strong></li>




</ol>
<p>　<strong>　2.max：计算最大值</strong><br /><strong>　　3.min：计算最小值</strong><br /><strong>　　4.sum：计算和</strong><br /><strong>　　5.avg：计算平均值</strong></p>
<p>注意：<strong>聚合函数的计算，排除null值。</strong><br />解决方案：</p>
<ol>
<li>选择不包含非空的列进行计算</li>
<li>IFNULL函数</li>




</ol>
<p><strong>3.分组查询</strong></p>
<div class="cnblogs_code">
<pre>语法：group by 分组字段</pre>
</div>
<p>注意：<br />　　1.分组之后查询的字段：分组字段、聚合函数<br />　　2.where 和 having的区别？</p>
<ol>
<li>where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</li>
<li>where 后不可以跟聚合函数，having可以进行聚合函数的判断。</li>




</ol>
<p><strong>4.分页查询</strong><br />语法：<strong>limit开始的索引</strong>，每页查询的条数；</p>
<div class="cnblogs_code">
<pre>公式：开始的索引 = （当前的页码 - <span style="color: #800080;">1</span>） *<span style="color: #000000;"> 每页显示的条数
</span>--<span style="color: #000000;">每页显示3条记录

SELECT </span>* FROM student LIMIT <span style="color: #800080;">0.3</span>； --<span style="color: #000000;">第1页
SELECT </span>* FROM student LIMIT <span style="color: #800080;">3.3</span>； --<span style="color: #000000;">第2页
SELECT </span>* FROM student LIMIT <span style="color: #800080;">6.3</span>； --<span style="color: #000000;">第3页

limit 是一个MySQL</span><span style="color: #800000;">"</span><span style="color: #800000;">方言</span><span style="color: #800000;">"</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>约束</h2>
<p><strong>概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。</strong><br />分类：</p>
<ol>
<li>主键约束：primary key </li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>




</ol>
<p><br /><strong>非空约束：not null</strong><br />　　1.创建表时添加约束</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">CREATE TABLE stu(
　　id INT,
　　NAME VARCHAR(</span><span style="color: #800080;">20</span>) NOT NULL --<span style="color: #000000;">name为非空
);</span></pre>
</div>
<p>　　2.创建表完后，添加非空约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY NAME VARCHAR(<span style="color: #800080;">20</span>) NOT NULL;</pre>
</div>
<p>　　3.删除name的非空约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY NAME VARCHAR(<span style="color: #800080;">20</span>);</pre>
</div>
<p><strong>唯一约束：unique，值不能重复</strong></p>
<p>　　1.注意：<br />唯一约束可以有null值，但是只能有一条记录为null</p>
<p>　　2.创建表时，添加唯一约束</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">CREATE TABLE stu(
　　id INT,
　　phone_number VARCHAR(</span><span style="color: #800080;">20</span>) UNIQUE --<span style="color: #000000;">添加了唯一约束(手机号)
);</span></pre>
</div>
<p>　　3.删除唯一约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu DROP INDEX　phone_number;</pre>
</div>
<p>　　4.在表创建完后，添加唯一约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY phone_number VARCHAR(<span style="color: #800080;">20</span>) UNIQUE;</pre>
</div>
<p><strong>主键约束：primary key</strong><br />　　1.注意：</p>
<ol>
<li>含义：非空且唯一</li>
<li>一张表只能有一个字段为主键</li>
<li>主键就是表中记录的唯一标识</li>




</ol>
<p>　　2.在创建表时，添加主键约束</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">create table stu(
　　id </span><span style="color: #0000ff;">int</span> primary key, --<span style="color: #000000;">给id添加主键约束
　　name varchar(</span><span style="color: #800080;">20</span><span style="color: #000000;">)
);</span></pre>
</div>
<p>　　3.删除主键</p>
<div class="cnblogs_code">
<pre>--错误写法 alter table stu modify id <span style="color: #0000ff;">int</span><span style="color: #000000;"> ;
AlTER TABLE stu DROP PRIMARY KEY;</span></pre>
</div>
<p>　　4.创建完表后，添加主键</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</pre>
</div>
<p><strong>5.自动增长：</strong><br />	　<strong>　1.概念：如果莫一列是数值类型的，使用 auto_increment 可以来完成值的自动增长</strong><br />	<br />	　　2.在创建表时，添加主键约束，并且完成主键自增长</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">create table stu(
　　id </span><span style="color: #0000ff;">int</span> primary key auto_increment, --<span style="color: #000000;">给id添加主键约束
　　name varchar(</span><span style="color: #800080;">20</span><span style="color: #000000;">)
);</span></pre>
</div>
<p>　　3.删除自动增长</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY id INT;</pre>
</div>
<p>--添加自动增长</p>
<div class="cnblogs_code">
<pre>ALTER TABLE　stu MODIFY id INT auto_increment</pre>
</div>
<p><strong>外键约束：foreign key，让表与表产生关系，从而保证数据的正确性。</strong><br />　　1.在创建表时，添加外键<br />语法：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">create table 表名(
　　...
　　外键列
　　constraint 外键名称 foregin key （外键列名称） references 主表名称（主表列名称）
);</span></pre>
</div>
<p>　　2.删除外键</p>
<div class="cnblogs_code">
<pre>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称；</pre>
</div>
<p>　　3.创建表之后，添加外键</p>
<div class="cnblogs_code">
<pre>ALTER TABLE employee（表名） ADD CONSTRAINT（外键名称） emp_dept_fk FOREIGN KEY (dep_id（外键字段名称）) REFERENCES department(id)（主表名称（主表列名称））</pre>
</div>
<p><strong>4.级联操作</strong><br />添加级联操作<br />语法：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">ALTER TABLE 表名 ADD CONSTRAINT（外键名称）
FOREIGN KEY (外键字段名称) REFERENCES 主表名称（主表列名称）</span></pre>
</div>
<p><strong>分类：</strong><br />	　　1.级联更新：</p>
<div class="cnblogs_code">
<pre>ON UPDATE CASCADE</pre>
</div>
<p>　　2.级联删除：</p>
<div class="cnblogs_code">
<pre>ON DELETE CASCADE</pre>
</div>
<p>&nbsp;</p>
<h2><br />数据库的设计</h2>
<p><strong>1.多表之间的关系</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span><span style="color: #000000;">.一对一(了解）
如：人和身份证
分析：一个人只有一个身份证，一个身份证只能对应一个人
</span><span style="color: #800080;">2</span><span style="color: #000000;">.一对多（多对一）:
如：部门和员工
分析：一个部门有多个员工，一个员工只能对应一个部门
</span><span style="color: #800080;">3</span><span style="color: #000000;">.多对多：
如：学生和课程
分析：一个学生可以选择多个课程，一个课程也可以被多个学生选择</span></pre>
</div>
<p><strong>2.实现关系：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span><span style="color: #000000;">.一对一
如：人和身份证
实现关系：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。
</span><span style="color: #800080;">2</span><span style="color: #000000;">.一对多（多对一）:
如：部门和员工
实现关系：在多的一方建立外键，指向另一方的主键。
</span><span style="color: #800080;">3</span><span style="color: #000000;">.多对多：
如：学生和课程
实现关系：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。</span></pre>
</div>
<p><strong>2.数据库设计的范式</strong><br /><strong>概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</strong><br />设计关系数据库时，遵从不同的规范要求，设计合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递规范，越高的范式数据库冗余越小。<br />目前关系数据库有六种范式：第一范式（1NF），第二范式（2NF），第三范式（3NF），巴斯-科德范式（BCNF），第四范式（4NF），</p>
<p><strong>分类：</strong><br /><strong>1.第一范式（1NF）：</strong>每一列都是不可分割的原子数据项<br /><strong>2.第二范式（2NF）：</strong>在1NF的基础上,非码属性必须完全依赖于候选码(在1NF基础上消除非主属性对主码的部分函数依赖)</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">几个概念:
</span><span style="color: #800080;">1</span>.函数依赖:A--&gt;<span style="color: #000000;">B,如果通过A属性(属性组)的值,可以确定唯一B属性的值,则称B依赖于A.
例如:学号</span>--&gt;姓名.(学号,课程名称)--&gt;<span style="color: #000000;"> 分数
</span><span style="color: #800080;">2</span>.完全函数依赖:A--&gt;<span style="color: #000000;">B ,如果A是一个属性组,则B属性值的确定需要依赖于A属性组中所有的属性值.
例如:(学号,课程名称) </span>--&gt;<span style="color: #000000;"> 分数
</span><span style="color: #800080;">3</span>.部分函数依赖:A--&gt;<span style="color: #000000;">B,如果A是一个属性组,则B属性值的确定只需要依赖于A属性组某一些性值即可.
例如:(学号,课程名) </span>--&gt;<span style="color: #000000;">姓名
</span><span style="color: #800080;">4</span>.传递函数依赖:A--&gt;B,B--&gt;<span style="color: #000000;">C,如果通过A属性(属性组)的值,可以确定唯一B属性的值,再通过B属性(属性组)的值可以确定唯一属性的值,则称C传递函数依赖于A
</span><span style="color: #800080;">5</span><span style="color: #000000;">.码:如果在一张表中,一个属性或属性组,被其他所有属性所完全依赖,则称这个属性(属性组)为该表的码
例如:该表中码为:(学号,课程名称)
主属性:码属性组中的所有属性
非主属性:除了码属性组的属性</span></pre>
</div>
<p><strong> 3.第三范式(3NF):</strong>在2NF基础上,任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)<br />	<br />	</p>
<p>&nbsp;</p>
<h2>本节内容</h2>
<p><strong>1.多表查询</strong></p>
<p><strong>2.事务</strong></p>
<p><strong>3.DCL</strong></p>
<h2>多表查询:</h2>
<p><strong>查询语法</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">select</span><span style="color: #000000;"> 
　　列名列表
</span><span style="color: #0000ff;">from</span><span style="color: #000000;"> 
　　表名列表
</span><span style="color: #0000ff;">where</span> ...</pre>
</div>
<p><strong>准备sql</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#创建部门表
CREATE TABLE dept();
#创建员工表
CREATE TABLE emp();</span></pre>
</div>
<p><strong>笛卡尔积:</strong><br />	有两个集合A,B,去这两个集合的所有组成情况.<br />	要完成多表查询,需要消除无用的数据</p>
<p><strong>多表查询的分类:</strong><br />	<strong>1.内连接查询</strong></p>
<ol>
<li>隐式内连接:使用where条件消除无用数据</li>
<li>显示连接:语法:select 字段列表 from 表名1 [inner] join 表名2 on 条件</li>
<li>内连接查询:</li>




</ol>
<ul>
<li>从那些表中查询数据</li>
<li>条件是什么</li>
<li>查询那些字段</li>
</ul>
<p>	<strong>2.外连接查询</strong><br />		1.左外连接:</p>
<div class="cnblogs_code">
<pre>语法:<span style="color: #0000ff;">select</span> 字段列表 <span style="color: #0000ff;">from</span><span style="color: #000000;"> 表1 left [outer] join 表2 on 条件;
查询的是左表所有数据以及其交集部分.</span></pre>
</div>
<p>2.右外连接</p>
<div class="cnblogs_code">
<pre>语法:<span style="color: #0000ff;">select</span> 字段列表 <span style="color: #0000ff;">from</span><span style="color: #000000;"> 表1 right [outer] join 表2 on 条件;
查询的是右表所有数据以及其交集部分.</span></pre>
</div>
<h2>&nbsp;</h2>
<h2>子查询:</h2>
<p><strong>概念:查询中嵌套查询,称嵌套查询为子查询</strong><br />--查询工资最高的员工信息</p>
<div class="cnblogs_code">
<pre>--1查询最高的工资是多少 <span style="color: #800080;">9000</span><span style="color: #000000;">
SELECT MAX(salary) FROM emp;
</span>--<span style="color: #800080;">2</span><span style="color: #000000;"> 查询员工信息,并且工资等于9000的
</span><span style="color: #0000ff;">select</span> * <span style="color: #0000ff;">from</span> emp WHERE emp.<span style="color: #800000;">'</span><span style="color: #800000;">salary</span><span style="color: #800000;">'</span>=<span style="color: #800080;">9000</span><span style="color: #000000;">;

</span>--<span style="color: #000000;">一条sql就完成这个操作.子查询
SELECT </span>* FROM emp WHERE emp.<span style="color: #800000;">'</span><span style="color: #800000;">salary</span><span style="color: #800000;">'</span> = (SELECT MAX(salary) FROM emp);</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>事务</h2>
<p><strong>1.事务的基本介绍</strong><br />概念:<br />	<strong>如果一个包含多个步骤的业务操作,被事务管理,那么这些操作要么同时成功,要么同时失败.</strong><br />操作:</p>
<ol>
<li>开启事务:start transaction;</li>
<li>回滚:rollback;</li>
<li>提交:commit;</li>




</ol>
<p><strong>2.事务的四大特征</strong></p>
<ol>
<li>原子性:是不可分割的最小操作单位,要么同时成功,要么同时失败.</li>
<li>持久性:当事务提交或回滚后,数据库会持久化的保存数据</li>
<li>隔离性:多个事务之间,相互独立.</li>
<li>一致性:事务操作前后,数据总量不变</li>




</ol>
<p><br /><strong>3.事务的隔离级别</strong><br /><strong>概念:多个事务之间隔离的,相互独立的.但是如果多个事务操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题.</strong><br />存在问题:</p>
<ol>
<li><strong>脏读:一个事务,</strong>读取到另一个事务中没有提交的数据</li>
<li><strong>不可重复读(虚读):</strong>在同一个事物中,两次读取到的数据不一样.</li>
<li><strong>幻读:</strong>一个事务操作(DML)数据表中所有记录,另一个事务添加了一条数据,则第一个事务查询不到自己的修改.</li>




</ol>
<p><strong>隔离级别:</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span><span style="color: #000000;">.read uncommmitted:读未提交
产生的问题:脏读,不可重复读,幻读

</span><span style="color: #800080;">2</span><span style="color: #000000;">.read committed :读已提交(Oracle)
产生的问题:不可重复读,幻读

</span><span style="color: #800080;">3</span><span style="color: #000000;">.repeatable read:可重复读(MySQL默认)
产生的问题:幻读

</span><span style="color: #800080;">4</span><span style="color: #000000;">.serializable:串行化
可以解决所有的问题</span></pre>
</div>
<p><strong>注意:</strong>隔离级别从小到大安全性越来越高,但是效率越来越低</p>
<p><strong>数据库查询隔离级别:</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">select</span> @@tx_isolation</pre>
</div>
<p><strong>数据库设置隔离级别:</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">set</span> <span style="color: #0000ff;">global</span><span style="color: #000000;"> transaction isolation level 级别字符串;<br /></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>DCL:管理用户、授权</h1>
<p><strong>SQL分类:</strong></p>
<ol>
<li>DDL:操作数据库和表</li>
<li>DML：增删改表中的数据</li>
<li>DQL:查询表中的数据</li>
<li>DCL:管理用户、授权</li>
</ol>
<p><strong>DBA:数据库管理员</strong></p>
<p><strong>DCL:管理用户、授权</strong></p>
<p><strong>1.管理用户</strong><br />	　　1.添加用户:</p>
<div class="cnblogs_code">
<pre>语法:CREATE USER <span style="color: #800000;">'</span><span style="color: #800000;">用户名</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">主机名</span><span style="color: #800000;">'</span> IDENTIFIED BY <span style="color: #800000;">'</span><span style="color: #800000;">密码</span><span style="color: #800000;">'</span>;</pre>
</div>
<p>　　2.删除用户</p>
<div class="cnblogs_code">
<pre>语法:DROP USER <span style="color: #800000;">'</span><span style="color: #800000;">用户名</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">主机名</span><span style="color: #800000;">'</span>;</pre>
</div>
<p>　　3.修改用户密码:</p>
<div class="cnblogs_code">
<pre>UPDATE USER SET PASSWORD(<span style="color: #800000;">'</span><span style="color: #800000;">新密码</span><span style="color: #800000;">'</span>) WHERE USER = <span style="color: #800000;">'</span><span style="color: #800000;">用户名</span><span style="color: #800000;">'</span><span style="color: #000000;">;
UPDATE USER SET PASSWORD(</span><span style="color: #800000;">'</span><span style="color: #800000;">abc</span><span style="color: #800000;">'</span>) WHERE USER = <span style="color: #800000;">'</span><span style="color: #800000;">cainiao</span><span style="color: #800000;">'</span><span style="color: #000000;">;

SET PASSWORD FOR </span><span style="color: #800000;">'</span><span style="color: #800000;">用户名</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">主机名</span><span style="color: #800000;">'</span>=PASSWORD(<span style="color: #800000;">'</span><span style="color: #800000;">新密码</span><span style="color: #800000;">'</span><span style="color: #000000;">);
SET PASSWORD FOR </span><span style="color: #800000;">'</span><span style="color: #800000;">root</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">localhost</span><span style="color: #800000;">'</span>=PASSWORD(<span style="color: #800000;">'</span><span style="color: #800000;">123</span><span style="color: #800000;">'</span>);</pre>
</div>
<p><strong> 如果使用mysql中忘记了root用户的密码?</strong></p>
<ol>
<li>cmd --&gt; net stop mysql 停止mysql服务 --&nbsp;需要管理员运行该cmd</li>
<li>使用无验证方式启动mysql服务: mysql --skip-grant-tables</li>
<li>打开新的cmd窗口,直接输入mysql命令,敲回车.就可以登陆成功</li>
<li>use mysql</li>
<li>uodate user set password = password('你的新密码') where user = 'root';</li>
<li>关闭两个窗口</li>
<li>打开任务管理器,手动结束mysql.exe的进程</li>
<li>启动mysql的服务</li>
<li>使用新密码登陆.</li>
</ol>
<p> 　　4.查询用户:<br />	--1.切换到 mysql数据库</p>
<div class="cnblogs_code">
<pre>USE mysql ;</pre>
</div>
<p>--2.查询user表</p>
<div class="cnblogs_code">
<pre>SELECT * FROM USER;</pre>
</div>
<p><strong> 通配符:% 表示可以在任意主机使用用户登陆数据库</strong></p>
<p><strong>2.权限管理</strong><br />	--查询权限:</p>
<div class="cnblogs_code">
<pre>SHOW GRANTS FOR <span style="color: #800000;">'</span><span style="color: #800000;">用户名</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">主机名</span><span style="color: #800000;">'</span><span style="color: #000000;">;
SHOW GRANTS FOE </span><span style="color: #800000;">'</span><span style="color: #800000;">CAINIAO</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">%</span><span style="color: #800000;">'</span>;</pre>
</div>
<p>--授予权限</p>
<div class="cnblogs_code">
<pre>grant 权限列表 on 数据库名.表名 to <span style="color: #800000;">'</span><span style="color: #800000;">用户名</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">主机名</span><span style="color: #800000;">'</span>;</pre>
</div>
<p>--给张三用户授予所有权限,在任意数据库任意表上</p>
<div class="cnblogs_code">
<pre>GRANT ALL ON *.* TO <span style="color: #800000;">'</span><span style="color: #800000;">zhangsan</span><span style="color: #800000;">'</span>@ <span style="color: #800000;">'</span><span style="color: #800000;">localhost</span><span style="color: #800000;">'</span>;</pre>
</div>
<p>--撤销权限:</p>
<div class="cnblogs_code">
<pre>revoke 权限列表 on 数据库名.表名 <span style="color: #0000ff;">from</span> <span style="color: #800000;">'</span><span style="color: #800000;">用户名</span><span style="color: #800000;">'</span>@<span style="color: #800000;">'</span><span style="color: #800000;">主机名</span><span style="color: #800000;">'</span>;</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>SQL分类之DCL:管理用户、授权</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191639.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 13:26:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191639.html</guid><description><![CDATA[<h1>DCL:管理用户、授权</h1>
<p><strong>SQL分类:</strong></p>
<ol>
<li>DDL:操作数据库和表</li>
<li>DML:增删改表中的数据</li>
<li>DQL:查询表中的数据</li>
<li>DCL:管理用户、授权</li>
</ol>
<p><strong>DBA:数据库管理员</strong></p>
<p><strong>DCL:管理用户、授权</strong></p>
<p><br /><strong>1.管理用户</strong><br />　　1.添加用户:</p>
<div class="cnblogs_code">
<pre>语法:CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';</pre>
</div>
<p>　　2.删除用户</p>
<div class="cnblogs_code">
<pre>语法:DROP USER '用户名'@'主机名';</pre>
</div>
<p>　　3.修改用户密码:</p>
<div class="cnblogs_code">
<pre>UPDATE USER SET PASSWORD('新密码') WHERE USER = '用户名'<span>;
UPDATE USER SET PASSWORD('abc') WHERE USER = 'cainiao'<span>;

SET PASSWORD FOR '用户名'@'主机名'=PASSWORD('新密码'<span>);
SET PASSWORD FOR 'root'@'localhost'=PASSWORD('123');</span></span></span></pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>如果使用mysql中忘记了root用户的密码?</strong></p>
<ol>
<li>cmd --&gt; net stop mysql 停止mysql服务 --&nbsp;需要管理员运行该cmd</li>
<li>使用无验证方式启动mysql服务: mysql --skip-grant-tables</li>
<li>打开新的cmd窗口,直接输入mysql命令,敲回车.就可以登陆成功</li>
<li>use mysql</li>
<li>uodate user set password = password('你的新密码') where user = 'root';</li>
<li>关闭两个窗口</li>
<li>打开任务管理器,手动结束mysql.exe的进程</li>
<li>启动mysql的服务</li>
<li>使用新密码登陆.</li>

</ol>
<p><br />　　4.查询用户:<br />--1.切换到 mysql数据库</p>
<div class="cnblogs_code">
<pre>USE mysql ;</pre>
</div>
<p>--2.查询user表</p>
<div class="cnblogs_code">
<pre>SELECT * FROM USER;</pre>
</div>
<p><strong>通配符:% 表示可以在任意主机使用用户登陆数据库</strong></p>
<p><br /><strong>2.权限管理</strong><br />--查询权限:</p>
<div class="cnblogs_code">
<pre>SHOW GRANTS FOR '用户名'@'主机名'<span>;
SHOW GRANTS FOE 'CAINIAO'@'%';</span></pre>
</div>
<p>--授予权限</p>
<div class="cnblogs_code">
<pre>grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';</pre>
</div>
<p>--给张三用户授予所有权限,在任意数据库任意表上</p>
<div class="cnblogs_code">
<pre>GRANT ALL ON *.* TO 'zhangsan'@ 'localhost';</pre>
</div>
<p>--撤销权限:</p>
<div class="cnblogs_code">
<pre>revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>数据库的多表查询和事务</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191600.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 13:18:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191600.html</guid><description><![CDATA[<h2>本节内容</h2>
<p><strong>1.多表查询</strong></p>
<p><strong>2.事务</strong></p>
<h3><span style="font-size: 1.5em;">多表查询:</span></h3>
<p><strong>查询语法</strong></p>
<div class="cnblogs_code">
<pre>select<span> 
　　列名列表
from<span> 
　　表名列表
where ...</span></span></pre>
</div>
<p>&nbsp;</p>
<p><strong>准备sql</strong></p>
<div class="cnblogs_code">
<pre><span>#创建部门表
CREATE TABLE dept();
#创建员工表
CREATE TABLE emp();</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>笛卡尔积:</strong><br />有两个集合A,B,去这两个集合的所有组成情况.<br />要完成多表查询,需要消除无用的数据</p>
<p>&nbsp;</p>
<p><strong>多表查询的分类:</strong><br /><strong>1.内连接查询</strong></p>
<ol>
<li>隐式内连接:使用where条件消除无用数据</li>
<li>显示连接:语法:select 字段列表 from 表名1 [inner] join 表名2 on 条件</li>
<li>内连接查询:</li>

</ol>
<ul>
<li>从那些表中查询数据</li>
<li>条件是什么</li>
<li>查询那些字段</li>
</ul>
<p><strong>2.外连接查询</strong><br />1.左外连接:</p>
<div class="cnblogs_code">
<pre>语法:select 字段列表 from<span> 表1 left [outer] join 表2 on 条件;
查询的是左表所有数据以及其交集部分.</span></pre>
</div>
<p>2.右外连接</p>
<div class="cnblogs_code">
<pre>语法:select 字段列表 from<span> 表1 right [outer] join 表2 on 条件;
查询的是右表所有数据以及其交集部分.</span></pre>
</div>
<h2>&nbsp;</h2>
<h2>子查询:</h2>
<p><strong>概念:查询中嵌套查询,称嵌套查询为子查询</strong><br />--查询工资最高的员工信息</p>
<div class="cnblogs_code">
<pre>--1查询最高的工资是多少 9000<span>
SELECT MAX(salary) FROM emp;
--2<span> 查询员工信息,并且工资等于9000的
select * from emp WHERE emp.'salary'=9000<span>;

--<span>一条sql就完成这个操作.子查询
SELECT * FROM emp WHERE emp.'salary' = (SELECT MAX(salary) FROM emp);</span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<h2>事务</h2>
<p><strong>1.事务的基本介绍</strong><br />概念:<br /><strong>如果一个包含多个步骤的业务操作,被事务管理,那么这些操作要么同时成功,要么同时失败.</strong><br />操作:</p>
<ol>
<li>开启事务:start transaction;</li>
<li>回滚:rollback;</li>
<li>提交:commit;</li>

</ol>
<p><strong>2.事务的四大特征</strong></p>
<ol>
<li>原子性:是不可分割的最小操作单位,要么同时成功,要么同时失败.</li>
<li>持久性:当事务提交或回滚后,数据库会持久化的保存数据</li>
<li>隔离性:多个事务之间,相互独立.</li>
<li>一致性:事务操作前后,数据总量不变</li>

</ol>
<p><br /><strong>3.事务的隔离级别</strong><br /><strong>概念:多个事务之间隔离的,相互独立的.但是如果多个事务操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题.</strong><br />存在问题:</p>
<ol>
<li><strong>脏读:一个事务,</strong>读取到另一个事务中没有提交的数据</li>
<li><strong>不可重复读(虚读):</strong>在同一个事物中,两次读取到的数据不一样.</li>
<li><strong>幻读:</strong>一个事务操作(DML)数据表中所有记录,另一个事务添加了一条数据,则第一个事务查询不到自己的修改.</li>

</ol>
<p><strong>隔离级别:</strong></p>
<div class="cnblogs_code">
<pre>1<span>.read uncommmitted:读未提交
产生的问题:脏读,不可重复读,幻读

2<span>.read committed :读已提交(Oracle)
产生的问题:不可重复读,幻读

3<span>.repeatable read:可重复读(MySQL默认)
产生的问题:幻读

4<span>.serializable:串行化
可以解决所有的问题</span></span></span></span></pre>
</div>
<p><strong>注意:</strong>隔离级别从小到大安全性越来越高,但是效率越来越低</p>
<p><strong>数据库查询隔离级别:</strong></p>
<div class="cnblogs_code">
<pre>select @@tx_isolation</pre>
</div>
<p><strong>数据库设置隔离级别:</strong></p>
<div class="cnblogs_code">
<pre>set global<span> transaction isolation level 级别字符串;<br /></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>数据库的查询语句的约束和范式</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191539.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191539.html</guid><description><![CDATA[<h2><br />本节内容</h2>
<p><strong>1.DQL：查询语句</strong></p>
<ol>
<li>排序查询</li>
<li>聚合函数</li>
<li>分组查询</li>
<li>分页查询</li>

</ol>
<p><strong>2.约束</strong><br /><strong>3.多表之间的关系</strong><br /><strong>4.范式</strong><br /><strong>5.数据库的备份和还原</strong></p>
<p>&nbsp;</p>
<h2>DQL：查询语句</h2>
<p><strong>1.排序查询</strong></p>
<div class="cnblogs_code">
<pre><span>语法：order by 子句
order by 排序字段1 排序方式1，排序字段2 排序方式2...</span></pre>
</div>
<p><strong>排序方式：</strong></p>
<div class="cnblogs_code">
<pre><span>ASC：升序，默认的
DESC：降序</span></pre>
</div>
<p>注意：<br /><strong>如果有多个排序条件，则当前的条件值一样时，才会判断第二条件。</strong><br /><br /><strong>2.聚合函数：将一列数据作为一个整体，进行纵向的计算。</strong><br /><strong>　　1.count：计算个数</strong></p>
<ol>
<li>一般选择非空的列<strong>：主键</strong></li>
<li><strong>count(*)</strong></li>

</ol>
<p>　<strong>　2.max：计算最大值</strong><br /><strong>　　3.min：计算最小值</strong><br /><strong>　　4.sum：计算和</strong><br /><strong>　　5.avg：计算平均值</strong></p>
<p>注意：<strong>聚合函数的计算，排除null值。</strong><br />解决方案：</p>
<ol>
<li>选择不包含非空的列进行计算</li>
<li>IFNULL函数</li>

</ol>
<p>&nbsp;</p>
<p><strong>3.分组查询</strong></p>
<div class="cnblogs_code">
<pre>语法：group by 分组字段</pre>
</div>
<p>注意：<br />　　1.分组之后查询的字段：分组字段、聚合函数<br />　　2.where 和 having的区别？</p>
<ol>
<li>where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</li>
<li>where 后不可以跟聚合函数，having可以进行聚合函数的判断。</li>

</ol>
<p>&nbsp;</p>
<p><strong>4.分页查询</strong><br />语法：<strong>limit开始的索引</strong>，每页查询的条数；</p>
<div class="cnblogs_code">
<pre>公式：开始的索引 = （当前的页码 - 1） *<span> 每页显示的条数
--<span>每页显示3条记录

SELECT * FROM student LIMIT 0.3； --<span>第1页
SELECT * FROM student LIMIT 3.3； --<span>第2页
SELECT * FROM student LIMIT 6.3； --<span>第3页

limit 是一个MySQL"方言"</span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>约束</h2>
<p><strong>概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。</strong><br />分类：</p>
<ol>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>

</ol>
<p><br /><strong>非空约束：not null</strong><br />　　1.创建表时添加约束</p>
<div class="cnblogs_code">
<pre><span>CREATE TABLE stu(
　　id INT,
　　NAME VARCHAR(20) NOT NULL --<span>name为非空
);</span></span></pre>
</div>
<p>　　2.创建表完后，添加非空约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</pre>
</div>
<p>　　3.删除name的非空约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY NAME VARCHAR(20);</pre>
</div>
<p>&nbsp;</p>
<p><strong>唯一约束：unique，值不能重复</strong></p>
<p>　　1.注意：<br />唯一约束可以有null值，但是只能有一条记录为null</p>
<p>　　2.创建表时，添加唯一约束</p>
<div class="cnblogs_code">
<pre><span>CREATE TABLE stu(
　　id INT,
　　phone_number VARCHAR(20) UNIQUE --<span>添加了唯一约束(手机号)
);</span></span></pre>
</div>
<p>　　3.删除唯一约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu DROP INDEX　phone_number;</pre>
</div>
<p>　　4.在表创建完后，添加唯一约束</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</pre>
</div>
<p><br /><strong>主键约束：primary key</strong><br />　　1.注意：</p>
<ol>
<li>含义：非空且唯一</li>
<li>一张表只能有一个字段为主键</li>
<li>主键就是表中记录的唯一标识</li>

</ol>
<p>　　2.在创建表时，添加主键约束</p>
<div class="cnblogs_code">
<pre><span>create table stu(
　　id int primary key, --<span>给id添加主键约束
　　name varchar(20<span>)
);</span></span></span></pre>
</div>
<p>　　3.删除主键</p>
<div class="cnblogs_code">
<pre>--错误写法 alter table stu modify id int<span> ;
AlTER TABLE stu DROP PRIMARY KEY;</span></pre>
</div>
<p>　　4.创建完表后，添加主键</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</pre>
</div>
<p><br /><strong>5.自动增长：</strong><br />　<strong>　1.概念：如果莫一列是数值类型的，使用 auto_increment 可以来完成值的自动增长</strong><br /><br />　　2.在创建表时，添加主键约束，并且完成主键自增长</p>
<div class="cnblogs_code">
<pre><span>create table stu(
　　id int primary key auto_increment, --<span>给id添加主键约束
　　name varchar(20<span>)
);</span></span></span></pre>
</div>
<p>　　3.删除自动增长</p>
<div class="cnblogs_code">
<pre>ALTER TABLE stu MODIFY id INT;</pre>
</div>
<p>--添加自动增长</p>
<div class="cnblogs_code">
<pre>ALTER TABLE　stu MODIFY id INT auto_increment;</pre>
</div>
<p><br /><strong>外键约束：foreign key，让表与表产生关系，从而保证数据的正确性。</strong><br />　　1.在创建表时，添加外键<br />语法：</p>
<div class="cnblogs_code">
<pre><span>create table 表名(
　　...
　　外键列
　　constraint 外键名称 foregin key （外键列名称） references 主表名称（主表列名称）
);</span></pre>
</div>
<p>　　2.删除外键</p>
<div class="cnblogs_code">
<pre>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称；</pre>
</div>
<p>　　3.创建表之后，添加外键</p>
<div class="cnblogs_code">
<pre>ALTER TABLE employee（表名） ADD CONSTRAINT（外键名称） emp_dept_fk FOREIGN KEY (dep_id（外键字段名称）) REFERENCES department(id)（主表名称（主表列名称））</pre>
</div>
<p>&nbsp;</p>
<p><strong>4.级联操作</strong><br />添加级联操作<br />语法：</p>
<div class="cnblogs_code">
<pre><span>ALTER TABLE 表名 ADD CONSTRAINT（外键名称）
FOREIGN KEY (外键字段名称) REFERENCES 主表名称（主表列名称）</span></pre>
</div>
<p><strong>分类：</strong><br />　　1.级联更新：</p>
<div class="cnblogs_code">
<pre>ON UPDATE CASCADE</pre>
</div>
<p>　　2.级联删除：</p>
<div class="cnblogs_code">
<pre>ON DELETE CASCADE</pre>
</div>
<p>&nbsp;</p>
<h2><br />数据库的设计</h2>
<p><strong>1.多表之间的关系</strong></p>
<div class="cnblogs_code">
<pre>1<span>.一对一(了解）
如：人和身份证
分析：一个人只有一个身份证，一个身份证只能对应一个人
2<span>.一对多（多对一）:
如：部门和员工
分析：一个部门有多个员工，一个员工只能对应一个部门
3<span>.多对多：
如：学生和课程
分析：一个学生可以选择多个课程，一个课程也可以被多个学生选择</span></span></span></pre>
</div>
<p><strong>2.实现关系：</strong></p>
<div class="cnblogs_code">
<pre>1<span>.一对一
如：人和身份证
实现关系：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。
2<span>.一对多（多对一）:
如：部门和员工
实现关系：在多的一方建立外键，指向另一方的主键。
3<span>.多对多：
如：学生和课程
实现关系：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。</span></span></span></pre>
</div>
<p><strong>2.数据库设计的范式</strong><br /><strong>概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</strong><br />设计关系数据库时，遵从不同的规范要求，设计合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递规范，越高的范式数据库冗余越小。<br />目前关系数据库有六种范式：第一范式（1NF），第二范式（2NF），第三范式（3NF），巴斯-科德范式（BCNF），第四范式（4NF），</p>
<p><strong>分类：</strong><br /><strong>1.第一范式（1NF）：</strong>每一列都是不可分割的原子数据项<br /><strong>2.第二范式（2NF）：</strong>在1NF的基础上,非码属性必须完全依赖于候选码(在1NF基础上消除非主属性对主码的部分函数依赖)</p>
<div class="cnblogs_code">
<pre><span>几个概念:
1.函数依赖:A--&gt;<span>B,如果通过A属性(属性组)的值,可以确定唯一B属性的值,则称B依赖于A.
例如:学号--&gt;姓名.(学号,课程名称)--&gt;<span> 分数
2.完全函数依赖:A--&gt;<span>B ,如果A是一个属性组,则B属性值的确定需要依赖于A属性组中所有的属性值.
例如:(学号,课程名称) --&gt;<span> 分数
3.部分函数依赖:A--&gt;<span>B,如果A是一个属性组,则B属性值的确定只需要依赖于A属性组某一些性值即可.
例如:(学号,课程名) --&gt;<span>姓名
4.传递函数依赖:A--&gt;B,B--&gt;<span>C,如果通过A属性(属性组)的值,可以确定唯一B属性的值,再通过B属性(属性组)的值可以确定唯一属性的值,则称C传递函数依赖于A
5<span>.码:如果在一张表中,一个属性或属性组,被其他所有属性所完全依赖,则称这个属性(属性组)为该表的码
例如:该表中码为:(学号,课程名称)
主属性:码属性组中的所有属性
非主属性:除了码属性组的属性</span></span></span></span></span></span></span></span></span></pre>
</div>
<p><strong>3.第三范式(3NF):</strong>在2NF基础上,任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)</p>]]></description></item><item><title>SQL分类之DQL：查询表中的记录</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191387.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 12:45:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191387.html</guid><description><![CDATA[<h1>DQL：查询表中的记录</h1>
<p><strong>select * from 表名；</strong></p>
<p><strong>1.语法</strong></p>
<p>select&nbsp;<br />　　字段列表<br />from<br />　　表名列表<br />where&nbsp;<br />　　条件列表<br />group by<br />　　分组字段<br />having<br />　　分组之后的条件<br />order by<br />　　排序<br />limit&nbsp;<br />　　分页限定<br /><br /><strong>2.基础查询</strong><br />　　1.多个字段的查询</p>
<div class="cnblogs_code">
<pre>select 字段名1，字段名2... from 表名；</pre>
</div>
<p>注意：</p>
<ul>
<li><strong>如果查询所有字段，则可以使用*来替代字段列表。</strong></li>
</ul>
<p>　　2.去除重复</p>
<div class="cnblogs_code">
<pre>distinct</pre>
</div>
<p>　　3.计算列<br />一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</p>
<div class="cnblogs_code">
<pre>ifnull(表达式1，表达式2);</pre>
</div>
<ul>
<li>表达式1：那个字段需要判断是否为null</li>
<li>如果改字段为null后的替换值。</li>
</ul>
<p>　　4.起别名</p>
<div class="cnblogs_code">
<pre>as ：as也可以省略</pre>
</div>
<p>&nbsp;</p>
<p><strong>3.条件查询</strong></p>
<div class="cnblogs_code">
<pre>1.where子句后跟条件</pre>
</div>
<div class="cnblogs_code">
<pre>2<span>.运算符

&gt;,&lt;,&gt;=,&lt;=,=,&lt;&gt;<span>
BETWEEN...AND
IN(集合)
LIKE
IS NULL
and or &amp;&amp;<span>
or or ||<span>
not or !</span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>SQL分类之DML：增删改表中的数据</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191360.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 12:40:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191360.html</guid><description><![CDATA[<h1>DML：增删改表中的数据</h1>
<p><strong>1.添加数据：</strong></p>
<ul>
<li>语法：</li>
</ul>
<div class="cnblogs_code">
<pre>insert into 表名(列名1，列名2，...列名n) values(值1，值2，...值n)；</pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>1.列名和值要一一对应。</li>
<li>2.如果表名后，不定义列名，则默认给所有列添加值。</li>
</ul>
<div class="cnblogs_code">
<pre>insert into 表名 values(值1，值2，...值n)；</pre>
</div>
<ul>
<li>3.除了数字类型，其他类型需要使用引号（单双都可以）引起来</li>
</ul>
<p><br /><strong>2.删除数据：</strong></p>
<ul>
<li>语法：</li>

</ul>
<div class="cnblogs_code">
<pre>delete from 表名 [where 条件]</pre>
</div>
<p><strong>注意：</strong></p>
<ol>
<li>如果不加条件，则删除表中所有记录。</li>
<li>如果要删除所有记录</li>
</ol>
<ul>
<li><strong>delete from 表名；</strong>-- 不推荐使用。有多少条记录就会执行多少次删除操作。</li>
<li><strong>TRUNCATE TABLE 表名；</strong>&nbsp;-- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</li>
</ul>
<p>&nbsp;</p>
<p><strong>3.修改数据</strong></p>
<ul>
<li>*语法：</li>
</ul>
<div class="cnblogs_code">
<pre>update 表名 set 列名1 = 值1，列名2 = 值2，...[where 条件];</pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>如果不加任何条件，则会将表中所有记录全部修改。</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>SQL分类之DDL：操作数据库表</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191227.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 12:18:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191227.html</guid><description><![CDATA[<h2>DDL：操作数据库表</h2>
<h2>1.操作数据库：CRUD</h2>
<p><strong>1.C(Create):创建</strong></p>
<ul>
<li>创建数据库：</li>
</ul>
<div class="cnblogs_code">
<pre>create database 数据库名称</pre>
</div>
<ul>
<li>创建数据库，判断不存在，再创建：</li>
</ul>
<div class="cnblogs_code">
<pre>create database if not exists 数据库名称；</pre>
</div>
<ul>
<li>创建数据库，并指定字符集</li>
</ul>
<div class="cnblogs_code">
<pre>create database 数据库名称 character set 字符集名；</pre>
</div>
<ul>
<li>练习：创建db3数据库，判断是否存在，并指定字符集为gbk</li>
</ul>
<div class="cnblogs_code">
<pre>create database if not exists db3 character set gbk;</pre>
</div>
<p><br /><strong>2.R(Retrieve):查询</strong></p>
<ul>
<li>询所有数据库的名称：</li>

</ul>
<div class="cnblogs_code">
<pre>show database；</pre>
</div>
<ul>
<li>查询某个数据库的字符集：查询某个数据库的创建语句</li>
</ul>
<div class="cnblogs_code">
<pre>show create database 数据库名称；</pre>
</div>
<p><br /><strong>3.U(Update):修改</strong></p>
<ul>
<li>修改数据库的字符集</li>

</ul>
<div class="cnblogs_code">
<pre>alter database 数据库名称 character set 字符集名称：</pre>
</div>
<p><br /><strong>4.D(Delete):删除</strong></p>
<ul>
<li>删除数据库</li>

</ul>
<div class="cnblogs_code">
<pre>drop database 数据库名称；</pre>
</div>
<ul>
<li>判断数据库存在，存在再删除</li>
</ul>
<div class="cnblogs_code">
<pre>drop database if exists 数据库名称；</pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>5:使用数据库</strong></p>
<ul>
<li>查询当前正在使用的数据库名称</li>

</ul>
<div class="cnblogs_code">
<pre>select database();</pre>
</div>
<ul>
<li>使用数据库</li>
</ul>
<div class="cnblogs_code">
<pre>use 数据库名称；</pre>
</div>
<h2><br />2.操作表</h2>
<p><strong>1.C(Create):创建	</strong></p>
<ul>
<li>语法;</li>

</ul>
<div class="cnblogs_code">
<pre><span>create table 表名(
列名1 数据类型1，
列名2 数据类型2，
...
列名n 数据类型n
);</span></pre>
</div>
<p><strong>注意：最后一列，不需要加逗号（，）</strong></p>
<ul>
<li>数据类型：</li>
</ul>
<p><strong>1.int：</strong>整数类型</p>
<div class="cnblogs_code">
<pre>age int，</pre>
</div>
<p><strong>2.double：</strong>小数类型</p>
<div class="cnblogs_code">
<pre>score duoble （3，7）</pre>
</div>
<p><strong>3.data：</strong>日期，只包含年月日，yyyy-MM-dd<br /><strong>4.datatime：</strong>日期，包含年月日时分秒 ，yyyy-MM-dd HH：mm；ss<br /><strong>5.timestamp：</strong>时间类型 包含年月日时分秒 yyyy-MM-dd HH：mm；ss</p>
<div class="cnblogs_code">
<pre>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</pre>
</div>
<p><strong>6.varchar：</strong>字符串</p>
<div class="cnblogs_code">
<pre>name varchar(20<span>):姓名最大20的字符
cainiao 7个字符 张三 2个字符</span></pre>
</div>
<ul>
<li>创建表</li>
</ul>
<div class="cnblogs_code">
<pre><span>create table student(
id int<span>,
name varchar(37<span>),
age int<span>,
score double(4.1<span>),
birthday data,
insert_time timestamp
);</span></span></span></span></span></pre>
</div>
<ul>
<li>复制表：</li>
</ul>
<div class="cnblogs_code">
<pre>create table 表名 like 被复制的表名</pre>
</div>
<p><br /><strong>2.R(Retrieve):查询</strong></p>
<ul>
<li>查询某个数据库中所有的表名称</li>

</ul>
<div class="cnblogs_code">
<pre>show tables；</pre>
</div>
<ul>
<li>查询表结构</li>
</ul>
<div class="cnblogs_code">
<pre>desc 表名；</pre>
</div>
<p><strong>3.U(Update):修改</strong></p>
<ul>
<li>1.修改表名</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 rename to 新的表名；</pre>
</div>
<ul>
<li>2.修改表的字符集</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 character set 字符集名称；</pre>
</div>
<ul>
<li>3.添加一列</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 add 列名 数据类型；</pre>
</div>
<ul>
<li>4.修改列名称 类型</li>
</ul>
<div class="cnblogs_code">
<pre><span>alter table 表名 change 列名 新列名 新列别 新数据类型；
alter table 表名 modify 列名 新数据类型；</span></pre>
</div>
<ul>
<li>5.删除列</li>
</ul>
<div class="cnblogs_code">
<pre>alter table 表名 drop 列名；</pre>
</div>
<p><strong>4.D(Delete):删除</strong></p>
<div class="cnblogs_code">
<pre><span>drop table 表名；
drop table if exists 表名；</span></pre>
</div>
<p>&nbsp;</p>
<h2><strong>*客户端图形化工具：SQLYog</strong></h2>
<p>&nbsp;</p>]]></description></item><item><title>什么是SQL ？</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191112.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 12:01:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11191112.html</guid><description><![CDATA[<h1>SQL</h1>
<p><strong>1.什么是SQL ？</strong></p>
<ul>
<li>Structured Query Languange：<strong>结构化查询语言</strong></li>
</ul>
<p>其实就是定义了操作所有<strong>关系型</strong>数据库的<strong>规则</strong>。每一种数据库操作的方式存在不一样的地方，称为&ldquo;方言&rdquo;。</p>
<p><strong>2.SQL通用语法</strong></p>
<ol>
<li>SQL语句可以单行或多行书写，以分号结尾。</li>
<li>可使用空格和缩进来增强语句的可读性。</li>
<li>MySQL数据库的SQL 语言不区分大小写，关键字建议使用大写。</li>
<li>3种 注释</li>
</ol>
<ul>
<li>单行注释： -- 注释内容 或 # 注释内容（mysql特有）</li>
<li>多行注释： /*注释*/</li>
</ul>
<p><strong>3.SQL分类</strong><br />1.DDL(Data Definition Language)<strong>数据定义语言</strong></p>
<ul>
<li>用来定义数据库对象：数据库、表、列等。关键字：create，drop，alter等</li>

</ul>
<p><br />2.DML(Data Manipulatio Language)<strong>数据操作语言</strong></p>
<ul>
<li>用来对数据库中表的数据进行增删改。关键字：insert，delete，update 等</li>

</ul>
<p><br />3.DQL(Data Query Language)<strong>数据库查询语言</strong></p>
<ul>
<li>用来查询数据库中表的记录（数据）。关键字：select，where 等</li>

</ul>
<p><br />4.DCL(Data Control Language)<strong>数据控制语言</strong>（了解）</p>
<ul>
<li>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANY，REVOKE 等。</li>

</ul>
<p>&nbsp;</p>]]></description></item><item><title>数据库知识总结</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11190999.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 15 Jul 2019 11:43:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/15/11190999.html</guid><description><![CDATA[<h1>数据库知识总结</h1>
<h2>本节内容</h2>
<p><strong>1.数据库的基本概念</strong></p>
<p><strong>2.MySQL数据库软件</strong></p>
<ol>
<li>安装</li>
<li>卸载</li>
<li>配置</li>
</ol>
<p><strong>3.SQL</strong></p>
<h2>数据库的基本概念</h2>
<p>1.数据库的英文单词：<strong>DataBase 简称：DB</strong><br />2.什么是数据库？</p>
<ul>
<li>用于存储和管理数据的仓库</li>


</ul>
<p>3.数据库的特点：</p>
<ol>
<li>持久化存储数据。其实数据库就是一个文件系统</li>
<li>方便存储和管理数据</li>
<li>使用了统一的方式操作数据库 -- SQL</li>


</ol>
<p>4.常见的数据库软件</p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201907/1444343-20190715193843077-1841892066.png" alt="" /></p>
<p>&nbsp;</p>
<h2>MySQL数据库软件</h2>
<p>MySQL的安装在博客中比较多也比较全，这里就不一一截图。<br /><strong>主要讲解下MySQL的卸载</strong></p>
<p><br />1.安装<br />参见博客</p>
<p><strong>2.卸载</strong><br />1.去mysql的安装目录找到my.ini文件并打开</p>
<ul>
<li>复制datadir="C:/ProgramData/MySQL/MySQL Server 5.5/Data/"</li>


</ul>
<p>2.卸载MySQL<br /><br />3.删除C:/ProgramData目录下的MySQL文件夹 （隐藏文件）<br /><br /><strong>3.配置</strong><br />MySQL服务启动</p>
<ol>
<li>手动。</li>
<li>cmd--&gt; services.msc 打开服务的窗口</li>
<li>使用管理员打开cmd</li>


</ol>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span>net start mysql :启动mysql的服务
net stop mysql :关闭mysql的服务</span></pre>
</div>
<p>&nbsp;</p>
<p>MySQL登陆</p>
<div class="cnblogs_code">
<pre>1.mysql -uroot -<span>p密码
2.mysql -hip -uroot -<span>p 连目标的密码
3.mysql --host=ip --user=root --password=连接目标的密码</span></span></pre>
</div>
<p>&nbsp;</p>
<p>MySQL退出</p>
<div class="cnblogs_code">
<pre>1<span>.exit
2.quit</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>MySQL目录结构</strong></p>
<p>1.MySQL安装目录<br />配置文件&nbsp;<strong>my.ini</strong></p>
<p><br />2.MySQL数据目录</p>
<ul>
<li>几个概念<ol>
<li>数据库:文件夹</li>
<li>表：文件</li>
<li>数据:数据</li>


</ol></li>
</ul>]]></description></item><item><title>Java学习：数据库连接池技术</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/07/11146348.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 07 Jul 2019 07:09:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/07/11146348.html</guid><description><![CDATA[<p><strong>本节内容</strong></p>
<ol>
<li>数据库连接池</li>
<li>Spring JDBC ： JDBC Template</li>
</ol>
<h2>数据库连接池</h2>
<p><strong>1.概念：</strong>其实就是一个容器（集合），存放数据库连接的容器</p>
<ul>
<li>当系统初始化好后，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器</li>
</ul>
<p><strong>2.好处:</strong></p>
<ol>
<li>节约资源</li>
<li>用户访问高效</li>
</ol>
<p><strong>3.实现：</strong><br />	1.标准接口： DataSource javax.sql包下的<br /><strong>方法：</strong></p>
<ol>
<li><strong>获取连接：getConnection()</strong></li>
<li><strong>归还连接：Connection.close()</strong>。如果连接对象Connection是从连接池中获取的，那么调用connection.close()，方法，则不会再关闭连接了。而是归还连接</li>

</ol>
<p>	2.一般我们不会去实现它，有数据库厂商来实现</p>
<ol>
<li><strong>C3P0：</strong>数据库连接池技术</li>
<li><strong>Druid:</strong>数据库连接池实现技术，由阿里巴巴提供的</li>
</ol>
<p>&nbsp;</p>
<h2><strong>4.C3P0：数据库连接池技术</strong></h2>
<p><strong> 步骤：</strong></p>
<p><strong>	1.导入jar包(两个)</strong> c3p0-0.9.5.2.jar  mchange-commons-java-0.2.12.jar</p>
<ul>
<li>		不要忘记导入数据库驱动jar包</li>

</ul>
<p><strong>	2.定义配置文件</strong>：</p>
<ul>
<li>		名称：c3p.properties 或者 c3p0-config.xml</li>
<li>		路径：直接将文件放在src目录下即可。</li>

</ul>
<p><strong>	3.创建核心对象</strong>，数据库连接池对象 ComboPooledDataSource</p>
<p><strong>	4.获取连接：</strong>getConnection</p>
<p>&nbsp;</p>
<h2>5.Druid:数据库连接池实现技术，由阿里巴巴提供的</h2>
<p><strong>步骤：	</strong><br />	<strong>1.导入jar包</strong> druid -1.0.9.jar<br />	<strong>2.定义配置文件：</strong> </p>
<ul>
<li>	  是properties形式的</li>
<li>	  可以叫任意名称，可以放在任意目录下</li>

</ul>
<p><strong>	3.加载配置文件。</strong> Properties<br />	<strong>4.获取数据库连接池对象：</strong>通过工厂类来获取 DruidDataSourceFactory<br />	<strong>5.获取连接：</strong>getConnection</p>
<p>&nbsp;</p>
<p><br /><strong>定义工具类</strong></p>
<ol>
<li><strong>定义一个类</strong> JDBCUtils</li>
<li><strong>提供静态代码块加载配置文件，初始化连接池对象</strong></li>
<li><strong>提供方法</strong></li>

</ol>
<ul>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>

</ul>
<h2>&nbsp;</h2>
<h2>Spring JDBC</h2>
<p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
<p><strong>步骤：</strong><br />	<strong>1.导入jar包</strong><br />	<strong>2.创建JdbcTemplate对象</strong>。依赖于数据源DataSource</p>
<div class="cnblogs_code">
<pre>JdbcTemplate template = <span style="color: #0000ff;">new</span> JdbcTemplate(ds);</pre>
</div>
<p><strong> 3.调用JdbcTempate的方法来完成CRUD的操作</strong><br /><strong>update():</strong>执行DML语句。增、删、改语句<br /><br /><strong>queryForMap()：</strong>查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p>
<ul>
<li>			注意：这个方法查询的结果集长度只能是1</li>

</ul>
<p><strong>queryForList()：</strong>查询结果将结果集封装为list集合</p>
<ul>
<li>		注意：将每一条记录封装为一个Map集合，再将Map集合封装到list集合中</li>

</ul>
<p><strong>query()：</strong>查询结果，将结果封装为JavaBean对象</p>
<ul>
<li>			query的参数：RowMapper </li>
<li>			 一般我们使用BeanPertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li>

</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">new</span> BeanPropertyRowMapper&lt;类型&gt;(类型.<span style="color: #0000ff;">class</span>)</pre>
</div>
<p><strong> queryForObject()：</strong>查询结果，将结果封装为对象</p>
<ul>
<li>一般用于聚合函数查询</li>
</ul>]]></description></item><item><title>Java学习：JDBC各类详解</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/07/11146258.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 07 Jul 2019 06:45:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/07/11146258.html</guid><description><![CDATA[<h2 style="text-align: center;">&nbsp;JDBC各个类详解</h2>
<p><strong>代码实现：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">1.导入驱动jar包
</span><span style="color: #008000;">//</span><span style="color: #008000;">2.注册驱动</span>
Class.forName("com.mysql.jdbc.Driver"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">3.获取数据库连对象</span>
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3","root","password"<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">4.定义sql语句</span>
String sql = "update account set balance = 500 where id = 1"<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">5.获取执行sql语句的对象 Statement</span>
Statement stmt =<span style="color: #000000;"> conn.createStatement();
</span><span style="color: #008000;">//</span><span style="color: #008000;">6.执行sql</span>
<span style="color: #0000ff;">int</span> count =<span style="color: #000000;"> stmt.executeUpdate(sql);
</span><span style="color: #008000;">//</span><span style="color: #008000;">7.处理结果</span>
<span style="color: #000000;">System.out.println(count);
</span><span style="color: #008000;">//</span><span style="color: #008000;">8.释放结果</span>
<span style="color: #000000;">stmt.close();
conn.close();</span></pre>
</div>
<h2>详解各个对象</h2>
<h3>1. DriverManager:驱动管理对象</h3>
<p><strong>功能：</strong></p>
<p><strong> 1.注册驱动：</strong>告诉程序该使用哪一个数据库驱动jar</p>
<ul>
<li><strong> static void registerDriver(Driver driver):</strong>注册与给定的驱动程序DriverManager</li>
</ul>
<div class="cnblogs_code">
<pre>写代码使用：Class.forName("com.mysql.jdbc.Driver");</pre>
</div>
<p><strong> 注意：</strong>mysql5之后的驱动jar包可以省略注册驱动的步骤。</p>
<p><strong> 2.获取数据库连接</strong></p>
<p><strong> *方法：</strong>static Connection getConnection(String url, String user, String password)<br /><strong>*参数：</strong><br />			　　<strong>*url：</strong>指定连接的路径</p>
<ul>
<li>语法：jdbc:mysql://ip地址（域名）：端口号/数据库名称</li>
<li>例子：jdbc：mysql://localhost:3306/db3</li>
<li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc：mysql：///数据库名称</li>

</ul>
<p>			　<strong>　*user</strong>:用户名<br />			　<strong>　*password：</strong>密码</p>
<h3><br />2. Connection：数据库连接对象</h3>
<p><strong>功能：</strong></p>
<p><strong>1.获取执行sql语句的对象</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Statement createStatement()
PreParedStatement perpareStatement(String sql)</span></pre>
</div>
<p><strong> 2.管理事务：</strong></p>
<ul>
<li><strong>开启事务：</strong>setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务</li>
<li><strong>提交事务：</strong>commit()</li>
<li><strong>回滚事务：</strong>rollback()</li>
</ul>
<p>&nbsp;</p>
<h3>3. Statement：执行sql的对象</h3>
<p><strong>执行sql</strong><br /><strong>1.Boolean execute(String sql ):</strong>可以执行任意的sql （了解）<br /><strong>2.int executeUpdate(String sql ):</strong>执行DML（<strong>insert,update,delete)</strong>语句、DDL<strong>（create，later，drop）</strong>语句</p>
<ul>
<li><strong>返回值：</strong>影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败</li>

</ul>
<p><strong>	3.ResultSet executeQuery(String sql)</strong> :执行DQL（<strong>select）</strong>语句</p>
<p>&nbsp;</p>
<h3>4. ResultSet：结果集对象，封装查询结果</h3>
<p><strong> 1.boolean next():</strong>游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据），如果是，则返回false，如果不是则返回true<br /><strong>2.getXxx（参数）：</strong>获取数据</p>
<ul>
<li>Xxx：代表数据类型 如：int getInt(),String getString()</li>
<li>参数：</li>

</ul>
<div class="cnblogs_code">
<pre>1.<span style="color: #0000ff;">int</span>：代表列的编号，从1开始 如：getString(1<span style="color: #000000;">)
</span>2.string:代表列名称。 如：getDouble("balance")\</pre>
</div>
<p><strong>注意：</strong><br />使用步骤：</p>
<ol>
<li>游标向下移动一行 </li>
<li>判断是否有数据</li>
<li>获取数据</li>

</ol>
<h3>&nbsp;</h3>
<h3>5. PreparedStatement：执行sql的对象</h3>
<p><strong>1.SQL注入问题：</strong>在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p>
<ul>
<li>	1.输入用户（随便），输入密码：a' or 'a' = 'a</li>
<li>	2.sql:select * from user where username = 'shhshdcainiao' and password =  ' a' or 'a' = 'a '</li>

</ul>
<p><strong>2.解决sql注入问题：</strong>使用PreparedStatement对象来解决<br /><strong>3.预编译的SQL：</strong>参数使用&nbsp; &nbsp;<strong>？</strong>作为<strong>占位符</strong><br /><strong>4.步骤：</strong></p>
<ul>
<li>	1.导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li>
<li>	2.注入驱动</li>
<li>	3.获取数据库连对象 Connection </li>
<li>	4.定义sql</li>
<li>	5.获取执行sql语句的对象 Statement</li>
<li>	6.执行sql ，接受返回结果</li>
<li>	7.处理结果</li>
<li>	8.释放资源</li>

</ul>
<p><strong>5.注意：</strong>后期都会使用 PreparedStatement来完成增删改查的所有操作</p>
<ul>
<li>	1.可以防止SQL注入</li>
<li>	2.效率更高</li>

</ul>
<p>&nbsp;</p>
<h2>JDBC控制事物</h2>
<p><strong>1.事物</strong>：一个包含多个步骤的业务操作。如果这个业务操作被事物管理，则这多个步骤要么同时成功，要么同时失败<br /><strong>2.操作</strong>：</p>
<ul>
<li>	1.开启事务</li>
<li>	2.提交事务：</li>
<li>	3.回滚事务：</li>

</ul>
<p><strong>3.使用Connection对象来管理事务</strong><br /><strong>开启事务：setAutoCommit(boolean autoCommit):</strong>调用该方法设置参数为false，即开启事务</p>
<ul>
<li>在执行sql之前开启事务</li>

</ul>
<p><strong>	提交事务：commit()</strong></p>
<ul>
<li>当所有sql的都执行完提交事务</li>

</ul>
<p><strong>	回滚事务：rollback()</strong></p>
<ul>
<li>在catch中回滚事务</li>

</ul>
<h2>&nbsp;</h2>
<h2>抽取JDBC工具类：JDBCUtils</h2>
<p><strong>	目的：</strong>简化书写<br /><strong>分析：</strong></p>
<ul>
<li>		1.注册驱动来抽取</li>
<li>		2.抽取一个方法获取连接对象</li>

</ul>
<p><strong> 需求：</strong>不想传递参数（麻烦），还得保证工具类的通用性。<br />			<strong>解决：</strong>配置文件</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">jdbc.properties
url </span>=<span style="color: #000000;">
user </span>=<span style="color: #000000;"> 
password </span>=</pre>
</div>
<ul>
<li>3.抽取一个方法释放资源</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：JDBC快速入门</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/04/11131043.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 04 Jul 2019 02:50:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/04/11131043.html</guid><description><![CDATA[<p><br /><strong>本节类容</strong></p>
<ol>
<li>JDBC基本概念</li>
<li>快速入门</li>


</ol>
<h2>JDBC基本概念</h2>
<p><strong>概念：</strong></p>
<ul>
<li>Java DataBase Connectivity Java 数据库连接，Java语言操作数据库</li>


</ul>
<p><br /><strong>JDBC本质：</strong></p>
<ul>
<li>其实是官方（sun公司）定义的一套操作所有关系数据库的规则，<strong>即接口。</strong></li>
<li>各个数据库厂商去实现这套接口，提供数据库<strong>驱动jar包。</strong></li>
<li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的<strong>实现类。</strong></li>


</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Person接口

Worker类

Person p </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Worler();

p.eat();</span></pre>
</div>
<p>&nbsp;</p>
<p><strong><img src="https://img2018.cnblogs.com/blog/1444343/201907/1444343-20190704103939281-965832980.png" alt="" /></strong></p>
<p>&nbsp;</p>
<h2>快速入门</h2>
<p><strong>步骤：</strong></p>
<ol>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li>


</ol>
<ul>
<li>	1.复制 mysql-connector-java-5.1.37-bin.jar 到项目的libs目录下</li>
<li>	2.右键 --&gt; Add As Library</li>


</ul>
<ol>
<li>注册驱动</li>
<li>获取数据库连对象 Connection</li>
<li>定义sql</li>
<li>获取执行sql语句的对象 Statement</li>
<li>执行sql，接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>


</ol>
<div class="cnblogs_code">
<pre><span style="color: #000000;">JDBC快速入门

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.sql.Connection;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.sql.DriverManager;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.sql.Statement;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> JdbcCaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception{
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">1.导入驱动jar包
        </span><span style="color: #008000;">//</span><span style="color: #008000;">2.注册驱动</span>
        Class.forName("com.mysql.jdbc.Driver"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">3.获取数据库连对象</span>
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3","root","password"<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">4.定义sql语句</span>
        String sql = "update account set balance = 500 where id = 1"<span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">5.获取执行sql语句的对象 Statement</span>
        Statement stmt =<span style="color: #000000;"> conn.createStatement();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">6.执行sql</span>
        <span style="color: #0000ff;">int</span> count =<span style="color: #000000;"> stmt.executeUpdate(sql);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">7.处理结果</span>
<span style="color: #000000;">        System.out.println(count);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">8.释放结果</span>
<span style="color: #000000;">        stmt.close();
        conn.close();
        
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：内部类的概念于分类</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/03/11129279.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 03 Jul 2019 13:40:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/03/11129279.html</guid><description><![CDATA[<h2>内部类的概念于分类</h2>
<p><strong>如果一个事物的内部类包含另一个事物，那么这就是一个类内部包含另一个类。</strong><br />例如：身体和心脏的关系，又如：汽车和发动机的关系。</p>
<p>&nbsp;</p>
<h2>分类</h2>
<ol>
<li>成员内部类</li>
<li>局部内部类（包含匿名内部类）</li>

</ol>
<div class="cnblogs_code">
<pre><span style="color: #000000;">成员内部类的定义格式：
修饰符 </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 外部类名称{
    修饰符 </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 内部类名称{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">。。。</span>
<span style="color: #000000;">    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">。。。</span>
}</pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>内用外，随意访问；外用内，需要内部类对象。</li>
<li>生成的.class文件名字：外部类$内部类.class</li>
</ul>
<p>&nbsp;</p>
<h2>如何使用成员内部类？有两种方式</h2>
<ol>
<li>间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。</li>
<li>直接方式：</li>
</ol>
<div class="cnblogs_code">
<pre><span style="color: #000000;">公式：
类名称 对象名 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> 类名称();
【外部类名称.内部类名称 对象名 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> 外部类名称().new内部类名称();】

 </span></pre>
</div>
<p>&nbsp;</p>
<h2>内部类的同名变量访问</h2>
<p>如果出现了重名现象，</p>
<div class="cnblogs_code">
<pre>那么格式是：外部类名称.<span style="color: #0000ff;">this</span><span style="color: #000000;">.外部类成员变量名
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Outer{
    
    </span><span style="color: #0000ff;">int</span> num 10;<span style="color: #008000;">//</span><span style="color: #008000;">外部类的成员变量</span>
    
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Inner{
        
        </span><span style="color: #0000ff;">int</span> num = 20;<span style="color: #008000;">//</span><span style="color: #008000;">内部类的成员变量</span>
        
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> methodInner(){
            </span><span style="color: #0000ff;">int</span> num = 30;<span style="color: #008000;">//</span><span style="color: #008000;">内部类方法的局部变量</span>
            System.out.println(num );<span style="color: #008000;">//</span><span style="color: #008000;">局部变量，就近原则</span>
            System.out.println(<span style="color: #0000ff;">this</span>.num );<span style="color: #008000;">//</span><span style="color: #008000;">内部类的成员变量</span>
            System.out.println(Outer.<span style="color: #0000ff;">this</span>.num );<span style="color: #008000;">//</span><span style="color: #008000;">外部类的成员变量</span>
<span style="color: #000000;">        }
        
    }
}<br /></span></pre>
</div>
<h2>&nbsp;</h2>
<h2>局部内部类定义</h2>
<p><strong>如果一个类是定义在一个方法内部的，那么这就是一个局部内部类</strong><br /><strong>&lsquo;局部&rsquo;：</strong>只有当前所属的方法才能使用它，出了这个方法外面就不能用了。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">定义格式：
修饰符 </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 外部类名称{
    修饰符 返回值类型 外部类方法名称（参数列表）{
        </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 局部内部类名称{
            </span><span style="color: #008000;">//</span><span style="color: #008000;">。。。</span>
<span style="color: #000000;">        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<h2>小结一下类的权限修饰符；</h2>
<p><strong>public &gt; protected &gt; (default) &gt;private</strong><br />定义一个类的时候，权限修饰符规则：</p>
<ol>
<li><strong>外部类：</strong>public / （default)只能是这两种</li>
<li><strong>成员内部类：</strong>public / protected /(default) /private都可以</li>
<li><strong>局部内部类：</strong>什么都不能写</li>

</ol>
<h2>&nbsp;</h2>
<h2>局部内部类的final问题</h2>
<p><strong>局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。</strong></p>
<p><strong>备注</strong>：</p>
<ul>
<li>从Java 8+开始，只有局部变量事实不变，那么final关键字可以省略不写。</li>

</ul>
<p><strong>原因：</strong></p>
<ol>
<li>new出来的对象在推内存当中。</li>
<li>局部变量是跟着方法走的，在栈内存当中</li>
<li>方法运行结束之后，立刻出栈，局部变量就会立刻消失。</li>
<li>但是new出来的对象会在推当中持续存在，直到垃圾回收消失。</li>

</ol>
<h2>匿名内部类</h2>
<p><strong>如果接口的实现类（或者是父类的子类）只需要使用唯一的一次。</strong><br /><strong>那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】</strong></p>
<p>匿名内部类的定义格式：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">匿名内部类的定义格式：
接口名称 对象名称 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> 接口名称(){
    </span><span style="color: #008000;">//</span><span style="color: #008000;">覆盖重写所有的抽象方法</span>
};<span style="color: #008000;">//</span><span style="color: #008000;">分号不能省略</span></pre>
</div>
<p>&nbsp;</p>
<h2>对格式"new 内部类名称 接口名称() {...}"进行解析</h2>
<ol>
<li><strong>new代表创建对象的动作</strong></li>
<li><strong>接口名称就是匿名内部类需要实现那个接口</strong></li>
<li><strong>{...}这才是匿名内部类的内容</strong></li>
</ol>
<p><strong>另外还需要注意几点问题：</strong><br />1.匿名内部类，在<strong>【创建对象】</strong>的时候，只能使用唯一一次。</p>
<ul>
<li>如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。</li>

</ul>
<p>2.匿名对象，在<strong>【调用方法】</strong>的时候，只能调用唯一一次。</p>
<ul>
<li>如果希望同一个对象，调用多次方法，那么必须给对象起一个名字。</li>

</ul>
<p>3.匿名内部类是省略了<strong>【实现类/子类名称】</strong>，但是匿名对象是省略了<strong>【对象名称】</strong></p>
<ul>
<li>强调：匿名内部类和匿名对象不是一回事！！！</li>

</ul>]]></description></item><item><title>Java四种权限修饰符 在创建类中的使用</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/03/11129200.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 03 Jul 2019 13:26:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/03/11129200.html</guid><description><![CDATA[<h2 style="text-align: center;"><br />四种权限修饰符</h2>
<p><br /><strong>Java中有四种权限修饰符</strong></p>
<p><strong>public &gt; protected &gt; (default) &gt;private</strong></p>
<p><strong>同一个类（我自己）</strong> 	YES YES YES YES<br /><strong>同一个包（我儿子）</strong>  YES YES YES NO<br /><strong>不同包子类（我邻居）</strong>YES YES NO NO<br /><strong>不同包非子类（陌生人）</strong>YES NO NO NO</p>
<p><strong>注意事项：</strong><br /><strong>（default）并不是关键字&ldquo;default&rdquo;，而是根本不写</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> num = 37<span style="color: #000000;">;
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">int</span> num = 37<span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> num = 37<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> num = 37<span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：final关键字的使用与注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/03/11129165.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 03 Jul 2019 13:19:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/03/11129165.html</guid><description><![CDATA[<p><strong>final 关键字代表最终、不可改变的。</strong></p>
<h2>常见的四种用法</h2>
<ol>
<li>可以用来修饰一个类</li>
<li>可以用来修饰一个方法</li>
<li>可以用来修饰一个局部变量</li>
<li>可以用来修饰一个成员变量</li>
</ol>
<p>1.<br /><strong>当final关键字用来修饰一个类的时候，格式：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名称{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">。。。</span>
}</pre>
</div>
<p><strong>含义：</strong></p>
<ul>
<li>当前这个类不能有任何的子类。（太监类）</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没有儿子）。</li>
</ul>
<p><br />2.<br /><strong>当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写的。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
修饰符 </span><span style="color: #0000ff;">final</span><span style="color: #000000;"> 返回值类型 方法名称（参数列表）{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">方法体</span>
}</pre>
</div>
<p><strong>注意事项：</strong></p>
<ul>
<li>对于类、方法来，abstract关键字和final关键字不能同时使用，因为矛盾。</li>
</ul>
<p>3.<br /><strong>一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。</strong><br />&lsquo;一次赋值，终身不变&rsquo;</p>
<ol>
<li>对于基本类型来说，不可变说的是变量当中的数据不可改变</li>
<li>对于引用类型来说，不可变说的是变量当中的地址值不可改变</li>

</ol>
<p>4.<br /><strong>对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。</strong></p>
<ol>
<li>对于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了</li>
<li>对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。</li>
<li>必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。</li>

</ol>]]></description></item><item><title>Java学习：面向对象三大特征：封装性、继承性、多态性之多态性。</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/01/11115399.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 01 Jul 2019 09:23:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/01/11115399.html</guid><description><![CDATA[<h2 style="text-align: center;"><strong>面向对象三大特征：封装性、继承性、多态性之多态性。</strong></h2>
<p><strong>extends继承或者implemens实现，是多态性的前提。</strong></p>
<p><strong>例如：</strong><br />小菜是一个学生，但同时也是一个人。<br />小菜是一个对象，这个对象既有学生形态，也有人类形态。<br /><strong>一个对象拥有多种形态，这就是：【对象的多态性】</strong></p>
<h2>多态的格式与使用</h2>
<p>代码当中体现多态性，其实就是一句话<strong>：父类引用指向子类对象。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
分类名称 对象名 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> 子类名称();
或者：
接口名称 对象名 </span>= <span style="color: #0000ff;">new</span> 实现类名称();</pre>
</div>
<p>&nbsp;</p>
<h2>访问成员变量的两方式</h2>
<p>1.直接通过<strong>对象名称访问成员变量：</strong>看等号左边是谁，优先用谁，没有则向上找。</p>
<div class="cnblogs_code">
<pre>Fu obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
System.out.println(obj.num);</span><span style="color: #008000;">//</span><span style="color: #008000;">Fu</span></pre>
</div>
<p>&nbsp;</p>
<p>2.间接通过<strong>成员方法访问成员变量：</strong>看该方法属于谁，优先用谁，没有则向上找。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">子类没有覆盖重写，就是父
</span><span style="color: #008000;">//</span><span style="color: #008000;">子类如果覆盖重写，就是子</span>
obj.showNum();</pre>
</div>
<h2>&nbsp;</h2>
<h2>在多态的代码中，成员方法的访问规则是</h2>
<p> <strong>看new的谁，就优先用谁，没有则向上找。</strong><br />	<br /><strong>口诀：编译看左边，运行看右边。</strong></p>
<p><strong>对比一下：</strong></p>
<ul>
<li><strong>成员变量</strong>：编译看左边，运行还是看左边。</li>
<li><strong>成员方法：</strong>编译看左边，运行看右边。</li>

</ul>
<div class="cnblogs_code">
<pre>Fu obj = <span style="color: #0000ff;">new</span> Zi();<span style="color: #008000;">//</span><span style="color: #008000;">多态</span>
<span style="color: #000000;">
obj.method();</span><span style="color: #008000;">//</span><span style="color: #008000;">父子都有，优先用子</span>
obj.methodFu();<span style="color: #008000;">//</span><span style="color: #008000;">子类没有父类有，向上找父类</span></pre>
</div>
<p><strong>多态的好处</strong>：<br />无论右边new的时候换成那个子类对象，等号左边调用方法都不会变化。</p>
<h2>向上转型和向下转型：</h2>
<p><strong>1.对象的向上转型，其实就是多态的写法</strong>：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式:
父类名称 对象名 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> 子类名称();
Animal animal </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();
(创建了一只猫，当作动物看待，没问题)</span></pre>
</div>
<p><strong>含义：</strong></p>
<ul>
<li>右侧创建了一个子类对象，把它当作父类来看待使用。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><strong>向上转型一定是安全的。</strong>从小范围转向的大范围，从小范围的猫，向上转换成为了更大范围的动物。</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">类似于：
</span><span style="color: #0000ff;">double</span> num = 100:<span style="color: #008000;">//</span><span style="color: #008000;">正确，int&mdash;&mdash;&gt;double,自动类型转换</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>向上转型一定是安全的，没有问题的，正确的。</strong>但是有一个弊端，对象一旦向上转型为父类，那么就无法调用子类原有的内容。<br />解决方法：用对象的向下转型【还原】</p>
<p>&nbsp;</p>
<p><strong>2.对象的向下转型，其实是一个[还原]的动作。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
子类名称 对象名 </span>=<span style="color: #000000;"> （子类名称） 父类对象;
Animal animal </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Cat();本来是猫，向上转型为动物
Cat cat </span>= (Cat) animal;<span style="color: #008000;">//</span><span style="color: #008000;">本来是猫，已经被当中动物了，还原回来成为本来的猫</span></pre>
</div>
<p><strong>含义：</strong></p>
<ul>
<li>将父类对象，<strong>【还原】</strong>成为本来的子类对象。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>必须<strong>保证对象本来创建的时候</strong>，就是猫，才能向下转型成为猫。</li>
<li>如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错。<strong>ClassCastException</strong></li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;">类似于：
</span><span style="color: #0000ff;">int</span> num = (<span style="color: #0000ff;">int</span>) 10.0;<span style="color: #008000;">//</span><span style="color: #008000;">可以</span>
<span style="color: #0000ff;">int</span> num = (<span style="color: #0000ff;">int</span>) 10.6;<span style="color: #008000;">//</span><span style="color: #008000;">不可以</span></pre>
</div>
<p>&nbsp;</p>
<h2>如何才能知道一个父类引用的对象，本来是什么子类？</h2>
<p>格式：</p>
<div class="cnblogs_code">
<pre>对象 <span style="color: #0000ff;">instanceof</span> 类名称</pre>
</div>
<p>这将会得到一个<strong>boolean值结果，</strong>也就是判断前面的对象不能当作后面类型的实例。</p>
<div class="cnblogs_code">
<pre>Animal animal = <span style="color: #0000ff;">new</span> Dog();<span style="color: #008000;">//</span><span style="color: #008000;">本来是一只狗</span>
animal.eat();<span style="color: #008000;">//</span><span style="color: #008000;">狗吃骨头
</span><span style="color: #008000;">//</span><span style="color: #008000;">如果希望调用子类特有的方法，需要向下转型
</span><span style="color: #008000;">//</span><span style="color: #008000;">判断一下父类引用的animal本来是不是Dog</span>
<span style="color: #0000ff;">if</span>(animal <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Dog){
    Dog dog </span>=<span style="color: #000000;"> (Dog) animal;
    dog.watchHouse();
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">判断一下animal本来是不是Cat</span>
<span style="color: #0000ff;">if</span>(animal <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Cat ){
    Cat cat </span>=<span style="color: #000000;"> (Cat) animal;
    cat.catchMouse();
}</span></pre>
</div>]]></description></item><item><title>Java学习：接口（interface）的使用于注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/01/11115251.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 01 Jul 2019 09:09:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/07/01/11115251.html</guid><description><![CDATA[<h2 style="text-align: center;">接口</h2>
<p><strong>接口就是一种公共的规范标准。</strong><br />只要符合规范标准，就可以大家通用。</p>
<p><strong>接口就是多个类的公共规范。</strong><br />接口是一种引用数据类型，最重要的内容就是其中的:<strong>抽象方法。</strong></p>
<h2>如何定义一个接口的格式</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">如何定义一个接口的格式：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> 接口名称{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">接口内容</span>
}</pre>
</div>
<p>备注：换成了关键字interface之后，编译生成的字节码文件仍然是：<br /><strong>.java --&gt;.class</strong></p>
<h2>&nbsp;接口包含的内容</h2>
<p>如果是Java 7，那么接口中可以包含的内容有：<br /><strong>1.常量</strong><br /><strong>2.抽象方法</strong></p>
<p>如果是Java 8，还可以额外包含有：<br /><strong>3.默认方法</strong><br /><strong>4.静态方法</strong></p>
<p>如果是Java 9，还可以额外包含有：<br /><strong>5.私有方法</strong></p>
<h2><br />接口中的抽象方法的调用</h2>
<p>在任何版本的Java中，接口都能定义抽象方法。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> 返回值类型 方法名称（参数列表）；</pre>
</div>
<p><strong>注意事项：</strong></p>
<ol>
<li>接口当中的抽象方法，修饰符必须是两固定的关键字：public abstract</li>
<li>这两关键字修饰符，可以选择性的省略。</li>
<li>方法的三要素，可以随意定义。</li>
</ol>
<h2>接口使用步骤</h2>
<p>1.接口不能直接使用，必须有一个<strong>&ldquo;实现类&rdquo;</strong>来&ldquo;实现&rdquo;该接口。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> 实现类名称 <span style="color: #0000ff;">implements</span><span style="color: #000000;"> 接口名称{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 。。。</span>
}</pre>
</div>
<p>2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。<br /><strong>实现：去掉abstract关键字，加上方法体大括。</strong></p>
<p>3.创建实现类的对象，进行使用。<br /><strong>注意事项：</strong><br />如果实现类并没有覆盖重写接口中的所有的抽象方法，那么这个实现类自己就必须是抽象类。</p>
<h2>在Java 9+版本中,接口的内容可以有</h2>
<p><strong>1.成员变量其实就是常量</strong>，</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
[</span><span style="color: #0000ff;">public</span>] [<span style="color: #0000ff;">static</span>] [<span style="color: #0000ff;">final</span>] 数据类型 常量名称 = 数据值；</pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>常量必须进行赋值，而且一旦赋值不能改变。</li>
<li>常量名称完全大写，用下划线进行分隔。</li>
<li><strong> 【方法可以覆盖重写】</strong></li>
<li><strong> 【常量不可以覆盖重写】</strong></li>
</ul>
<p><strong>2，接口中最重要的就是抽象方法，</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
[</span><span style="color: #0000ff;">public</span>] [<span style="color: #0000ff;">abstract</span>] 返回值类型 方法名称（参数列表）；</pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>实现类必须覆盖重写（实现）接口中所有的抽象方法。除非实现类是抽象类。</li>
</ul>
<p><strong>3.从Java 8开始，接口里允许定义默认方法。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
[</span><span style="color: #0000ff;">public</span><span style="color: #000000;">] defaul 返回值类型 方法名称（参数列表）{
    方法体
}</span></pre>
</div>
<p><strong>注意</strong>：</p>
<ul>
<li>默认方法也可以被覆盖重写</li>
</ul>
<p><strong>备注</strong>：</p>
<ul>
<li>接口当中的默认方法，可以解决接口升级的问题。</li>
</ul>
<p><strong>4.从Java 8开始，接口里允许定义静态方法。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
[</span><span style="color: #0000ff;">public</span>] <span style="color: #0000ff;">static</span><span style="color: #000000;"> 返回值类型 方法名称（参数列表）{
    方法体
}</span></pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</li>
</ul>
<p><strong>5.从Java 9开始，接口允许定于私有方法。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
普通私有方法：</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> 返回值类型 方法名称（参数列表）{
    方法体
}
静态私有方法：</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> 返回值类型 方法名称（参数列表）{
    方法体
}</span></pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>private的方法只有接口自己才能调用，不能被实现类或别人使用。</li>
</ul>
<h2>接口之间的多继承</h2>
<ol>
<li>类与类之间是单继承的。直接父类只有一个。</li>
<li>类与接口之间是多实现的。一个类可以实现多个接口。、</li>
<li>接口与接口之间是多继承的。</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol>
<li>多个父接口当中的抽象方法如果重复，没关系。</li>
<li>多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写。<strong>【而且带有defaul关键字】</strong></li>
</ol>
<p>&nbsp;</p>]]></description></item><item><title>目录： 其他</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110820.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 11:08:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110820.html</guid><description><![CDATA[<h2 style="text-align: center;">&nbsp;其他</h2>
<ul>
<li><strong><a id="post_title_link_11041924" href="https://www.cnblogs.com/cainiao-chuanqi/p/11041924.html">Windows中DOS简单命令的总结</a></strong></li>
<li><strong><a id="post_title_link_11051813" href="https://www.cnblogs.com/cainiao-chuanqi/p/11051813.html">JDK9版本以上Java独有的一个轻量级小工具，你知道吗？jshell</a></strong></li>
</ul>]]></description></item><item><title>目录：面向对象设计模式</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110812.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 11:06:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110812.html</guid><description><![CDATA[<hr />
<h2 style="text-align: center;">&nbsp;面向对象设计模式</h2>
<ul>
<li><strong>&nbsp;<a id="post_title_link_10957617" href="https://www.cnblogs.com/cainiao-chuanqi/p/10957617.html">面向对象设计模式总结</a></strong></li>
<li><strong><a id="post_title_link_10957708" href="https://www.cnblogs.com/cainiao-chuanqi/p/10957708.html">23种设计模式</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10958780" href="https://www.cnblogs.com/cainiao-chuanqi/p/10958780.html">UML统一建模语言介绍</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10959800" href="https://www.cnblogs.com/cainiao-chuanqi/p/10959800.html">软件设计的七大原则</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10966300" href="https://www.cnblogs.com/cainiao-chuanqi/p/10966300.html">GoF的23种设计模式之创建型模式的特点和分类</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10978331" href="https://www.cnblogs.com/cainiao-chuanqi/p/10978331.html">GoF的23种设计模式之结构型模式的特点和分类</a></strong></li>
<li><strong><a id="post_title_link_10979160" href="https://www.cnblogs.com/cainiao-chuanqi/p/10979160.html">GoF的23种设计模式之行为型模式的特点和分类(1)</a></strong></li>
<li><strong><a id="post_title_link_10979389" href="https://www.cnblogs.com/cainiao-chuanqi/p/10979389.html">GoF的23种设计模式之行为型模式的特点和分类(2)</a></strong></li>
</ul>]]></description></item><item><title>目录：软件设计</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110810.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 11:05:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110810.html</guid><description><![CDATA[<h2 style="text-align: center;">软件设计</h2>
<ul>
<li><a id="post_title_link_10396585" href="https://www.cnblogs.com/cainiao-chuanqi/p/10396585.html"><strong>软考知识分析</strong></a></li>
<li><strong>软考自查：<a id="post_title_link_10418787" href="https://www.cnblogs.com/cainiao-chuanqi/p/10418787.html">面向对象设计</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10420491" href="https://www.cnblogs.com/cainiao-chuanqi/p/10420491.html">计算机组成原理和体系结构</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10427704" href="https://www.cnblogs.com/cainiao-chuanqi/p/10427704.html">操作系统基本原理</a></strong></li>
<li><strong>软考自查：<a href="https://www.cnblogs.com/cainiao-chuanqi/p/10433188.html">数据库系统</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10436628" href="https://www.cnblogs.com/cainiao-chuanqi/p/10436628.html">计算机网络</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10445858" href="https://www.cnblogs.com/cainiao-chuanqi/p/10445858.html">数据结构与算法基础</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10449519" href="https://www.cnblogs.com/cainiao-chuanqi/p/10449519.html">软件工程</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10452163" href="https://www.cnblogs.com/cainiao-chuanqi/p/10452163.html">信息安全基础知识</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10458382" href="https://www.cnblogs.com/cainiao-chuanqi/p/10458382.html">程序设计语言与语言处理程序基础</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10460476" href="https://www.cnblogs.com/cainiao-chuanqi/p/10460476.html">法律法规与标准化知识</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10464779" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464779.html">数据流图（DFD）</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10464843" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464843.html">数据库设计</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10464952" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464952.html">UML建模</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10469308" href="https://www.cnblogs.com/cainiao-chuanqi/p/10469308.html">面向对象设计</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10469692" href="https://www.cnblogs.com/cainiao-chuanqi/p/10469692.html">数据结构及算法应用</a></strong></li>
</ul>]]></description></item><item><title>目录 :python学习</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110809.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 11:04:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110809.html</guid><description><![CDATA[<h2 style="text-align: center;">python学习</h2>
<ul>
<li><strong><a href="https://www.cnblogs.com/cainiao-chuanqi/p/9406421.html" target="_blank">python第一阶段总结（1）</a></strong></li>
<li><strong><a href="https://www.cnblogs.com/cainiao-chuanqi/p/9407219.html" target="_blank">python第一阶段总结（2）</a></strong></li>
</ul>]]></description></item><item><title>目录：Java学习</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110806.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 11:03:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110806.html</guid><description><![CDATA[<h2 style="text-align: center;">&nbsp;Java学习</h2>
<h3>第一阶段</h3>
<ul>
<li><strong><a id="post_title_link_11041949" href="https://www.cnblogs.com/cainiao-chuanqi/p/11041949.html">Java学习：常量和变量 的定义和注意事项</a></strong></li>
<li><strong><a id="post_title_link_11045318" href="https://www.cnblogs.com/cainiao-chuanqi/p/11045318.html">Java学习：数据类型转换注意事项</a></strong></li>
<li><strong><a id="post_title_link_11046487" href="https://www.cnblogs.com/cainiao-chuanqi/p/11046487.html">Java学习：运算符的使用与注意事项</a></strong></li>
<li><strong><a id="post_title_link_11051843" href="https://www.cnblogs.com/cainiao-chuanqi/p/11051843.html">Java学习：switch语句使用的注意事项</a></strong></li>
<li><strong><a id="post_title_link_11052390" href="https://www.cnblogs.com/cainiao-chuanqi/p/11052390.html">java学习：循环结构的使用规则和注意事项</a></strong></li>
<li><strong><a id="post_title_link_11060933" href="https://www.cnblogs.com/cainiao-chuanqi/p/11060933.html">Java学习：方法的使用与注意事项</a></strong></li>
<li><strong><a id="post_title_link_11061116" href="https://www.cnblogs.com/cainiao-chuanqi/p/11061116.html">Java学习：方法重载的使用规则</a></strong></li>
<li><strong><a id="post_title_link_11066350" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066350.html">Java学习：数组的使用和注意事项</a></strong></li>
<li><strong><a id="post_title_link_11073986" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073986.html">Java学习： 面向对象的使用与注意事项</a></strong></li>
</ul>
<h3><strong>第二阶段</strong></h3>
<ul>
<ul>
<li><strong><a id="post_title_link_11066356" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066356.html">Java的内存需要划分成为5个部分</a><br /></strong></li>
<li><strong><a id="post_title_link_11073993" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073993.html">局部变量和成员变量的区别</a></strong></li>
<li><strong><a id="post_title_link_11073989" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073989.html">一个标准的类通常要拥有下面四个组成部分</a></strong></li>
<li><strong><a id="post_title_link_11090273" href="https://www.cnblogs.com/cainiao-chuanqi/p/11090273.html">常用Java API之Scanner：功能与使用方法</a></strong></li>
<li><strong><a id="post_title_link_11097312" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097312.html">Java中的匿名对象</a></strong></li>
<li><strong><a id="post_title_link_11097354" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097354.html">常用Java API之Ramdom--用代码模拟猜数小游戏</a></strong></li>
<li><a id="post_title_link_11097439" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097439.html"><strong>Java学习：集合的使用与数组的区</strong>别</a></li>




</ul>



</ul>]]></description></item><item><title>目录</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110801.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 11:01:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110801.html</guid><description><![CDATA[<h1 style="text-align: center;">目录</h1>
<ul>
<li>Linux</li>
<li>大数据</li>
<li>软件设计</li>
<li>爬虫，python</li>
<li>面向对象设计（Java）</li>
<li>项目总结</li>
<li>其他</li>
</ul>
<hr />
<h2 style="text-align: center;">&nbsp;面向对象设计模式</h2>
<ul>
<li><strong>&nbsp;<a id="post_title_link_10957617" href="https://www.cnblogs.com/cainiao-chuanqi/p/10957617.html">面向对象设计模式总结</a></strong></li>
<li><strong><a id="post_title_link_10957708" href="https://www.cnblogs.com/cainiao-chuanqi/p/10957708.html">23种设计模式</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10958780" href="https://www.cnblogs.com/cainiao-chuanqi/p/10958780.html">UML统一建模语言介绍</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10959800" href="https://www.cnblogs.com/cainiao-chuanqi/p/10959800.html">软件设计的七大原则</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10966300" href="https://www.cnblogs.com/cainiao-chuanqi/p/10966300.html">GoF的23种设计模式之创建型模式的特点和分类</a></strong></li>
<li><strong>&nbsp;<a id="post_title_link_10978331" href="https://www.cnblogs.com/cainiao-chuanqi/p/10978331.html">GoF的23种设计模式之结构型模式的特点和分类</a></strong></li>
<li><strong><a id="post_title_link_10979160" href="https://www.cnblogs.com/cainiao-chuanqi/p/10979160.html">GoF的23种设计模式之行为型模式的特点和分类(1)</a></strong></li>
<li><strong><a id="post_title_link_10979389" href="https://www.cnblogs.com/cainiao-chuanqi/p/10979389.html">GoF的23种设计模式之行为型模式的特点和分类(2)</a></strong></li>
</ul>
<h2>&nbsp;</h2>
<hr />
<h2 style="text-align: center;">软件设计</h2>
<ul>
<li><a id="post_title_link_10396585" href="https://www.cnblogs.com/cainiao-chuanqi/p/10396585.html"><strong>软考知识分析</strong></a></li>
<li><strong>软考自查：<a id="post_title_link_10418787" href="https://www.cnblogs.com/cainiao-chuanqi/p/10418787.html">面向对象设计</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10420491" href="https://www.cnblogs.com/cainiao-chuanqi/p/10420491.html">计算机组成原理和体系结构</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10427704" href="https://www.cnblogs.com/cainiao-chuanqi/p/10427704.html">操作系统基本原理</a></strong></li>
<li><strong>软考自查：<a href="https://www.cnblogs.com/cainiao-chuanqi/p/10433188.html">数据库系统</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10436628" href="https://www.cnblogs.com/cainiao-chuanqi/p/10436628.html">计算机网络</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10445858" href="https://www.cnblogs.com/cainiao-chuanqi/p/10445858.html">数据结构与算法基础</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10449519" href="https://www.cnblogs.com/cainiao-chuanqi/p/10449519.html">软件工程</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10452163" href="https://www.cnblogs.com/cainiao-chuanqi/p/10452163.html">信息安全基础知识</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10458382" href="https://www.cnblogs.com/cainiao-chuanqi/p/10458382.html">程序设计语言与语言处理程序基础</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10460476" href="https://www.cnblogs.com/cainiao-chuanqi/p/10460476.html">法律法规与标准化知识</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10464779" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464779.html">数据流图（DFD）</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10464843" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464843.html">数据库设计</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10464952" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464952.html">UML建模</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10469308" href="https://www.cnblogs.com/cainiao-chuanqi/p/10469308.html">面向对象设计</a></strong></li>
<li><strong>软考自查：<a id="post_title_link_10469692" href="https://www.cnblogs.com/cainiao-chuanqi/p/10469692.html">数据结构及算法应用</a></strong></li>
</ul>
<hr />
<h2 style="text-align: center;">python学习</h2>
<ul>
<li><strong><a href="https://www.cnblogs.com/cainiao-chuanqi/p/9406421.html" target="_blank">python第一阶段总结（1）</a></strong></li>
<li><strong><a href="https://www.cnblogs.com/cainiao-chuanqi/p/9407219.html" target="_blank">python第一阶段总结（2）</a></strong></li>
</ul>
<hr />
<h2 style="text-align: center;">&nbsp;Java学习</h2>
<h3>第一阶段</h3>
<ul>
<li><strong><a id="post_title_link_11041949" href="https://www.cnblogs.com/cainiao-chuanqi/p/11041949.html">Java学习：常量和变量 的定义和注意事项</a></strong></li>
<li><strong><a id="post_title_link_11045318" href="https://www.cnblogs.com/cainiao-chuanqi/p/11045318.html">Java学习：数据类型转换注意事项</a></strong></li>
<li><strong><a id="post_title_link_11046487" href="https://www.cnblogs.com/cainiao-chuanqi/p/11046487.html">Java学习：运算符的使用与注意事项</a></strong></li>
<li><strong><a id="post_title_link_11051843" href="https://www.cnblogs.com/cainiao-chuanqi/p/11051843.html">Java学习：switch语句使用的注意事项</a></strong></li>
<li><strong><a id="post_title_link_11052390" href="https://www.cnblogs.com/cainiao-chuanqi/p/11052390.html">java学习：循环结构的使用规则和注意事项</a></strong></li>
<li><strong><a id="post_title_link_11060933" href="https://www.cnblogs.com/cainiao-chuanqi/p/11060933.html">Java学习：方法的使用与注意事项</a></strong></li>
<li><strong><a id="post_title_link_11061116" href="https://www.cnblogs.com/cainiao-chuanqi/p/11061116.html">Java学习：方法重载的使用规则</a></strong></li>
<li><strong><a id="post_title_link_11066350" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066350.html">Java学习：数组的使用和注意事项</a></strong></li>
<li><strong><a id="post_title_link_11073986" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073986.html">Java学习： 面向对象的使用与注意事项</a></strong></li>
</ul>
<h3><strong>第二阶段</strong></h3>
<ul>
<li><strong><a id="post_title_link_11066356" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066356.html">Java的内存需要划分成为5个部分</a><br /></strong></li>
<li><strong><a id="post_title_link_11073993" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073993.html">局部变量和成员变量的区别</a></strong></li>
<li><strong><a id="post_title_link_11073989" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073989.html">一个标准的类通常要拥有下面四个组成部分</a></strong></li>
<li><strong><a id="post_title_link_11090273" href="https://www.cnblogs.com/cainiao-chuanqi/p/11090273.html">常用Java API之Scanner：功能与使用方法</a></strong></li>
<li><strong><a id="post_title_link_11097312" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097312.html">Java中的匿名对象</a></strong></li>
<li><strong><a id="post_title_link_11097354" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097354.html">常用Java API之Ramdom--用代码模拟猜数小游戏</a></strong></li>
<li><a id="post_title_link_11097439" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097439.html"><strong>Java学习：集合的使用与数组的区</strong>别</a></li>


</ul>
<hr />
<h2 style="text-align: center;">&nbsp;大数据</h2>
<ul>
<li><strong><a id="post_title_link_9463342" href="https://www.cnblogs.com/cainiao-chuanqi/p/9463342.html">大数据的行业与技术趋势</a></strong></li>
<li><strong><a id="post_title_link_10581017" href="https://www.cnblogs.com/cainiao-chuanqi/p/10581017.html">大数据学习路线</a></strong></li>
<li><strong><a id="post_title_link_11006061" href="https://www.cnblogs.com/cainiao-chuanqi/p/11006061.html">FusionInsight大数据开发学习总结</a></strong></li>
<li><strong><a id="post_title_link_11006088" href="https://www.cnblogs.com/cainiao-chuanqi/p/11006088.html">FusionInsight大数据开发---HDFS应用开发</a></strong></li>
<li><strong><a id="post_title_link_11010227" href="https://www.cnblogs.com/cainiao-chuanqi/p/11010227.html">FusionInsight大数据开发--HBase应用开发</a></strong>&nbsp;</li>


</ul>
<hr />
<h2 style="text-align: center;">&nbsp;其他</h2>
<ul>
<li><strong><a id="post_title_link_11041924" href="https://www.cnblogs.com/cainiao-chuanqi/p/11041924.html">Windows中DOS简单命令的总结</a></strong></li>
<li><strong><a id="post_title_link_11051813" href="https://www.cnblogs.com/cainiao-chuanqi/p/11051813.html">JDK9版本以上Java独有的一个轻量级小工具，你知道吗？jshell</a></strong></li>


</ul>
<hr />
<h2 style="text-align: center;">&nbsp;项目</h2>
<ul>
<li><strong><a id="post_title_link_11110442" href="https://www.cnblogs.com/cainiao-chuanqi/p/11110442.html">案例分析发红包</a></strong></li>
</ul>
<hr />
<p>&nbsp;</p>
<p><strong>更新中...</strong></p>]]></description></item><item><title>案例分析发红包</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110442.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 09:12:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110442.html</guid><description><![CDATA[<h2>案例分析发红包</h2>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190630192456711-435386713.png" alt="" /></p>
<div class="cnblogs_code">
<pre>用户类</pre>
<p>&nbsp;是一个父类，来构造方法</p>
<p>&nbsp;</p>
<pre><span style="color: #000000;">++++++++++++++++++++++++++++++<br />User.java

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> User{
    
    </span><span style="color: #0000ff;">private</span> String name;<span style="color: #008000;">//</span><span style="color: #008000;">姓名</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> money;<span style="color: #008000;">//</span><span style="color: #008000;">余额，也就是当前用户拥有的钱数</span>
    
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> User(){
        
    }
    
    </span><span style="color: #0000ff;">public</span> User(String name, <span style="color: #0000ff;">int</span><span style="color: #000000;"> money){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.money =<span style="color: #000000;"> money;
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">展示一下当前用户有多少前</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show(){
        System.out.println(</span>"我叫 ：" + name + ",我有多少钱：" +<span style="color: #000000;"> money);
    }
    
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName(){
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setName(){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getMoney(){
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> money;
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setMoney(){
        </span><span style="color: #0000ff;">this</span>.money =<span style="color: #000000;"> money;
    }
}<br /></span></pre>
</div>
<div class="cnblogs_code">
<pre>继承用户类<br />是一个子类<br />群主类发红包<br /><br />++++++++++++++++++++++<span style="color: #000000;">
Manager.java

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #008000;">//</span><span style="color: #008000;">群主类</span>

<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Manager <span style="color: #0000ff;">extends</span><span style="color: #000000;"> User{
    
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Manager(){
        
    }
    
    </span><span style="color: #0000ff;">public</span> Manager(String name ,<span style="color: #0000ff;">int</span><span style="color: #000000;"> money){
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.(name,money);
    }
    
    </span><span style="color: #0000ff;">public</span> ArrayList&lt;Integer&gt; send(<span style="color: #0000ff;">int</span> totaMoney,<span style="color: #0000ff;">int</span><span style="color: #000000;"> count){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">首先需要一个集合，用来存储若干个红包的金额</span>
        ArrayList&lt;Integer&gt; redList = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">首先看一下群主自己有多少钱</span>
        <span style="color: #0000ff;">int</span> leftMoney = <span style="color: #0000ff;">super</span>.getMoney();<span style="color: #008000;">//</span><span style="color: #008000;">群主当前金额</span>
        <span style="color: #0000ff;">if</span> (totaMoney &gt;<span style="color: #000000;"> leftMoney){
            System.out.println(</span>"余额不足"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> redList;<span style="color: #008000;">//</span><span style="color: #008000;">返回空集合</span>
<span style="color: #000000;">        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">扣钱，其实就是重新设置余额</span>
        <span style="color: #0000ff;">super</span>.setMoney(leftMoney -<span style="color: #000000;"> totaMoney)
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">发红包需要平均拆分成为count份</span>
        <span style="color: #0000ff;">int</span> avg = totaMoney/<span style="color: #000000;">count;
        </span><span style="color: #0000ff;">int</span> mod = totaMoney%count;<span style="color: #008000;">//</span><span style="color: #008000;">余数，也就是甩下的零头
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">除不开的零头，包在最后一个红包当中
        </span><span style="color: #008000;">//</span><span style="color: #008000;">下面把红包一个一个放到集合当中</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0; i&lt;count-1; i++<span style="color: #000000;">){
            redList.add(avg);
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">最后一个红包</span>
        <span style="color: #0000ff;">int</span> last = avg +<span style="color: #000000;"> mod;
        redList.add(last);
        
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> redList;
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre>继承用户类<br />是一个子类<br />普通成员用来收红包<br /><br />+++++++++++++++++++++<span style="color: #000000;">
Member.java 
</span><span style="color: #008000;">//</span><span style="color: #008000;">收红包的普通成员</span>

<span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.ArrayList;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Random;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Member <span style="color: #0000ff;">extends</span><span style="color: #000000;"> User{
    
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Member(){
    
    }
    
    </span><span style="color: #0000ff;">public</span> Member(String name , <span style="color: #0000ff;">int</span><span style="color: #000000;"> money){
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(name,money);
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> receive(ArrayList&lt;Integer&gt;<span style="color: #000000;"> list){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">从多个红包当中随便抽取一个，给我自己
        </span><span style="color: #008000;">//</span><span style="color: #008000;">随机获取一个集合当中的索引编号</span>
        <span style="color: #0000ff;">int</span> index = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random().nextInt(list.size());
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">根据索引，从集合当中删除，并且得到被删除的红包，给我自己</span>
        <span style="color: #0000ff;">int</span> delta =<span style="color: #000000;"> list.remove(index);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">当前成员自己本来有多少钱</span>
        <span style="color: #0000ff;">int</span> money = <span style="color: #0000ff;">super</span><span style="color: #000000;">.getMoney();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">加法，并且重新设置回去</span>
        <span style="color: #0000ff;">super</span>.setMoney(money +<span style="color: #000000;"> delta);
    }

}</span></pre>
</div>
<div class="cnblogs_code">
<pre>创建一个主方法<br />用来实例对象<br />调用方法实现发收红包的功能<br /><br />++++++++++++++++++++<span style="color: #000000;">
CaiNiao.java

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        Manager manager </span>= <span style="color: #0000ff;">new</span> Manager("群主"，100<span style="color: #000000;">);
        
        Member one </span>= <span style="color: #0000ff;">new</span> Member("菜鸟一号",0<span style="color: #000000;">)
        Member two </span>= <span style="color: #0000ff;">new</span> Member("菜鸟二号",0<span style="color: #000000;">)
        Member three </span>= <span style="color: #0000ff;">new</span> Member("菜鸟三号",0<span style="color: #000000;">)
        
        manager.show();</span><span style="color: #008000;">//</span><span style="color: #008000;">100</span>
        one.show();<span style="color: #008000;">//</span><span style="color: #008000;">0</span>
        two.show();<span style="color: #008000;">//</span><span style="color: #008000;">0</span>
        three.show();<span style="color: #008000;">//</span><span style="color: #008000;">0</span>
        System.one.println("=============="<span style="color: #000000;">);
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">群主总共发了20块，分成3个红包 </span>
        ArrayList&lt;Integer&gt; redList = manager.send(20,3<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">三个普通成员收红包</span>
<span style="color: #000000;">        one.receive(redList);
        two.receive(redList);
        three.receive(redList);
        
        manager.show();</span><span style="color: #008000;">//</span><span style="color: #008000;">100-20=80
        </span><span style="color: #008000;">//</span><span style="color: #008000;">6,6.8随机分给三个人</span>
<span style="color: #000000;">        one.show();
        two.show();
        three.show();
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：抽象方法和抽象类的使用</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110199.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 08:08:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110199.html</guid><description><![CDATA[<h2>抽象</h2>
<p><strong>抽象方法</strong>:就是加上abstract关键字，然后去掉大括，直接分号结束。<br /><strong>抽象类</strong>：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</p>
<h3>如何使用抽象类和抽象方法：</h3>
<p><strong>1.不能直接创建new抽象类对象。</strong></p>
<p><br /><strong>2.必须用一个子类来继承抽象父类。</strong></p>
<p><br /><strong>3.子类必须覆盖重写抽象父类当中所有的抽象方法。</strong><br /><strong>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括。</strong></p>
<p><br /><strong>4.创建子类对象进行使用。</strong></p>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：面向对象的三大特征：封装性、继承性、多态性之继承性</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110165.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 30 Jun 2019 08:02:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/30/11110165.html</guid><description><![CDATA[<p>面向对象的三大特征：封装性、继承性、多态性。</p>
<h2 style="text-align: center;">继承</h2>
<p>继承是多态的前提 ，如果没有继承，就没有多态。</p>
<p>继承主要解决的问题就是<strong>：共性抽取。</strong></p>
<h3>继承关系当中的特点：</h3>
<ol>
<li>子类可以拥有父类的&ldquo;内容&rdquo;</li>
<li>子类还可以拥有自己的专有的内容。</li>
</ol>
<p>&nbsp;</p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190630170537606-1327707912.png" alt="" width="958" height="414" /></p>
<p>&nbsp;</p>
<h3>继承的格式：</h3>
<p>在继承的关系中，&rdquo;子类就是一个父类&ldquo;。也就是说，子类可以被当做父类看待。<br />例父类是员工，子类是讲师，那么&ldquo;讲师就是一个员工&rdquo;。<strong>关系：is-a。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">定义父类的格式：（一个普通的类的定义）
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> 父类名称{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">...</span>
<span style="color: #000000;">}

定义子类的格式：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> 子类名称 <span style="color: #0000ff;">extends</span><span style="color: #000000;"> 父类名称{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">...</span>
}</pre>
</div>
<p>&nbsp;</p>
<h3>区分子类重名的三种方法：</h3>
<ul>
<li>局部变量： 直接写成员变量</li>
<li>本类的成员变量： this.成员变量</li>
<li>父类的成员变量： super.成员变量</li>
</ul>
<p><strong>注意事项：</strong><br />无论是成员变量还是成员方法，如果没有都是<strong>向上找父类，绝不会向下找子类的</strong>。</p>
<ul>
<li>重写（Override）：方法名称一样，参数列表【也一样】。覆盖、覆写。</li>
<li>重载（Overload)：方法名称一样：参数列表【不一样】。</li>





</ul>
<p><strong>方法覆盖重写的特点：</strong>创建的是子类对象，则优先用子类方法。</p>
<p><strong>方法覆盖重写的注意事项：</strong></p>
<p>1.必须保证父子类之间方法的名称相同，参数列表也相同。</p>
<ul>
<li>@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。</li>
<li>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</li>





</ul>
<p>2.子类方法的返回值必须【小于等于】父类方法的返回值范围。</p>
<ul>
<li>小扩展提示：java.Lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object子类。</li>





</ul>
<p>3.子类方法的权限必须【大于等于】父类方法的权限修饰符。</p>
<ul>
<li>小扩展提示：public &gt; protected &gt; (default) &gt; private</li>
<li>备注：（default）不是关键字default，而是什么都不写，留空。</li>





</ul>
<h3>super和this关键字的用法</h3>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190630170524973-779508050.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>扩展：</strong><br /><strong>子类必须调用父类的构造方法，不写则赠送super();写了则用写的指定的super调用，super只能有一个，还必须是第一个。</strong></p>
<p>super关键字用来访问父类的类容，而this关键字用来访问父类内容。用法也有三个：</p>
<ol>
<li>在本类的成员方法中，访问本来的成员变量。</li>
<li>在本类的成员方法中，访问本类的另一个成员方法。</li>
<li>在本类的构造方法中，访问本类的另一个构造方法。</li>





</ol>
<p>在第三种用法要注意：</p>
<ul>
<li>A:this(...)调用也必须是构造方法的第一个语句，唯一一个。</li>
<li>B:super和this两构造调用，不能同时使用。</li>





</ul>]]></description></item><item><title>Java.util.Math类--数学相关的工具类</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/29/11107896.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 29 Jun 2019 13:12:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/29/11107896.html</guid><description><![CDATA[<h2>Math类--数学相关的工具类</h2>
<p><strong>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">double</span> abs(<span style="color: #0000ff;">double</span><span style="color: #000000;"> num);获取绝对值。有多种重载；
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">double</span> ceil(<span style="color: #0000ff;">double</span><span style="color: #000000;"> num);向上取整。
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">double</span> floor(<span style="color: #0000ff;">double</span><span style="color: #000000;"> num);向下取整。
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">long</span> round(<span style="color: #0000ff;">double</span><span style="color: #000000;"> num);四舍五入。

Math.PI代表近似的圆周率常量。</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>题目：</strong><br /><strong>计算在-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个？</strong></p>
<p>备注：如果使用Math.ceil方法，-10.8可以变成-10.0。<br />注意double也是可以进行++的。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> mian(String[] args){
        </span><span style="color: #0000ff;">int</span> count = 0;<span style="color: #008000;">//</span><span style="color: #008000;">符合要求数量</span>
        
        <span style="color: #0000ff;">double</span> min = -10.8<span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> max = 5.9<span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">这样处理，变量i就是区间之内所有的整数</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = (<span style="color: #0000ff;">int</span>) min;i &lt; max; i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> abs = Math.abs(i);<span style="color: #008000;">//</span><span style="color: #008000;">绝对值</span>
            <span style="color: #0000ff;">if</span>(abs &gt; 6||abs &lt; 2.1<span style="color: #000000;">){
                System.out.println(i);
                count </span>++<span style="color: #000000;"> ;
            }
        }
    }
    System.out.println(</span>"总共有 ：" + count);<span style="color: #008000;">//</span><span style="color: #008000;">9</span>
}</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：数组工具类Arrays</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/29/11107411.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 29 Jun 2019 10:13:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/29/11107411.html</guid><description><![CDATA[<h2>数组工具类Arrays</h2>
<p><strong>java.util.Arrays是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组常见的操作。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> String toString(数组)；
将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3...]）

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> sort(数组)；
按照默认升序（从小到大）对数组的元素进行排序。</span></pre>
</div>
<p><strong>备注：</strong><br />1.如果是数组，sort默认按照升序从小到大<br />2.如果是字符串，sort默认按照字母升序<br />3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。</p>
<p><br /><strong>题目：</strong><br /><strong>请使用Arrays相关的API,将一个随机字符串中的所有字符升序排列，并倒序打印。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        String str </span>= "cainiaochuanqi123321"<span style="color: #000000;">;
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如何进行升序排序：sort
        </span><span style="color: #008000;">//</span><span style="color: #008000;">必须是一个数组，才能用Arrays.sort方法
        </span><span style="color: #008000;">//</span><span style="color: #008000;">String --&gt; 数组，用toCharArray</span>
        <span style="color: #0000ff;">char</span>[] chars =<span style="color: #000000;"> str.toCharArray();
        Arrays.sort(chars);</span><span style="color: #008000;">//</span><span style="color: #008000;">对数组进行升序排列
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">需要倒序遍历</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = cahrs.length - 1;i &gt;=0;i--<span style="color: #000000;">){
            System.out.println(chars[i]);
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：static 关键字概述</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/29/11106671.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 29 Jun 2019 07:08:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/29/11106671.html</guid><description><![CDATA[<h2><br />static 关键字概述</h2>
<p><strong>一旦用了static关键字，那么这样的内容不再属于对象自己。而是属于类的，所以凡是本类的对象，都共享同一份。</strong></p>
<p><strong>如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</strong></p>
<p>&nbsp;</p>
<p>无论是成员变量，还是成员方法。如果有了static，都推荐使用<strong>类名称进行调用。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">静态变量：类名称.静态变量
静态方法：类名称.静态方法（）
</span><span style="color: #0000ff;">int</span> num;<span style="color: #008000;">//</span><span style="color: #008000;">成员变量</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> numstatic；<span style="color: #008000;">//</span><span style="color: #008000;">静态变量</span>

<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> Cainiao(){}<span style="color: #008000;">//</span><span style="color: #008000;">成员方法</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> CaiNiaoStatic(){}<span style="color: #008000;">//</span><span style="color: #008000;">静态方法
</span><span style="color: #008000;">//</span><span style="color: #008000;">不能访问成员变量
</span><span style="color: #008000;">//</span><span style="color: #008000;">静态方法中不能访问this关键字</span></pre>
</div>
<p><strong>注意事项：</strong></p>
<p>1.静态方法不能直接访问非静态变量。</p>
<ul>
<li>原因：因为在内存当中是【先】有静态内容，【后】有的非静态内容。</li>
<li>&ldquo;先人知道后人，但是后人不知道先人&rdquo;</li>
</ul>
<p>2.静态方法当中不能使用this。</p>
<ul>
<li>原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。</li>
</ul>
<p><strong>注意：</strong><br /><strong>根据类名称访问静态成员变量的时候，全程和对象就没关系，只和类有关系。</strong></p>
<p>&nbsp;</p>
<h3>静态代码块的格式是：</h3>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名称{
    </span><span style="color: #0000ff;">static</span><span style="color: #000000;"> {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">静态代码块的内容</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<p><strong>特点：</strong>当第一次用到本类时，静态代码块执行唯一一次。<br />静态内容总是优先于非静态，所以静态代码比构造方法先执行。</p>
<p><strong>静态代码的典型用途：</strong><br />用来一次性地对静态成员变量进行赋值。<br /> </p>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：字符串概述与特点</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/28/11104473.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 28 Jun 2019 11:37:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/28/11104473.html</guid><description><![CDATA[<h2>字符串概述与特点</h2>
<div class="cnblogs_code">
<pre>java.lang.String类 代表字符串</pre>
</div>
<p>API当中说：Java程序中的所有字符串字面值（如&ldquo;abc&ldquo;）都作为此类的实例实现。<br />其实就是说：程序当中<strong>所用的双引号字符串，都是String类的对象。</strong>（就算没有new，也照样是。）</p>
<p>&nbsp;</p>
<h3>字符串的特点</h3>
<ol>
<li>字符串的内容永远不可改变。【重点】</li>
<li>正是因为字符串不可改变，所以字符串是可以共享使用的。</li>
<li>字符串效果上相当于是char[]字符数组，但是底层原理byte[]字节数组</li>


</ol>
<h3><strong>创建字符串的常见3+1种方式</strong></h3>
<p><strong>三种构造方法</strong>：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span><span style="color: #000000;"> String():<br />创建一个空白字符串，不含有任何内容。
　　String str </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> String();

</span><span style="color: #0000ff;">public</span> String(<span style="color: #0000ff;">char</span><span style="color: #000000;">[] array):<br />根据字符数组的内容，来对应的字符串。
　　</span><span style="color: #0000ff;">char</span>[] charArray = {'A','B','C'<span style="color: #000000;">};
　　String str </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> String(charArray);

</span><span style="color: #0000ff;">public</span> String(<span style="color: #0000ff;">byte</span><span style="color: #000000;">[] array):<br />根据字节数组的内容，来对应的字符串。
　　</span><span style="color: #0000ff;">byte</span>[] byteArray = {33,55,77<span style="color: #000000;">};
　　String str </span>= <span style="color: #0000ff;">new</span> String(byteArray)</pre>
</div>
<p><strong>一种直接创建：</strong></p>
<div class="cnblogs_code">
<pre>String str = "CaiNiap";<span style="color: #008000;">//</span><span style="color: #008000;">右边直接用双引号</span></pre>
</div>
<p><strong>注意：直接写上双引号，就是字符串对象。</strong></p>
<p>&nbsp;</p>
<h3>字符串常量池</h3>
<p><strong>程序当中直接写上的双引号字符串，就在字符串常量池中。</strong></p>
<p>对于基本类型来说，<strong>==</strong> 是进行数值的比较<br />对于引用类型来说，<strong>==</strong> 是进行【地址值】的比较。<br />	<strong>注意：双引号直接写的字符串在常量当中，new的不在池当中</strong></p>
<p>&nbsp;</p>
<h3>字符串的比较</h3>
<p><strong>==</strong> 是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两方法。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> equals(Object obj):<br />参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true，否则返回false</pre>
</div>
<p><strong>备注：任何对象都能用Object进行接收</strong>。</p>
<p><br />如果比较双方一个常量一个变量，推荐把常量字符串写在前面。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">推荐：&rdquo;abc&ldquo;.equals(str) 
不推荐：str.equals(</span>"abc")</pre>
</div>
<p>&nbsp;</p>
<h3>String当中与获取相关的常用方法有</h3>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> length();
获取字符串当中含有的字符个数，拿到字符串长度。

</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String concat(String str):
将当前字符串和参数字符串拼接成为返回值新的字符串。

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">char</span> charAt(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index):
获取指定索引位置的单个字符。（索引从0开始）

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> indexOf(String str);
查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回</span>-1值。</pre>
</div>
<h3>&nbsp;</h3>
<h3>字符串的截取方法：</h3>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> String substring(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index);
截取从参数位置一直到字符串末尾，返回新字符串。、

</span><span style="color: #0000ff;">public</span> String substring(<span style="color: #0000ff;">int</span> begin,<span style="color: #0000ff;">int</span><span style="color: #000000;"> end)
截取从begin开始，一直到end结束，中间的字符串
备注：[begin ,end)，包含左边，不包含右边。

String 当中与转换相关的常用方法有：

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">char</span><span style="color: #000000;">[] toCharArray();
将当前字符串拆分成为字符串数组作为返回值。

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">byte</span><span style="color: #000000;">[] getBytes();
获取当前字符串底层的字节数组

</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String replace(CharSequence oldString,CharSequence newString);
将所有出现的老字符串替换为新的字符串，返回替换后的结果新字符串。</span></pre>
</div>
<p>&nbsp;</p>
<h3>字符串的分割</h3>
<p><strong>分割字符串的方法；</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span><span style="color: #000000;"> String[] split(String regex):
按照参数的规则，将字符串切分成为若干部分。</span></pre>
</div>
<p><strong>注意事项：</strong></p>
<ul>
<li>split方法的参数其实是一个&ldquo;正则表达式&rdquo;</li>
<li>注意：如果按照英文句点，"."进行切分，必须写"\\."(两个反斜杠)</li>
</ul>
<h3>&nbsp;</h3>
<h3>例子</h3>
<p><strong>定义一个方法：把数组{1，2，3}按照指定的格式拼接成一个字符串。格式参照如下：[word1#word2#word3#].</strong></p>
<p><strong>分析：</strong><br />1.首先准备一个int[]数组，内容是：1，2，3<br />2.定义一个方法，用来将数组变成字符串<br />三要素：<br />返回值类型：String<br />方法名称：fromArrayToString<br />参数列表：int[]<br />3.格式：[word1#word2#word3#]<br />用到：for循环、字符串拼接、每个数组元素之前都有一个word字样、分隔使用的是#、分区下一个是不是最后一个<br />4.调用方法，得到返回值，并打印结果字符串</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #0000ff;">int</span>[] array = {1,2,3<span style="color: #000000;">};
        String result </span>=<span style="color: #000000;"> fromArrayToString(array);
        System.out.println(result);
        
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> String fromArrayToString(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] array){
    String str </span>= "["<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;array.length;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span> (i==array.length-1<span style="color: #000000;">){
            str </span>+="word" + array[i] +"]"<span style="color: #000000;">;
        }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            str </span>+= "world" + array[i] + "#"<span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<h3>例子：</h3>
<p><strong>题目：</strong><br /><strong>键盘输入一个字符串，并且统计其中各种字符出现的次数。</strong><br /><strong>种类有：大写字母、小写字母、数字、其他</strong></p>
<p><strong>思路：</strong><br />1.既然用到键盘输入，肯定是Scanner<br />2.键盘输入的是字符串，那么：String str =sc.next();<br />3.定义四个变量。分别代表四种字符各自出现的次数 。<br />4.需要对字符串一个字、一个字的检查，String --&gt;char[],方法就是toCharArray()<br />5.遍历char[]字符数组，对当前字符种类进行判断，并且用四个变量进行++动作。<br />6.打印输出四个变量，分别代表四种字符出现的次数。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Scanner;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        Scanner sc </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
        System.out.println(</span>"请输入一个字符串： "<span style="color: #000000;">);
        String input </span>=<span style="color: #000000;"> sc.next();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取键盘输入的一个字符串</span>
        
        <span style="color: #0000ff;">int</span> countUpper = 0；<span style="color: #008000;">//</span><span style="color: #008000;">大写字母</span>
        <span style="color: #0000ff;">int</span> countLower = 0；<span style="color: #008000;">//</span><span style="color: #008000;">小写字母</span>
        <span style="color: #0000ff;">int</span> countNumber = 0；<span style="color: #008000;">//</span><span style="color: #008000;">数字</span>
        <span style="color: #0000ff;">int</span> countOther= 0；<span style="color: #008000;">//</span><span style="color: #008000;">其他字符</span>
        
        <span style="color: #0000ff;">char</span>[] charArray =<span style="color: #000000;"> input.toCharArray();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0;i&lt;charArray.length;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">char</span> ch = charArray[i];<span style="color: #008000;">//</span><span style="color: #008000;">当前单个字符</span>
            <span style="color: #0000ff;">if</span>('A' &lt;= ch&amp;&amp;ch &lt;='Z'<span style="color: #000000;">){
                countUpper</span>++<span style="color: #000000;">;
            }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ('a' &lt;= ch &amp;&amp; ch &lt;='z'<span style="color: #000000;">}{
                countLower</span>++<span style="color: #000000;">;
            }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ('0' &lt;= ch &amp;&amp; ch &lt;= '9'<span style="color: #000000;">){
                countNumber</span>++<span style="color: #000000;">;
            }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
                countOther</span>++<span style="color: #000000;">;
            }
        }<br />
        System.out.println(</span>"大写字母有：" +<span style="color: #000000;"> countUpper);
        System.out.println(</span>"小写字母有：" +<span style="color: #000000;"> countLower);
        System.out.println(</span>"数字有：" +<span style="color: #000000;"> countNumber);
        System.out.println(</span>"其他字符有：" +<span style="color: #000000;"> countOther);
    }<br />}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：集合的使用与数组的区别</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/27/11097439.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 27 Jun 2019 07:43:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/27/11097439.html</guid><description><![CDATA[<h2 style="text-align: center;">ArrayList 集合</h2>
<p><strong>ArrayList 集合</strong></p>
<div class="cnblogs_code">
<pre>ArrayList&lt;String&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;();</pre>
</div>
<ol>
<li>对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。</li>
<li><strong>泛型：</strong>也就是也就是装在集合当中的所有元素，全部都是统一的什么类型</li>
<li><strong>注意：</strong>泛型只能是引用类型，不能是基本类型</li>
</ol>
<p><strong>数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变</strong></p>
<p><strong>ArrayList 集合和数组的区别：</strong></p>
<ul>
<li>数组的长度不可以改变。</li>
<li>但是ArrayList的长度可以改变。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。</li>
<li>如果内容是空，得到的是空的中括：[]</li>
</ul>
<p><br /><strong>ArrayList当中常用的方法：</strong><br />public boolean add(E e)：</p>
<ul>
<li>向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。</li>
<li>备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。</li>
<li>但是对于其他集合来，add添加的动作不一定成功。</li>
</ul>
<p>public E get(int index);</p>
<ul>
<li>从集合当中获取元素，参加是索引编号，返回值就是对应位置的元素。</li>
<li>索引值从零开始 E是泛型</li>
</ul>
<p>public E remove(int index );</p>
<ul>
<li>从集合当中删除元素，参数就是索引编号，返回值就是被删除的元素。</li>
</ul>
<p>public int size();</p>
<ul>
<li>获得集合尺寸的长度，返回值是集合中包含的元素个数。</li>
</ul>
<div class="cnblogs_code">
<pre>ArrayList&lt;<span style="color: #0000ff;">int</span>&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
</span><span style="color: #008000;">//</span><span style="color: #008000;">错误写法 泛型只能是引用类型，不能是基本类型</span></pre>
</div>
<p>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的&ldquo;包装类&rdquo;。</p>
<div class="cnblogs_code">
<pre>基本类型---<span style="color: #000000;">包装类（引用类型，包装类都位于java.lang包下）
</span><span style="color: #0000ff;">byte</span>---<span style="color: #000000;">Byte
</span><span style="color: #0000ff;">short</span>---<span style="color: #000000;">Short
</span><span style="color: #0000ff;">int</span>---<span style="color: #000000;">Integer 【特殊】
</span><span style="color: #0000ff;">long</span>---<span style="color: #000000;">Long
</span><span style="color: #0000ff;">float</span>---<span style="color: #000000;">Float
</span><span style="color: #0000ff;">double</span>---<span style="color: #000000;">Double
</span><span style="color: #0000ff;">char</span>---<span style="color: #000000;">Character 【特殊】
</span><span style="color: #0000ff;">boolean</span>---Boolean</pre>
</div>
<p><br /> 从JDK 1.5+开始，支持自动装箱、自动拆箱。</p>
<div class="cnblogs_code">
<pre>自动装箱:基本类型---&gt;<span style="color: #000000;">包装类型
自动拆箱：包装类型</span>---&gt;基本类型</pre>
</div>
<h3><br />题目：</h3>
<p><strong>生成6个1~33之间的随机整数，添加到集合并遍历集合。</strong></p>
<p><strong>思路：</strong><br />1.需要存储6个数字，创建一个集合，&lt;Integer&gt;<br />2.产生随机数，需要用到Random<br />3.用循环6次，来产生6个随机数：for循环<br />4.循环内调用r.nextInt(int n),参数是33， 0~32，整体+1才是1~33<br />5.把数字添加到集合中：add<br />6.遍历集合：for,size,get<br /><br /></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Random
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Scanner

</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> calss CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> mian(String[] args){
        
        ArrayList</span>&lt;Integer&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        Random r </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;6;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> num = r.nextInt(33)+1<span style="color: #000000;">;
            list.add(num);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历集合</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;list.size();i++<span style="color: #000000;">){
            System.out.println(list.get(i));
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>题目：</strong></p>
<p><strong>用一个大的集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中。</strong><br /><strong>要求使用自定义的方法来实现筛选。</strong></p>
<p><strong>分析：</strong><br />1.需要创建一个大集合，用来存储int数字，&lt;Integer&gt;<br />2.随机数就是用Random nextInt<br />3.循环20次，把随机数字放入大集合：for循环，add方法<br />4.定义一个方法，用来筛选符合要求的元素，得到小集合<br />三要素：</p>
<ul>
<li>返回值类型：ArrayList小集合（里面元素个数不确定）</li>
<li>方法名称：getSmallist</li>
<li>参数列表：ArrayList大集合（装着20个随机数字）</li>
</ul>
<p>5，判断（if）是偶数：num%2 = = 0<br />6.如果是偶数。就放到小集合当中，否则不放</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Random

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        ArrayList</span>&lt;Integer&gt; biglist = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        Random r </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;20;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> num = r.nextInt(100)+1;<span style="color: #008000;">//</span><span style="color: #008000;">1~100</span>
<span style="color: #000000;">            biglist.add(num);
        }
        ArrayList</span>&lt;Integer&gt; smallList =<span style="color: #000000;"> getSmallist(biglist);
        
        System.out.println(</span>"偶数总共有多少个：" +<span style="color: #000000;"> smallList.size());
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;smallList.size();i++<span style="color: #000000;">){
            System.out.println(smallList.get(i));
        }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">这个方法，接受大集合参数，返回小集合结果</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> ArrayList&lt;Integer&gt; getSmallist(ArrayList&lt;Integer&gt;<span style="color: #000000;"> biglist)
        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个小集合，用来装偶数结果</span>
        ArrayList&lt;Integer&gt; smallList = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0;i&lt;biglist.size();i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> num =<span style="color: #000000;"> biglist.get(i);
            </span><span style="color: #0000ff;">if</span>(num %2==0<span style="color: #000000;">){
                smallList.add(num);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> smallList;
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>常用Java API之Ramdom--用代码模拟猜数小游戏</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/27/11097354.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 27 Jun 2019 07:34:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/27/11097354.html</guid><description><![CDATA[<h2 style="text-align: center;">常用Java API之Ramdom</h2>
<p><strong>Ramdom类用来生成随机数字</strong>。使用起来也是三个步骤；</p>
<p>1.导包</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span> java.util.Random;</pre>
</div>
<p>2.创建 </p>
<div class="cnblogs_code">
<pre>Random r = <span style="color: #0000ff;">new</span> Random();<span style="color: #008000;">//</span><span style="color: #008000;">小括当中留空即可</span></pre>
</div>
<p>3.使用 </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">获取一个随机的int数组（范围是int所有范围，有正负两）；
</span><span style="color: #0000ff;">int</span> num =<span style="color: #000000;"> r.nextInt();

获取一个随机的int数字（参数代表了范围，左闭右开区间）；
</span><span style="color: #0000ff;">int</span> num = r.nextInt(3<span style="color: #000000;">);
实际上代表的含义是：[</span>0,3）,也就是0&mdash;2</pre>
</div>
<h3>用代码模拟猜数小游戏</h3>
<p><strong>思路：</strong><br />1.首先需要产生一个随机数字，并且一旦产生就不再变化。用Random和nextInt方法（用来产生随机数字）<br />2.需要键盘输入，所以用到了Scanner<br />3.获取键盘输入的数字，用Scanner当中的nextInt方法（输入）<br />4.已经得到了两数字，判断（if）一下：</p>
<ul>
<li>	如果太小，提示太大，并且重试</li>
<li>	如果太小，提示太小，并且重试</li>
<li>	如果猜中，游戏结束</li>
</ul>
<p>5.重试就是再来，循环次数不确定，用while(true).</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Random
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Scanner

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main (String[] args){
        Random r </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();
        </span><span style="color: #0000ff;">int</span> randomNum = r.nextInt(100)+1;<span style="color: #008000;">//</span><span style="color: #008000;">[1,100]</span>
        Scanner sc = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
        
        </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
            System.out.println(</span>"请输入你猜得数字："<span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> gussNum = sc.nextInt();<span style="color: #008000;">//</span><span style="color: #008000;">键盘输入猜测的数字</span>
            
            <span style="color: #0000ff;">if</span> (guessNum &gt;<span style="color: #000000;"> randomNum){
                System.out.println(</span>"太大了，请重试。"<span style="color: #000000;">);
            
            }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (gussNum &lt;<span style="color: #000000;"> randomNum){
                System.out.println(</span>"太小了，请重试。"<span style="color: #000000;">);
                
            }</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                System.out.println(</span>"恭喜你，猜中啦"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">break</span>;<span style="color: #008000;">//</span><span style="color: #008000;">如果猜中，不再重试</span>
<span style="color: #000000;">            }
        }
        System.out.println(</span>"游戏结束！"<span style="color: #000000;">);
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java中的匿名对象</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/27/11097312.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 27 Jun 2019 07:29:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/27/11097312.html</guid><description><![CDATA[<h2 style="text-align: center;">匿名对象</h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">创建对象的标准格式：
类名称 对象名 </span>= <span style="color: #0000ff;">new</span> 类名称();</pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。
</span><span style="color: #0000ff;">new</span> 类名称();</pre>
</div>
<p>&nbsp;</p>
<p><strong>匿名对象</strong></p>
<ul>
<li><strong>注意事项</strong>：匿名对象只能使用唯一的一次，下次再使用不得不创建一个新的对象</li>
<li><strong>使用建议</strong>：如果确定一个对象只需要使用一次，就可以使用匿名对象</li>
</ul>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>methodParam(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in));

</span><span style="color: #008000;">//</span><span style="color: #008000;">使用匿名对象来进行传参

</span><span style="color: #008000;">//</span><span style="color: #008000;">使用匿名函数作为返回值</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>常用Java API之Scanner：功能与使用方法</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/26/11090273.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 26 Jun 2019 07:44:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/26/11090273.html</guid><description><![CDATA[<h2 style="text-align: center;">Scanner</h2>
<p>常用Java API之Scanner：功能与使用方法</p>
<p><strong>Scanner类的功能：可以实现键盘输入数据到程序当中</strong>。</p>
<p>引用类型的一般使用步骤：（Scanner是引用类型的）</p>
<p><strong>1.导包</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> 包路径.类名称;
如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。
只有java.lang包下的内容不需要导包，其他的包都需要import语句。</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>2.创建</strong></p>
<div class="cnblogs_code">
<pre>类名称 对象名 = <span style="color: #0000ff;">new</span> 类名称();</pre>
</div>
<p>&nbsp;</p>
<p><strong>3.使用</strong></p>
<div class="cnblogs_code">
<pre>对象名.成员方法名()</pre>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><strong><span style="color: #000000;">获取键盘输入的一个int数字：

</span></strong><span style="color: #0000ff;">int</span> num = sc.nextInt();</pre>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><strong><span style="color: #000000;">获取键盘输入的一个字符串：

</span></strong><span style="color: #0000ff;">int</span> str = sc.next();</pre>
</div>
<p>&nbsp;</p>
<h3>练习：</h3>
<p><strong>键盘输入三个数字，然后求出其中的最大值。</strong></p>
<p><strong>思路：</strong><br />1.既然是键盘输入，肯定需要用到Scanner<br />2.Scanner三个步骤，导包、创建、使用nextInt()方法<br />3.既然是三个数字，那么调用三次nextInt()方法，得到三个int变量<br />4.无法同时判断三个数字谁最大，应该转换成两步骤：<br />	4.1首先判断前两当中谁最大，拿到前两的最大值<br />	4.2拿着前俩个中的最大值，再和第三个数字比较，得到三个数字当中的最大值<br />5.打印最终结果。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> java.util.Scanner;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;">(String[] args){
        Scanner sc </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scanner(System.in);
        
        System.out.println(</span>"请输入第一个数字: "<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> a =<span style="color: #000000;"> sc.nextInt();
        System.out.println(</span>"请输入第二个数字: "<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> b =<span style="color: #000000;"> sc.nextInt();
        System.out.println(</span>"请输入第三个数字: "<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> c =<span style="color: #000000;"> sc.nextInt();
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">首先得到前两数字当中的最大值</span>
        <span style="color: #0000ff;">int</span> temp = a &gt; b ?<span style="color: #000000;"> a : b;
        </span><span style="color: #0000ff;">int</span> max = temp &gt; c ?<span style="color: #000000;"> temp : c;
        System.out.println(</span>"最大值是：" +<span style="color: #000000;"> max );
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>一个标准的类通常要拥有下面四个组成部分</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/23/11073989.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 23 Jun 2019 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/23/11073989.html</guid><description><![CDATA[<h3>一个标准的类通常要拥有下面四个组成部分：</h3>
<ol>
<li>所有的成员变量都要使用private关键字修饰</li>
<li>为每一个成员变量编写一对Getter/setter方法</li>
<li>编写一个无参数的构造方法</li>
<li>编写一个全参数的构造方法</li>
</ol>
<p><strong>这样的标准类也叫做Java Bean</strong></p>
<div class="cnblogs_code">
<pre><span>标准类：
public class<span> Student{
    
    private String name;//姓名
    private int age;//年龄
    
    public<span> Student(){
        //无参构造方法
<span>    }
    public Student(String name ,int<span> age ){
        this.name =<span> name;
        this.age =<span> age;
    }//有参构造方法
    
    public<span> String getName(){
        return<span> name;
    }
    public void<span> setName(String name){
        this.name =<span> name;
    }//姓名
    
    public int<span> getAge(){
        return<span> age;
    }
    public void setAge(int<span> age){
        this.age =<span> age;
    }//年龄
<span>}
    
//==================//
public class<span> CaiNiao{
    
    public static void<span> main(String[] args){
        Student stu1 = new<span> Student();
        stu1.setName("菜鸟"<span>)；
        stu1.setAge(18<span>);
        System.out.println("姓名：" + stu1.getName()+",年龄："+<span>stu1.getAge());
        //第二种方法
        student stu2 = new Student("传奇",28<span>);
        System.out.println("姓名：" + stu2.getName()+",年龄："+<span>stu2.getAge());
        stu2.setAge(22);//修改后
        System.out.println("姓名：" + stu2.getName()+",年龄："+<span>stu2.getAge());
        
    }
}
    </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>局部变量和成员变量的区别</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/23/11073993.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 23 Jun 2019 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/23/11073993.html</guid><description><![CDATA[<h3>局部变量和成员变量的区别：</h3>
<p><strong>1.定义的位置不一样【重点】</strong></p>
<ul>
<li>局部变量：在方法的内部</li>
<li>成员变量：在方法的外部，直接写在类当中</li>
</ul>
<p><strong>2.作用范围不一样【重点】</strong></p>
<ul>
<li>局部变量：只有方法当中才可以使用，出了方法就不能再用了</li>
<li>成员变量：整个类都可以通用</li>
</ul>
<p><strong>3.默认值不一样【重点】</strong></p>
<ul>
<li>局部变量：没有默认值，如果要想使用，必须手动进行赋值</li>
<li>成员变量：如果没有赋值，会有默认值，规则和数组一样</li>
</ul>
<p>4.内存的位置不一样（了解）</p>
<ul>
<li>局部变量：位于栈内存</li>
<li>成员变量：位于堆内存</li>
</ul>
<p>5.生命周期不一样（了解）</p>
<ul>
<li>局部变量：随着方法进栈而诞生，随着方法出栈而消失</li>
<li>成员变量：随着对象的创建而诞生，随着对象被垃而消失</li>
</ul>]]></description></item><item><title>Java学习： 面向对象的使用与注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/23/11073986.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 23 Jun 2019 11:49:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/23/11073986.html</guid><description><![CDATA[<h2 style="text-align: center;">&nbsp;面向对象的使用与注意事项</h2>
<p><strong>面向过程：</strong>当需要实现一个功能的时候，每一个具体的步骤都需要亲力，详细处理每一个细节<br /><strong>面向对象：</strong>当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事。</p>
<h3>类与对象的关系</h3>
<ol>
<li>类是对一类事物的描述，是抽象的。</li>
<li>对象是一类事物的实例，是具体的。</li>
<li>类是对象的模板，对象是类的实例。</li>
</ol>
<p><strong>定义一个类，</strong>用来模拟&ldquo;学生&rdquo;事物。其中就有两组成部分：</p>
<p>属性（是什么）：</p>
<ul>
<li>	姓名</li>
<li>	年龄</li>
</ul>
<p>行为（能做什么）：</p>
<ul>
<li>吃饭</li>
<li>睡觉</li>
<li>	学习</li>
</ul>
<p><strong>对应到Java的类当中</strong>：<br />成员变量（属性）：</p>
<div class="cnblogs_code">
<pre>String name；<span style="color: #008000;">//</span><span style="color: #008000;">姓名</span>
<span style="color: #0000ff;">int</span> age；<span style="color: #008000;">//</span><span style="color: #008000;">年龄</span></pre>
</div>
<p>成员方法（行为）；</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> eat（）{}<span style="color: #008000;">//</span><span style="color: #008000;">吃饭</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> sleep（）{}<span style="color: #008000;">//</span><span style="color: #008000;">睡觉</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> study（）{}<span style="color: #008000;">//</span><span style="color: #008000;">学习</span></pre>
</div>
<p><strong>注意事项：</strong></p>
<ol>
<li>成员变量是直接定义到类当中的，在方法外边。</li>
<li>成员方法不要写static关键字</li>
</ol>
<h3>对象的创建与使用</h3>
<p>通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。</p>
<p><strong>1.导包：</strong>也就是指出需要使用的类，在什么位置。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span> 包名称.类名称；</pre>
</div>
<p>对于和当前类属于<strong>同一个包</strong>的情况下，可以省略导包语句<strong>不写。</strong></p>
<p><strong>2.创建，格式：</strong></p>
<div class="cnblogs_code">
<pre>类名称 对象名 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> 类名称();
Student stu </span>= <span style="color: #0000ff;">new</span> Student();</pre>
</div>
<p><strong>3.使用，</strong>分为两情况：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">使用成员变量：对象名.成员变量
使用成员方法：对象名.成员方法名（参数）
(也就是，想用谁，就用对象名点儿谁。）</span></pre>
</div>
<p><strong>注意事项：</strong></p>
<ul>
<li>如果成员没有进行赋值，那么将会有一个默认值，规则和数组一样。</li>
<li>当一个对象作为参数，传递到方法当中时：实际上传递进去的是对象的地址值。</li>
<li>当使用一个对象类型作为方法的返回值时：返回值其实就是对象的地址值。</li>
</ul>
<h3><br />局部变量和成员变量的区别：</h3>
<p><strong>1.定义的位置不一样【重点】</strong></p>
<ul>
<li>局部变量：在方法的内部</li>
<li>成员变量：在方法的外部，直接写在类当中</li>
</ul>
<p><strong>2.作用范围不一样【重点】</strong></p>
<ul>
<li>局部变量：只有方法当中才可以使用，出了方法就不能再用了</li>
<li>成员变量：整个类都可以通用</li>
</ul>
<p><strong>3.默认值不一样【重点】</strong></p>
<ul>
<li>局部变量：没有默认值，如果要想使用，必须手动进行赋值</li>
<li>成员变量：如果没有赋值，会有默认值，规则和数组一样</li>
</ul>
<p>4.内存的位置不一样（了解）</p>
<ul>
<li>局部变量：位于栈内存</li>
<li>成员变量：位于堆内存</li>
</ul>
<p>5.生命周期不一样（了解）</p>
<ul>
<li>局部变量：随着方法进栈而诞生，随着方法出栈而消失</li>
<li>成员变量：随着对象的创建而诞生，随着对象被垃而消失</li>
</ul>
<h3>面向对象三大特征：封装、继承、多态。</h3>
<p><strong>封装</strong>性在Java当中的体现：</p>
<ol>
<li>方法就是一种封装</li>
<li>关键字private也是一种封装</li>
</ol>
<p><strong>封装就是将一些细节信息隐藏起来，对于外界不可见。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。
解决方案：用private关键字将需要保护的成员变量进行修饰</span></pre>
</div>
<p>一旦用了private进行修饰，那么本类当中任然可以随意访问。<br /><strong>但是：</strong>超出了本类范围之外就不能再直接访问了。</p>
<p>间接访问private成员变量，就是定义一对儿Getter/Setter方法</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>必须叫setXxx或者getXxx命名规则。</li>
<li>对于Getter来说，不能有参数，返回值类型和成员变量对应；</li>
<li>对于Setter来说，不能有返回值，参数类型和成员变量对应。</li>
</ul>
<h3><br />this关键字的定义：</h3>
<p>当方法的局部变量和类的成员变量重名的时候，<strong>根据&ldquo;就近原则&rdquo;，优先使用局部变量。</strong><br />如果需要访问本类当中的成员变量，需要使用格式：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">this</span><span style="color: #000000;">.成员变量
&ldquo;通过谁调用的方法，谁就是this。</span></pre>
</div>
<h3>构造方法：</h3>
<p><strong>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是再调用构造函数。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式：
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> 类名称（参数类型 参数名称）{
方法体
}</span></pre>
</div>
<p><strong>注意事项：</strong></p>
<ol>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不需要写</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数，方法体什么事情都不做</li>
</ol>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> Student（）{}</pre>
</div>
<p>　　5.一旦编写了至少一个构造方法，那么编译器将不再赠送。</p>
<p>　　6.构造方法也是可以进行重载的。</p>
<div class="cnblogs_code">
<pre>重载：方法名称相同，参数列表不同。</pre>
</div>
<h3> <br />一个标准的类通常要拥有下面四个组成部分：</h3>
<ol>
<li>所有的成员变量都要使用private关键字修饰</li>
<li>为每一个成员变量编写一对Getter/setter方法</li>
<li>编写一个无参数的构造方法	</li>
<li>编写一个全参数的构造方法	</li>
</ol>
<p><strong>这样的标准类也叫做Java Bean</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">标准类：
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Student{
    
    </span><span style="color: #0000ff;">private</span> String name;<span style="color: #008000;">//</span><span style="color: #008000;">姓名</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> age;<span style="color: #008000;">//</span><span style="color: #008000;">年龄</span>
    
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> Student(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">无参构造方法</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">public</span> Student(String name ,<span style="color: #0000ff;">int</span><span style="color: #000000;"> age ){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }</span><span style="color: #008000;">//</span><span style="color: #008000;">有参构造方法</span>
    
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName(){
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setName(String name){
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
    }</span><span style="color: #008000;">//</span><span style="color: #008000;">姓名</span>
    
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getAge(){
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> age;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setAge(<span style="color: #0000ff;">int</span><span style="color: #000000;"> age){
        </span><span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
    }</span><span style="color: #008000;">//</span><span style="color: #008000;">年龄</span>
<span style="color: #000000;">}
    
</span><span style="color: #008000;">//</span><span style="color: #008000;">==================</span><span style="color: #008000;">//
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        Student stu1 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Student();
        stu1.setName(</span>"菜鸟"<span style="color: #000000;">)；
        stu1.setAge(</span>18<span style="color: #000000;">);
        System.out.println(</span>"姓名：" + stu1.getName()+",年龄："+<span style="color: #000000;">stu1.getAge());
        </span><span style="color: #008000;">//</span><span style="color: #008000;">第二种方法</span>
        student stu2 = <span style="color: #0000ff;">new</span> Student("传奇",28<span style="color: #000000;">);
        System.out.println(</span>"姓名：" + stu2.getName()+",年龄："+<span style="color: #000000;">stu2.getAge());
        stu2.setAge(</span>22);<span style="color: #008000;">//</span><span style="color: #008000;">修改后</span>
        System.out.println("姓名：" + stu2.getName()+",年龄："+<span style="color: #000000;">stu2.getAge());
        
    }
}
    </span></pre>
</div>
<p>&nbsp;</p>
<p><br />	<br />	<br />	<br />	<br />	<br />	<br />	</p>
<p>&nbsp;</p>]]></description></item><item><title>Java的内存需要划分成为5个部分：</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/21/11066356.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 21 Jun 2019 11:08:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/21/11066356.html</guid><description><![CDATA[<h3>Java的内存需要划分成为5个部分：</h3>
<p><strong>1.栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。</strong></p>
<ul>
<li>局部变量：方法的参数，或者是方法{}内部的变量</li>
<li>作用域：一旦超出作用域，立从栈内存当中消失。</li>
</ul>
<p><strong>2.堆（Heap）：凡是new出来的东西，都在堆当中。</strong><br />堆内存里面的东西都有一个地址值：16进制<br />堆内存里面的数据，都有默认值。规则：</p>
<ul>
<li>如果是整数类型：那么默认值为0</li>
<li>如果是浮点类型：那么默认值为0.0</li>
<li>如果是字符类型：那么默认值为\u0000</li>
<li>如果是布尔类型：那么默认值为false</li>
<li>如果是引用类型：那么默认值为null</li>

</ul>
<p><br /><strong>3.方法区（Method Area）：存储.class相关信息，包含方法的信息。</strong></p>
<p>4.本地方法栈（Native Method Stack）：与操作系统相关。<br />5.寄存器（pc Register）：与cpu相关。</p>]]></description></item><item><title>Java学习：数组的使用和注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/21/11066350.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 21 Jun 2019 11:07:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/21/11066350.html</guid><description><![CDATA[<h2 style="text-align: center;">数组</h2>
<p><strong>数组的概念</strong>：是一种容器，可以同时存放多个数据值</p>
<h3><strong>数组的特点：</strong></h3>
<ol>
<li>数组是一种引用数据类型</li>
<li>数组当中的多个数据，类型必须统一</li>
<li>数组的长度在程序运行期间不可以改变</li>
</ol>
<p><strong>数组的初始化</strong>：在内存当中创建一个数组，并且向其中赋予一些默认值。</p>
<p>&nbsp;</p>
<h3>两种常见的初始化方式：</h3>
<p>1.动态初始化（指定长度）<br />2.静态初始化（指定类容）</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">动态初始化数组的格式：
数据类型[] 数组名称 </span>= <span style="color: #0000ff;">new</span> 数组类型[数组长度]；</pre>
</div>
<p><strong>解析含义：</strong></p>
<ul>
<li>左侧数据类型：也就是数组当中保存的数据，全都是统一的什么类型</li>
<li>左侧的括号：代表是一个数组</li>
<li>左侧数组名称：给数组取一个名字</li>
<li>右侧的new：代表创建数组的动作</li>
<li>右侧的数据类型：必须和左边的数据类型保持一致</li>
<li>右侧中括的长度：也就是数组当中，到底可以保存多少个数据，是一个int数字</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">动态初始化（指定长度）</span>
<span style="color: #0000ff;">int</span>[] array1 = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[3377];</pre>
</div>
<p>&nbsp;</p>
<h3>数组定义的格式-静态初始化</h3>
<p>动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数<br />静态初始化（指定类容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据类容进行指定。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">静态初始化基本格式：
数据类型[] 数组名称 </span>= <span style="color: #0000ff;">new</span> 数据类型[]{元素1，元素2，...}</pre>
</div>
<p><strong>注意事项：</strong><br />虽然静态初始化没有直接告诉长度，但是根据大括里面的元素具体内容，也可以自动推算出来长度。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">静态初始化</span>
String[] array2 = <span style="color: #0000ff;">new</span> String[]{"cai","niao","chuan","qi"};</pre>
</div>
<p>使用静态初始化数组的时候，格式还可以省略一下。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">省略格式</span>
数据类型[] 数组名称 = {元素1，元素2,...};</pre>
</div>
<p><strong>注意事项：</strong><br />1.静态初始化没有直接指定长度，但是仍然会自动推算得到长度。<br />2.动态和静态初始化可以拆分为两步骤。<br />3.静态初始化一旦使用省略模式，就不能拆分成为两步骤了。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">拆分为两步骤。</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;">[] array1;
array1 </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[7<span style="color: #000000;">]

</span><span style="color: #0000ff;">int</span><span style="color: #000000;">[] array2;
array2 </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[] {3,4,5,6,7}</pre>
</div>
<p>&nbsp;</p>
<h3>数组元素的访问</h3>
<p><strong>直接打印数组名称：</strong>得到的是数组对应的，内存地址哈希值。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">访问数组元素的格式：数组名称[索引值]
索引值：就是一个int数字，代表数组当中元素编号。</span></pre>
</div>
<p><strong>【注意】：索引值从0开始，一直到&ldquo;数组的长度-1&rdquo;为止。</strong></p>
<p>使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。如下：</p>
<ul>
<li>如果是整数类型：那么默认值为0</li>
<li>如果是浮点类型：那么默认值为0.0</li>
<li>如果是字符类型：那么默认值为\u0000</li>
<li>如果是布尔类型：那么默认值为false</li>
<li>如果是引用类型：那么默认值为null</li>
</ul>
<p><strong>注意事项：</strong><br />静态初始化其实也有默认值，只不过系统自动马上将默认值替换成为了大括当中的具体数值。</p>
<p>&nbsp;</p>
<h3>Java的内存需要划分成为5个部分：</h3>
<p><strong>1.栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。</strong></p>
<ul>
<li>	局部变量：方法的参数，或者是方法{}内部的变量</li>
<li>	作用域：一旦超出作用域，立从栈内存当中消失。</li>

</ul>
<p><strong>2.堆（Heap）：凡是new出来的东西，都在堆当中。</strong><br />	堆内存里面的东西都有一个地址值：16进制<br />	堆内存里面的数据，都有默认值。规则：</p>
<ul>
<li>		如果是整数类型：那么默认值为0</li>
<li>		如果是浮点类型：那么默认值为0.0</li>
<li>		如果是字符类型：那么默认值为\u0000</li>
<li>		如果是布尔类型：那么默认值为false</li>
<li>		如果是引用类型：那么默认值为null</li>

</ul>
<p><br /><strong>3.方法区（Method Area）：存储.class相关信息，包含方法的信息。</strong></p>
<p>4.本地方法栈（Native Method Stack）：与操作系统相关。<br />5.寄存器（pc Register）：与cpu相关。</p>
<p>&nbsp;</p>
<h3>数组操作异常：</h3>
<p>数组索引号越界异常<br />数组的索引编号从0开始，一直到&ldquo;数组的长度-1&rdquo;为止。</p>
<p>如果访问数组元素的时候，索引号并不存在，那么将会发生</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">数组索引号越界异常
ArrayIndexOutOfBoundsException</span></pre>
</div>
<p><strong>原因：索引编号写错了。</strong><br /><strong>解决：修改成为存在正确索引编号</strong></p>
<p>&nbsp;</p>
<h3>空指针异常</h3>
<p>所有的引用类型变量，都可以赋值为一个null值。但是代表其中什么都没有。</p>
<p>数组必须进行new初始化才能使用其中的元素。<br />如果只是赋值了一个null，没有进行new创建，那么将会发生</p>
<div class="cnblogs_code">
<pre>空指针异常 <br />NullPointerException</pre>
</div>
<p><strong>原因：忘了new</strong><br /><strong>解决：补上new</strong></p>
<p>&nbsp;</p>
<h3>获取数组的长度</h3>
<p>如何获取数组的长度，格式：</p>
<div class="cnblogs_code">
<pre>数组名称.length</pre>
</div>
<p>这将会得到一个int数字，代表数组的长度</p>
<p><strong>数组一旦创建，程序运行期间，长度不可改变。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">例子：数组的反转
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNaio{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #0000ff;">int</span>[] array = {10,20,30,40,50<span style="color: #000000;">};
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历打印数组本来的样子</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;array.length;i++<span style="color: #000000;">){
            System.out.println(array[i]);
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">进行反转操作</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> min = 0,max = array.length-1;min &lt;max;min++,max--<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> array[min];
            array[min] </span>=<span style="color: #000000;"> array[max];
            array[max] </span>=<span style="color: #000000;"> array[temp];
        }
        
        </span><span style="color: #008000;">//</span><span style="color: #008000;">再次遍历打印数组</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i&lt;array.length;i++<span style="color: #000000;">){
            System.out.println(array[i]);
            }
    }
}</span></pre>
</div>
<h3>&nbsp;</h3>
<h3>数组可以作为方法的参数</h3>
<p>当调用方法的时候，向方法的小括进行传参，传递进去的其实是数组的<strong>地址值。</strong></p>
<p>一个方法可以有<strong>0、1、多个参数</strong>，但是只能有0或者1个返回值，不能有多个返回值。<br />如果希望一个方法当中产生了多个结果数据进行返回，怎么办？<br /><strong>解决方案：使用一个数组作为返回值类型即可。</strong></p>
<h3>&nbsp;</h3>
<h3>数组可以作为返回值类型</h3>
<p>任何数据类型都能作为方法的参数类型，或者<strong>返回值类型</strong>。</p>
<ul>
<li>数组作为方法的参数，传递进去的其实是数组的地址值。</li>
<li>数组作为方法的返回值，返回的其实也是数组的地址值。</li>

</ul>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：方法重载的使用规则</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/20/11061116.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 20 Jun 2019 12:19:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/20/11061116.html</guid><description><![CDATA[<h2 style="text-align: center;"><strong>方法的重载</strong></h2>
<p>对于功能类似的方法来说，因为参数列表不一样，却需要记住那多不同的方法名称，太麻烦。</p>
<p><strong>方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样。</strong><br /><strong>好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。</strong></p>
<p>&nbsp;</p>
<p><strong>方法的重载与下列因素相关：</strong></p>
<ol>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数的多类型顺序不同</li>
</ol>
<p><strong>方法的重载与下列因素无关：</strong></p>
<ol>
<li>与参数的名称无关</li>
<li>与方法的返回值类型无关</li>
</ol>
<p><strong>例子：</strong></p>
<p>题目要求：<br /><strong>比较两数据是否相等。</strong><br />参数类型分别为两个byte类型、两个short类型、两个int类型、两个long类型。<br />并在main方法中进行测试</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        </span><span style="color: #0000ff;">byte</span> a = 10<span style="color: #000000;">;
        </span><span style="color: #0000ff;">byte</span> b = 20<span style="color: #000000;">;
        System.out.println(isSame(a,b));
        
        System.out.println((isSame(</span><span style="color: #0000ff;">short</span>)20,(<span style="color: #0000ff;">short</span>)20<span style="color: #000000;">));
        
        System.out.println(isSame(</span>11,22<span style="color: #000000;">));
        
        System.out.println(isSame(</span>10L,10L<span style="color: #000000;">));
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">boolean</span> isSame(<span style="color: #0000ff;">byte</span> a,<span style="color: #0000ff;">byte</span><span style="color: #000000;"> b){
        System.out.println(</span>"两byte参数的方法执行！"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">boolean</span><span style="color: #000000;"> same ;
        </span><span style="color: #0000ff;">if</span>(a==<span style="color: #000000;">b){
            same </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            same </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> same;
    }<br />
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">boolean</span> isSame(<span style="color: #0000ff;">short</span> a,<span style="color: #0000ff;">short</span><span style="color: #000000;"> b){
        System.out.println(</span>"两short参数的方法执行！"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">boolean</span> same = a == b ?<span style="color: #0000ff;">true</span>:<span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> same;
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">boolean</span> isSame(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
        System.out.println(</span>"两int参数的方法执行！"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> a ==<span style="color: #000000;"> b:;
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">boolean</span> isSame(<span style="color: #0000ff;">long</span> a,<span style="color: #0000ff;">long</span><span style="color: #000000;"> b){
        System.out.println(</span>"两long参数的方法执行！"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (a==<span style="color: #000000;">b){
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：方法的使用与注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/20/11060933.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 20 Jun 2019 11:45:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/20/11060933.html</guid><description><![CDATA[<h2 style="text-align: center;"><strong>方法的使用与注意事项</strong></h2>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">定义一个方法的格式：<br />public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> 方法名称（）{
方法体
}<br />
如何调用方法，格式：

方法名称（）；</span></pre>
</div>
<ol>
<li>方法名称的命名规则和变量一样，使用小驼峰。</li>
<li>方法体：也就是大括当中可以包含任意条语句。</li>
<li>方法定义好了之后，不会执行。如果要想执行，一定要进行方法的【调用】。</li>
</ol>
<p><strong>方法其实就是若干语句的功能集合。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><strong>方法好比是一个工厂。<br /><br /></strong>
奶粉工厂 原料：奶牛、饲料、水
产出物：奶制品<br />
钢铁工厂 原料：铁矿石、煤炭
产出物：钢铁建材</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<ul>
<li>参数（原料）：就是进入方法的数据。</li>
<li>返回值（产出物）：就是从方法中出来的数据。</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><strong>定义方法的完整格式：<br /><br /></strong>
修饰符 返回值类型 方法名称（参数类型 参数名称,...){
方法体
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> 返回值；
}</span></pre>
</div>
<p>&nbsp;</p>
<ul>
<li>修饰符:常用的固定写法，public static</li>
<li>返回值类型：也就是方法最终产生的数据结果是什么类型</li>
<li>方法名称：方法的名字，规则和变量一样，小驼峰</li>
<li>参数类型：进入方法的数据是什么类型</li>
<li>参数名称：进入方法的数据对应的变量名称</li>
</ul>
<p>ps：参数如果有多个，使用逗号进行分隔</p>
<ul>
<li>方法体：方法需要做的事情，若干行代码</li>
<li>return:两作用，第一停止当前方法，第二将后面的返回值还给调用处</li>
<li>返回值：也就是方法执行后最终产生的数据结果</li>
</ul>
<p><strong>注意：return后面的&ldquo;返回值&rdquo;，必须和方法名称前面的&ldquo;返回值类型&rdquo;，保持对应。</strong></p>
<p>定义一个，两int数字相加的方法。三要素：</p>
<div class="cnblogs_code">
<pre>返回值类型：<span style="color: #0000ff;">int</span><span style="color: #000000;">
方法名称：sum
参数列表：</span><span style="color: #0000ff;">int</span> a，<span style="color: #0000ff;">int</span> b</pre>
</div>
<p>&nbsp;</p>
<p>方法的三种调用格式。</p>
<ol>
<li>单独调用：方法名称(参数)；</li>
<li>打印调用：System.out.println(方法名称（参数））；</li>
<li>赋值调用：数据类型 变量名称= 方法名称(参数);</li>
</ol>
<p><strong>注意：此前学习的方法，返回值类型固定写为void，这种方法只能单独调用，不能进行打印调用或者赋值调用。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
</span><span style="color: #008000;">//</span><span style="color: #008000;">单独调用：方法名称</span>
sum(3,7<span style="color: #000000;">);
System.out.println(</span>"======"<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;">打印调用：System</span>
System.out.println(sum(3,3<span style="color: #000000;">);
System.out.println(</span>"======"<span style="color: #000000;">);

</span><span style="color: #008000;">//</span><span style="color: #008000;">赋值调用</span>
<span style="color: #0000ff;">int</span> number = sum(15,25<span style="color: #000000;">)
System.out.println(</span>"变量的值:" +<span style="color: #000000;"> number);

}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> sum(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
System.out.println(</span>"方法执行"<span style="color: #000000;">);
</span><span style="color: #0000ff;">int</span> result = a +<span style="color: #000000;"> b;
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result;
}
}</span></pre>
</div>
<p>&nbsp;</p>
<ul>
<li>有参数 ：小括当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数。</li>
</ul>
<p>例两数字相加，必须知道两数字是各自多少，才能相加。</p>
<ul>
<li>无参数：小括号当中留空。一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数。</li>
</ul>
<p>例定义一个方法，打印固定10次菜鸟。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main (String[] args){
text1(</span>33,77<span style="color: #000000;">);
text2();
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> text1(<span style="color: #0000ff;">int</span> a ,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b){
</span><span style="color: #0000ff;">int</span> result = a*<span style="color: #000000;">b;
System.out.println(</span>"结果是： " +<span style="color: #000000;"> result);
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> text2(){
</span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = 0;i &lt; 10;i ++<span style="color: #000000;">){
System.out.println(</span>"菜鸟" +<span style="color: #000000;"> i);    
}
}</span></pre>
</div>
<h3>&nbsp;</h3>
<h3><strong>对于有无返回值：</strong></h3>
<p><strong>注意事项：</strong></p>
<ul>
<li>对于有返回值的方法，可以使用单独调用、打印调用或者赋值调用。</li>
<li>但是对于无返回值的方法，只能使用单独调用，不能使用打印调用或者赋值调用<strong>。</strong></li>
</ul>
<p>&nbsp;</p>
<p><strong>使用方法的时候，注意事项：</strong></p>
<ol>
<li>方法应该定义在类当中，但是不能在方法当中定义方法。不能嵌套。</li>
<li>方法定义的前后顺序无所谓。</li>
<li>方法定义之后不会执行，如果希望执行，一定要调用：单独使用、打印调用、赋值调用。</li>
<li>如果方法有返回值，那么必须写上"return 返回值"，不能没有</li>
<li>return后面的返回值数据，必须和方法的返回值类型，对应起来。</li>
<li>对于一个void没有返回值的方法，不能写return后面的返回值，只能写return自己。</li>
</ol>]]></description></item><item><title>java学习：循环结构的使用规则和注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/19/11052390.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 19 Jun 2019 08:55:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/19/11052390.html</guid><description><![CDATA[<p>&nbsp;<strong>循环结构的基本组成部分，一般可分为四部分：</strong></p>
<ol>
<li>初始化语句：在循环开始最初执行，而且只做唯一一次</li>
<li>条件判断：如果成立，则循环继续；如果不成立，则循环退出。</li>
<li>循环体：重复要做的事情内容，若干行语句。</li>
<li>进步语句：每次循环之后都要进行的扫尾工作。</li>
</ol>
<div class="cnblogs_code">
<pre><span style="color: #000000;">for循环格式：
</span><span style="color: #0000ff;">for</span><span style="color: #000000;">(初始化语句；条件判断；进步语句){
循环体；
}

while循环格式：
初始化语句； 
</span><span style="color: #0000ff;">while</span><span style="color: #000000;">（条件判断）{
循环体；
进步语句；
}

</span><span style="color: #0000ff;">do</span>-<span style="color: #000000;">while循环格式：
初始化语句； 
</span><span style="color: #0000ff;">do</span><span style="color: #000000;">{
循环体；
进步语句；
}</span><span style="color: #0000ff;">while</span>（条件判断）；</pre>
</div>
<p>&nbsp;</p>
<p><strong>三种循环的区别：</strong></p>
<ol>
<li>如果条件判断从来都没有满足过，那么for循环和while循环将会执行0次，但是do-while会执行至少一次。</li>
<li>for循环的变量在小括中定义，只有循环内部才可以使用。while和do-while循环初始化语句本来就在外面，所以出来循环后还可以使用。</li>
</ol>
<p><strong>关于循环的选择，有一个小建议：</strong></p>
<ul>
<li>凡是次数确定的场景多用for循环；否则多用while循环。</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：switch语句使用的注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/19/11051843.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 19 Jun 2019 07:54:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/19/11051843.html</guid><description><![CDATA[<h3><strong>switch语句使用的注意事项：</strong></h3>
<ul>
<li><strong>多个case后面的数值不可以重复。</strong></li>
<li><strong>switch后面的小括当中只能是下列数据类型：</strong></li>
</ul>
<ol>
<li>基本数据类型：byte/short/char/int</li>
<li>引用数据类型：String字符串、enum枚举、</li>
</ol>
<ul>
<li><strong>switch语句格式可以很灵活：前后顺序可以颠倒，而且break语句还可以省略。</strong></li>
</ul>
<ol>
<li>&ldquo;匹配到哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止。&rdquo;</li>
</ol>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CaiNiao{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> mian(String[] args){
        </span><span style="color: #0000ff;">int</span> num = 3
        <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (num){
            </span><span style="color: #0000ff;">case</span> 1<span style="color: #000000;">:
                System.out.println(</span>"菜鸟"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span> 2<span style="color: #000000;">:
                System.out.println(</span>"传奇"<span style="color: #000000;">);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:
                System.out.println(</span>"小菜鸟"<span style="color: #000000;">)
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>JDK9版本以上Java独有的一个轻量级小工具，你知道吗？jshell</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/19/11051813.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 19 Jun 2019 07:51:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/19/11051813.html</guid><description><![CDATA[<p><strong>jshell，</strong>是JavaJDK9这个大版本更新以来，带来的一个轻量级小工具。我们再也不用进入Java目录，编写一个Java文件，然后再去编译，最后才能执行它。</p>
<p>这里，你可以直接写一个小功能，就能去实现它。这就是jshell带来的一个小便利。</p>
<p>介绍：jshell这是Java用来写脚本的轻量小工具。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.byteimg.com/large/pgc-image/bff1e811d23c46cfaf010278747d2421" alt="" data-ic="false" data-ic-uri="" data-height="566" data-width="877" data-story_id="0" data-image_ids="[]" />
<div class="editor-image-menu">&nbsp;</div>
<ul>
<li class="editor-image-menu"><strong>直接输入:jshell进入</strong></li>
<li class="editor-image-menu"><strong>退出： 输入/exit&nbsp; &nbsp;记得一定要加/</strong></li>
</ul>
</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-caption-wrapper">
<div class="cnblogs_code">
<pre><span style="color: #000000;">
对于byte</span>/<span style="color: #0000ff;">short</span>/<span style="color: #0000ff;">char</span>/<span style="color: #000000;">三种类型来说，如果右侧赋值的数值没有超过范围，
那么Javac编译器将会自动隐含的为我们补上一个（</span><span style="color: #0000ff;">byte</span>）（<span style="color: #0000ff;">short</span>）（<span style="color: #0000ff;">char</span><span style="color: #000000;">）。

</span><span style="color: #0000ff;">byte</span> num1 = <span style="color: #800080;">30</span>；<span style="color: #008000;">//</span><span style="color: #008000;">30
</span><span style="color: #008000;">//</span><span style="color: #008000;">int--&gt;byte ，不是自动类型转换
</span><span style="color: #008000;">//</span><span style="color: #008000;">int--&gt;char ，不是自动类型转换</span>
<span style="color: #0000ff;">char</span> zifu = <span style="color: #008000;">/*</span><span style="color: #008000;">（char）</span><span style="color: #008000;">*/</span><span style="color: #800080;">65</span>；<span style="color: #008000;">//</span><span style="color: #008000;">A 可以操作</span>
<span style="color: #000000;">
注意：
如果没有超过左侧的范围，编译器补上强转。
如果右侧超过了左侧的范围，那么直接编译器报错。、<br />
</span>==============================<span style="color: #000000;">

注意：常量可以自动优化，如果是变量就不可以了。

</span><span style="color: #0000ff;">short</span> a = <span style="color: #800080;">3</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">short</span> b = <span style="color: #800080;">7</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">short</span> result = <span style="color: #800080;">3</span>+<span style="color: #800080;">7</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">short = result = a + b；</span><span style="color: #008000;">//</span><span style="color: #008000;"> 报错，不可以运行</span>
System.<span style="color: #0000ff;">out</span>.println(result);<span style="color: #008000;">//</span><span style="color: #008000;">可以运行</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div>]]></description></item><item><title>Java学习：运算符的使用与注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/18/11046487.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 18 Jun 2019 09:33:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/18/11046487.html</guid><description><![CDATA[<h2 style="text-align: center;"><strong>运算符的使用与注意事项</strong></h2>
<p><br />四则运算当中的加号&ldquo;+&rdquo;有常见的三种用法：</p>
<ol>
<li><strong>对于数值来，那就是加法。</strong></li>
<li><strong>对于字符char类型来说，在计算之前，char会被提升成为int，然后再计算。char类型字符，和int类型数字之间的对照关系比表：ASCII，Unicode</strong></li>
<li><strong>对于字符串String（首字母大写，并不是关键字）来，加号代表字符串连操作。任何数据类型和字符串进行连接的时候，结果都会变成字符串</strong></li>

</ol>
<ul>
<li><strong>自增运算符：++</strong></li>
<li><strong>自减运算符：--</strong></li>

</ul>
<p>基本含义：让一个变量涨一个数字，或者让一个变量降一个数字1<br />使用格式：写在变量名称之前，或者写在变量名称之后。</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>例：++num，也可以num++</pre>
</div>
<p>&nbsp;</p>
<p><strong>使用方法：</strong></p>
<ol>
<li>　单独使用 ：不和其他任何操作混合，自己独立成为一个步骤</li>
<li>　混合使用 ；和其他操作混合，例如与赋值混合，或者与打印操作混合，等</li>
</ol>
<p><strong>使用区别</strong>：</p>
<ol>
<li>　在单独使用的时候，前++和后++没有任何区别。也就是两是完全一样的效果。</li>
<li>　在混合使用时，有很大的区别【注意】</li>
</ol>
<ul>
<li>A:如果时【前++】，那么变量【立刻+1】，然后拿着结果进行使用。【先加后用】</li>
<li>B:如果时【后++】，那么首先使用本来的值，【然后再让变量+1】. 【先用后加】</li>
</ul>
<p><br /><strong>注意事项：</strong><br />	　　只有变量才能使用自增、自减运算符。常量不可以发生改变，所以不能用。</p>
<p><br /><strong>		赋值运算符分为：</strong></p>
<p>基本赋值运算符：就是一个等号&ldquo;=&rdquo; ，代表将右侧的数据交给左侧的变量。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> a = 30<span style="color: #000000;">；

复合赋值运算符；<br />
</span>+= a+=3 相当于 a=a+3
-= *= /= %= 都是如此</pre>
</div>
<p>&nbsp;</p>
<p>注意事项：</p>
<ul>
<li>只有变量才能使用赋值运算符，常量不能进行赋值。</li>
<li>复合赋值运算符其中隐含了一个强制类型转换。</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">byte</span> num = 30<span style="color: #000000;">；
num </span>+= 5<span style="color: #000000;">；
</span><span style="color: #008000;">//</span><span style="color: #008000;">num = num + 5
</span><span style="color: #008000;">//</span><span style="color: #008000;">num = byte + int
</span><span style="color: #008000;">//</span><span style="color: #008000;">num = int + int
</span><span style="color: #008000;">//</span><span style="color: #008000;">num = int
</span><span style="color: #008000;">//</span><span style="color: #008000;">num = （byte） int</span>
System.out.println(num);<span style="color: #008000;">//</span><span style="color: #008000;">35</span></pre>
</div>
<p>&nbsp;</p>
<h3><strong>比较运算符：</strong></h3>
<div class="cnblogs_code">
<pre>大于 : &gt;<span style="color: #000000;">
小于 ：</span>&lt;<span style="color: #000000;">
大于等于 : </span>&gt;=<span style="color: #000000;">
小于等于 : </span>&lt;+<span style="color: #000000;">
相等 ：</span>==<span style="color: #000000;">
不相等 ：</span>!=</pre>
</div>
<p>&nbsp;</p>
<p>注意事项：</p>
<ol>
<li>比较运算符的结果一定是一个Boolean值，成立就是true，不成立就是false</li>
<li>如果进行多次判断，不能连写。</li>
</ol>
<div class="cnblogs_code">
<pre>数学当中的写法，例：3&lt;x&lt;7<span style="color: #000000;">
程序当中【不允许】这种写法。</span></pre>
</div>
<p>&nbsp;</p>
<h3>逻辑运算符</h3>
<div class="cnblogs_code">
<pre>与 &amp;&amp;<span style="color: #000000;"> 全都是真才为真，否则为假
或 </span>||<span style="color: #000000;"> 至少一个为真就是真，全都是假才为假
非 ！ 取反</span></pre>
</div>
<p>&nbsp;</p>
<p>与&ldquo;&amp;&amp;&rdquo; ，或&ldquo;||&rdquo;就有短路效果：如果根据左边已经可以判断得到最终结果，那么后面则不在执行，从而节省一定的效能</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>逻辑运算符只能用于Boolean值。</li>
<li>与，或两运算符，如果有多个条件，可以连续写</li>
</ol>
<ul>
<li>两个条件：条件A&amp;&amp;条件B</li>
<li>多个条件：条件A&amp;&amp;条件B条件C</li>
</ul>
<h3>三元运算符</h3>
<p>一元运算符：只需一个数据就可以进行操作的运算符，例：取反！、自增、自减<br />二元运算符：需要两个数据就可以进行操作的运算符，例：加法、减法<br />三元运算符: 需要三个数据就可以进行操作的运算符,</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">格式
数据类型 变量名 </span>= 条件判断 ？ 表达式A ： 表达式B</pre>
</div>
<p>&nbsp;</p>
<p><strong>流程：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">首先判断条件是否成立:
如果成立为true，那么将表达式A的值赋给左侧的变量
如果不成立为false，那么将表达式B的值赋给左侧的变量
二者选一：</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>必须同时满足表达式A和表达式B都符合左侧的数据类型要求。</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> cai = 3&gt;4?3.7:10;<span style="color: #008000;">//</span><span style="color: #008000;">错误写法</span></pre>
</div>
<ul>
<li>三元运算符的结果必须被使用</li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：数据类型转换注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/18/11045318.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 18 Jun 2019 07:19:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/18/11045318.html</guid><description><![CDATA[<h2 style="text-align: center;">数据类型的转换</h2>
<h3><strong>当数据类型不一样时，将会发生数据类型转换。</strong></h3>
<p><strong>自动类型转换（隐式）</strong><br />	　　1.特点 ：代码不需要进行特殊处理，自动完成。<br />	　　2.规则 ：数据范围从小到大。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">左边是long类型，右边是默认的int类型，左右不一样
</span><span style="color: #008000;">//</span><span style="color: #008000;">将右边的int常量，交给左侧的long变量进行存储
</span><span style="color: #008000;">//</span><span style="color: #008000;">int--&gt; long ,符合数据范围从小到大的要求</span>
<span style="color: #0000ff;">long</span> num1 = 100<span style="color: #000000;">；
System.out.println(num1);

</span><span style="color: #0000ff;">double</span> num2 = 2.5F<span style="color: #000000;">;
System.out.println(num2)</span></pre>
</div>
<p>&nbsp;</p>
<p><br /><strong>强制类型转换（显式）</strong></p>
<p>	　　1.特点 ：代码需要进行特殊处理，不能自动完成。<br />	　　2.格式 ：范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据；</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">左边是int类型，右边是long类型，不一样
</span><span style="color: #008000;">//</span><span style="color: #008000;">long --&gt; int,不是从小到大
</span><span style="color: #008000;">//</span><span style="color: #008000;">不能发生自动类型转换
</span><span style="color: #008000;">//</span><span style="color: #008000;">范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据；</span>
<span style="color: #0000ff;">int</span> num1 = （<span style="color: #0000ff;">int</span>） 100L<span style="color: #000000;">;
System.out.println(num1)</span><span style="color: #008000;">//</span><span style="color: #008000;">100</span>

<span style="color: #0000ff;">int</span> num2 = (<span style="color: #0000ff;">int</span>)777777777777L<span style="color: #000000;">;
System.out.println(num2);</span><span style="color: #008000;">//</span><span style="color: #008000;">170532704</span>

<span style="color: #0000ff;">int</span> num3 = (<span style="color: #0000ff;">int</span>)3.77<span style="color: #000000;">;
System.out.println(num3);</span><span style="color: #008000;">//</span><span style="color: #008000;">3 所有小数被舍弃</span>

<span style="color: #0000ff;">char</span> zifu = 'A'<span style="color: #000000;">;
System.out.println(zifu </span>+ 1);<span style="color: #008000;">//</span><span style="color: #008000;">66 这里的A被当作65处理</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>注意事项：</strong><br />	1.强制类型转换一般不推荐使用，因为有可能发生精度损失，数据溢出。<br />	2.byte/short/char这三种类型都可以发生数学运算，例加法&ldquo;+&rdquo;<br />	3.byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。<br />	4.Boolean类型不能发生数据类型转换<br />	</p>
<h3>数字和字符的对照关系表（编码表）</h3>
<p>ASCII码表：American Standard Code for Information Interchange，美国信息交换标准代码。<br />Unicode码表：万国码。也是数字和符号的对照关系，开头0-127部分和ASCII一样，但是从128开始包含有更多字符。</p>
<div class="cnblogs_code">
<pre>48 --- &rsquo;0<span style="color: #000000;">&lsquo;
</span>65 ---<span style="color: #000000;"> &rsquo;A&lsquo;
</span>97 --- &rsquo;a'</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Java学习：常量和变量 的定义和注意事项</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/17/11041949.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 17 Jun 2019 12:12:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/17/11041949.html</guid><description><![CDATA[<h2><strong>常量：在程序运行期间，固定不变的量。</strong></h2>
<p><strong>常量的分类：</strong><br /><strong>1.字符串常量：</strong>凡是用双引号引起来的部分，叫做字符串常量。</p>
<div class="cnblogs_code">
<pre>例如："abc","Hello","123"<span style="color: #000000;">
(两个双引号之间可以为空)</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>2.整数常量:</strong>直接写上的数字，无小数点。</p>
<div class="cnblogs_code">
<pre>例如：100,37,0,-109</pre>
</div>
<p>&nbsp;</p>
<p><strong>3.浮点数常量：</strong>直接写上的数字，有小数点。</p>
<div class="cnblogs_code">
<pre>例如：2.5,3.14,0.0</pre>
</div>
<p>&nbsp;</p>
<p><strong>4.字符常量：</strong>凡是用单引号引起来的部分，叫做字符常量。</p>
<div class="cnblogs_code">
<pre>例如：'A','B','7','菜'<span style="color: #000000;">
（两个单引号之间有且只有一个字符，没有不行，有两个也不行）</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>5.布尔常量：</strong>只有两种取值。</p>
<div class="cnblogs_code">
<pre>例如：<span style="color: #0000ff;">true</span>，<span style="color: #0000ff;">false</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>6.空常量：null。</strong></p>
<div class="cnblogs_code">
<pre>代表没有任何数据</pre>
</div>
<p>&nbsp;</p>
<h2>变量：程序运行期间，类容可以发生改变的量。</h2>
<h3>创建一个变量并且使用的格式：</h3>
<div class="cnblogs_code">
<pre>数据类型 变量名； <span style="color: #008000;">//</span><span style="color: #008000;">创建了一个变量</span>
变量名称 = 数据值； <span style="color: #008000;">//</span><span style="color: #008000;">赋值，将右边的数据值赋值给左边的变量</span></pre>
</div>
<p>&nbsp;</p>
<h3>一步到位的格式：</h3>
<div class="cnblogs_code">
<pre>数据类型 变量名称 = 数据值；<span style="color: #008000;">//</span><span style="color: #008000;">在创建一个变量的同时，立刻放入指定的数据值</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>使用变量的时候，有哪些注意事项；</strong></p>
<div class="cnblogs_code">
<pre>1<span style="color: #000000;">，如果创建多个变量，那么变量之间的名称不可以重复
</span>2<span style="color: #000000;">，对于float和long类型来说，字母后缀F和L不要丢掉。
</span>3<span style="color: #000000;">.如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围。
</span>4<span style="color: #000000;">.没有进行赋值的变量，不能直接使用；一定要赋值之后才能使用。
</span>5<span style="color: #000000;">.变量使用不能超过作用域的范围。
【作用域】：从定义变量的一行开始，一直到直接所属的大括号结束为止。</span></pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>Windows中DOS简单命令的总结</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/17/11041924.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 17 Jun 2019 12:06:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/17/11041924.html</guid><description><![CDATA[<h1 style="text-align: center;"><strong>MS-DOS</strong></h1>
<h2>命令提示符（cmd)</h2>
<ul>
<li><strong>启动：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Win+R，输入cmd回车</strong></li>
<li><strong>切换盘符&nbsp; &nbsp; &nbsp; &nbsp;　　&nbsp; &nbsp; 盘符名称：</strong></li>
<li><strong>进入文件夹&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd 文件夹名称</strong></li>
<li><strong>进入多级文件夹&nbsp; &nbsp; &nbsp; &nbsp;cd 文件夹1/文件夹2/文件夹3</strong></li>
<li><strong>返回上一级&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd .. </strong></li>
<li><strong>直接回跟路径&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd /</strong></li>
<li><strong>查看当前内容&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dir</strong></li>
<li><strong>清屏&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cls</strong></li>
<li><strong>退出&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit</strong></li>
</ul>
<p>&nbsp;</p>]]></description></item><item><title>FusionInsight大数据开发--HBase应用开发</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/12/11010227.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 12 Jun 2019 08:03:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/12/11010227.html</guid><description><![CDATA[<h2 style="text-align: center;">HBase应用开发</h2>
<h3>HBase的定义</h3>
<p><strong>HBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统。</strong></p>
<ul>
<li>适合于存储大表数据，可以达到实时级别。</li>
<li>利用Hadoop HDFS 作为其文件存储系统，提供实时的读写的数据库系统。</li>
<li>利用ZooKeeper作为协同服务。</li>
</ul>
<h3>HBase架构</h3>
<h3>HBase的适用场景</h3>
<ul>
<li>海量数据</li>
<li>高吞吐量</li>
<li>需要在海量数据中实现高效的随机读取</li>
<li>需要很好的性能伸缩能力</li>
<li>能够同时处理结构化和非结构化的数据</li>
<li>不需要完全拥有传统关系型数据库所具备的ACID特性</li>
</ul>
<h3>HBase应用开发流程</h3>
<ul>
<li>制定业务目标</li>
<li>准备开发环境</li>
<li>下载并导入样例工程</li>
</ul>
<h3><strong>设计HBase表</strong></h3>
<p><strong>设计原则：</strong></p>
<p><strong>查询数据唯一</strong></p>
<p><strong>数据均匀分布</strong></p>
<p><strong>查询性能优化</strong></p>
<p><strong>其他因素（region的提前划分，冷热Family的使用</strong>)</p>
<ul>
<li>根据场景开发工程</li>
<li>编译并运行程序</li>
<li>查看结果与调试程序</li>
</ul>
<h3>HBase表设计-总体原则</h3>
<p>设计目标：提高吞吐量<br />设计原则：预分region，是region分布均匀，提高并发<br />实现方法：Rowkey范围和分布已知，建议预分region</p>
<p>设计目标：提高写入性能<br />设计原则：避免过多的热点region<br />设计方法：根据应用场景，可以考虑将时间因素引入Rowkey</p>
<p>设计目标：提高查询性能<br />设计原则：数据连续存储，频繁访问的数据存储一个地方，数据连续存储，离散度，信息冗余。<br />实现方法：同时读取的数据存放在同一行、cell，使用二级索引</p>
<h3>HBase表设计-设计内容</h3>
<p>设计内容通过不同维度，可分为：<br /><strong>Table设计（表粒度的设计）</strong></p>
<ul>
<li>建表方法</li>
<li>预分region</li>
<li>Family属性</li>
<li>系统并发能力、数据清洗能力</li>









</ul>
<h3><strong>RowKey设计</strong></h3>
<ul>
<li>原则：需要同时访问的数据，RowKey尽量连续</li>
<li>访问效率：分散写，连续读</li>
<li>属性内容：常用的查询场景属性</li>
<li>属性值顺序：枚举，访问权重</li>
<li>时间属性：循环Key+TTL，周期建表</li>
<li>二级索引</li>
<li>折中法</li>
<li>冗余法</li>









</ul>
<h3><strong>Family设计</strong></h3>
<p>可枚举数量少扩展性弱的属性作为Family</p>
<h3><strong>Qualifier设计</strong></h3>
<p>&nbsp;不可枚举、数量多且扩展性强的属性作为Qualifier</p>
<p>原则：同时访问的数据存放到同一个Cell，列名尽量简短</p>
<h3>HBase常用接口</h3>
<p>create（）</p>
<p>put（）</p>
<p>get（）</p>
<p>getScanner（Scan scan）</p>
<p>、、、</p>
<h3>创建Configuration实例以及Kerberos安全认证</h3>
<p>HBaseConfiguration方法</p>
<h3><strong>创建表</strong></h3>
<p>create Table方法</p>
<h3><strong>写入数据</strong></h3>
<p>put方法</p>
<h3><strong>读取一行数据</strong></h3>
<p>get方法</p>
<h3><strong>读取多行数据</strong></h3>
<p>scan方法</p>
<p><a href="https://www.cnblogs.com/cainiao-chuanqi/p/11009077.html" target="_blank">&nbsp;更新中.....</a>.</p>
<h2>&nbsp;</h2>
<p>&nbsp;</p>]]></description></item><item><title>学习自查：目录(更新中...）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/12/11009077.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 12 Jun 2019 05:31:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/12/11009077.html</guid><description><![CDATA[<h1 style="text-align: center;">目录</h1>
<ul>
<li><span style="text-decoration: line-through;">Linux</span></li>
<li><span style="text-decoration: line-through;">大数据</span></li>
<li><span style="text-decoration: line-through;">软件设计</span></li>
<li><span style="text-decoration: line-through;">爬虫，python</span></li>
<li><span style="text-decoration: line-through;">面向对象设计（Java）</span></li>
<li><span style="text-decoration: line-through;">项目总结</span></li>
<li><span style="text-decoration: line-through;">其他</span></li>
</ul>
<hr />
<h2 style="text-align: center;">&nbsp;面向对象设计模式</h2>
<ul>
<li><strong>&nbsp;<a id="post_title_link_10957617" href="https://www.cnblogs.com/cainiao-chuanqi/p/10957617.html">面向对象设计模式总结</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_10957708" href="https://www.cnblogs.com/cainiao-chuanqi/p/10957708.html">23种设计模式</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_10958780" href="https://www.cnblogs.com/cainiao-chuanqi/p/10958780.html">UML统一建模语言介绍</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_10959800" href="https://www.cnblogs.com/cainiao-chuanqi/p/10959800.html">软件设计的七大原则</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_10966300" href="https://www.cnblogs.com/cainiao-chuanqi/p/10966300.html">GoF的23种设计模式之创建型模式的特点和分类</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_10978331" href="https://www.cnblogs.com/cainiao-chuanqi/p/10978331.html">GoF的23种设计模式之结构型模式的特点和分类</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_10979160" href="https://www.cnblogs.com/cainiao-chuanqi/p/10979160.html">GoF的23种设计模式之行为型模式的特点和分类(1)</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_10979389" href="https://www.cnblogs.com/cainiao-chuanqi/p/10979389.html">GoF的23种设计模式之行为型模式的特点和分类(2)</a></strong></li>
</ul>
<hr />
<h2 style="text-align: center;">软件设计</h2>
<ul>
<li><strong><a id="post_title_link_10396585" href="https://www.cnblogs.com/cainiao-chuanqi/p/10396585.html">软考知识分析</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10418787" href="https://www.cnblogs.com/cainiao-chuanqi/p/10418787.html">面向对象设计</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10420491" href="https://www.cnblogs.com/cainiao-chuanqi/p/10420491.html">计算机组成原理和体系结构</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10427704" href="https://www.cnblogs.com/cainiao-chuanqi/p/10427704.html">操作系统基本原理</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a href="https://www.cnblogs.com/cainiao-chuanqi/p/10433188.html">数据库系统</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10436628" href="https://www.cnblogs.com/cainiao-chuanqi/p/10436628.html">计算机网络</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10445858" href="https://www.cnblogs.com/cainiao-chuanqi/p/10445858.html">数据结构与算法基础</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10449519" href="https://www.cnblogs.com/cainiao-chuanqi/p/10449519.html">软件工程</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10452163" href="https://www.cnblogs.com/cainiao-chuanqi/p/10452163.html">信息安全基础知识</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10458382" href="https://www.cnblogs.com/cainiao-chuanqi/p/10458382.html">程序设计语言与语言处理程序基础</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10460476" href="https://www.cnblogs.com/cainiao-chuanqi/p/10460476.html">法律法规与标准化知识</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10464779" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464779.html">数据流图（DFD）</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10464843" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464843.html">数据库设计</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10464952" href="https://www.cnblogs.com/cainiao-chuanqi/p/10464952.html">UML建模</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10469308" href="https://www.cnblogs.com/cainiao-chuanqi/p/10469308.html">面向对象设计</a></strong></li>
</ul>
<ul>
<li><strong>软考自查：<a id="post_title_link_10469692" href="https://www.cnblogs.com/cainiao-chuanqi/p/10469692.html">数据结构及算法应用</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 style="text-align: center;">python学习</h2>
<ul>
<li><strong><a href="https://www.cnblogs.com/cainiao-chuanqi/p/9406421.html" target="_blank">python第一阶段总结（1）</a></strong></li>
<li><strong><a href="https://www.cnblogs.com/cainiao-chuanqi/p/9407219.html" target="_blank">python第一阶段总结（2）</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 style="text-align: center;">&nbsp;Java学习</h2>
<h3>第一阶段</h3>
<h4><strong>语法基础</strong></h4>
<ul>
<li><strong><a id="post_title_link_11041949" href="https://www.cnblogs.com/cainiao-chuanqi/p/11041949.html">Java学习：常量和变量 的定义和注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11045318" href="https://www.cnblogs.com/cainiao-chuanqi/p/11045318.html">Java学习：数据类型转换注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11046487" href="https://www.cnblogs.com/cainiao-chuanqi/p/11046487.html">Java学习：运算符的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11051843" href="https://www.cnblogs.com/cainiao-chuanqi/p/11051843.html">Java学习：switch语句使用的注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11052390" href="https://www.cnblogs.com/cainiao-chuanqi/p/11052390.html">java学习：循环结构的使用规则和注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11232732" href="https://www.cnblogs.com/cainiao-chuanqi/p/11232732.html">Java学习：构造方法</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11060933" href="https://www.cnblogs.com/cainiao-chuanqi/p/11060933.html">Java学习：方法的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11061116" href="https://www.cnblogs.com/cainiao-chuanqi/p/11061116.html">Java学习：方法重载的使用规则</a>&nbsp;</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11066350" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066350.html">Java学习：数组的使用和注意事项</a>&nbsp;</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223262" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223262.html">Java学习：Debug调试程序</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11066356" href="https://www.cnblogs.com/cainiao-chuanqi/p/11066356.html">Java的内存需要划分成为5个部分</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11073993" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073993.html">局部变量和成员变量的区别</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11073989" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073989.html">一个标准的类通常要拥有下面四个组成部分</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210377" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210377.html">基本类型与字符串类型之间的相互转换</a></strong></li>
</ul>
<h4><strong>面向对象</strong></h4>
<ul>
<li><strong><a id="post_title_link_11073986" href="https://www.cnblogs.com/cainiao-chuanqi/p/11073986.html">Java学习： 面向对象的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11232748" href="https://www.cnblogs.com/cainiao-chuanqi/p/11232748.html">Java学习：面向对象三大特征：封装、继承、多态之封装性</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11110165" href="https://www.cnblogs.com/cainiao-chuanqi/p/11110165.html">Java学习：面向对象三大特征：封装、继承、多态之继承性</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11110199" href="https://www.cnblogs.com/cainiao-chuanqi/p/11110199.html">Java学习：抽象方法和抽象类的使用</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11115251" href="https://www.cnblogs.com/cainiao-chuanqi/p/11115251.html">Java学习：接口（interface）的使用于注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11115399" href="https://www.cnblogs.com/cainiao-chuanqi/p/11115399.html">Java学习：面向对象三大特征：封装、继承、多态之多态性</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11129165" href="https://www.cnblogs.com/cainiao-chuanqi/p/11129165.html">Java学习：final关键字的使用与注意事项</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11129200" href="https://www.cnblogs.com/cainiao-chuanqi/p/11129200.html">Java四种权限修饰符 在创建类中的使用</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11129279" href="https://www.cnblogs.com/cainiao-chuanqi/p/11129279.html">Java学习：内部类的概念于分类</a></strong></li>
</ul>
<h3><strong>第二阶段</strong></h3>
<h4><strong>常用API&nbsp;</strong></h4>
<ul>
<li><strong><a id="post_title_link_11090273" href="https://www.cnblogs.com/cainiao-chuanqi/p/11090273.html">常用Java API之Scanner：功能与使用方法</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11097312" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097312.html">Java中的匿名对象</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11097354" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097354.html">常用Java API之Ramdom--用代码模拟猜数小游戏</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11097439" href="https://www.cnblogs.com/cainiao-chuanqi/p/11097439.html">Java学习：集合的使用与数组的区别</a>(ArraList集合)</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11104473" href="https://www.cnblogs.com/cainiao-chuanqi/p/11104473.html">Java学习：字符串概述与特点</a>(String类）</strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11106671" href="https://www.cnblogs.com/cainiao-chuanqi/p/11106671.html">Java学习：static 关键字概述</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11107411" href="https://www.cnblogs.com/cainiao-chuanqi/p/11107411.html">Java学习：数组工具类Arrays</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11107896" href="https://www.cnblogs.com/cainiao-chuanqi/p/11107896.html">Java.util.Math类--数学相关的工具类</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210316" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210316.html">Java的常用API之Object类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210341" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210341.html">Java的常用API之Date类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210359" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210359.html">Java的常用API之System类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210367" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210367.html">Java的常用API之包装类简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11210381" href="https://www.cnblogs.com/cainiao-chuanqi/p/11210381.html">Java的常用API</a></strong></li>
</ul>
<h4><strong>集合</strong></h4>
<ul>
<li><strong><a id="post_title_link_11215984" href="https://www.cnblogs.com/cainiao-chuanqi/p/11215984.html">Java学习：单列集合Collection</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216004" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216004.html">Java学习：迭代器简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216032" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216032.html">Java学习：泛型简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216046" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216046.html">斗地主案例的代码实现（单列）</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216058" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216058.html">集合单列--Colletion</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223084" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223084.html">Java学习：数据结构简介</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223151" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223151.html">Java学习：List接口</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223170" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223170.html">Java学习：Set接口与HashSet集合存储数据的结构（哈希表）</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223173" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223173.html">Java学习：可变参数</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223283" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223283.html">Java学习：双列集合Map</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223241" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223241.html">Java学习：Map接口</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223248" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223248.html">计算一个字符串中每一个字符出现的次数</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223279" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223279.html">JDK9对集合添加的优化</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223281" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223281.html">斗地主综合案例：有序版本（双列）</a></strong></li>
</ul>
<h3><strong>第三阶段</strong></h3>
<h4><strong>异常与多线程</strong></h4>
<ul>
<li><strong><a id="post_title_link_11279691" href="https://www.cnblogs.com/cainiao-chuanqi/p/11279691.html">Java学习：异常的概念</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11285611" href="https://www.cnblogs.com/cainiao-chuanqi/p/11285611.html">多线程简介（全）</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_11285428" href="https://www.cnblogs.com/cainiao-chuanqi/p/11285428.html">Java学习：线程实现方式</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11285626" href="https://www.cnblogs.com/cainiao-chuanqi/p/11285626.html">Java学习：线程的安全问题</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11285751" href="https://www.cnblogs.com/cainiao-chuanqi/p/11285751.html">多线程面试题(含答案)</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11299824" href="https://www.cnblogs.com/cainiao-chuanqi/p/11299824.html">Java学习：等待唤醒机制</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11299892" href="https://www.cnblogs.com/cainiao-chuanqi/p/11299892.html">Java学习：线程间通信</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11299988" href="https://www.cnblogs.com/cainiao-chuanqi/p/11299988.html">Java学习：线程池</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11300138" href="https://www.cnblogs.com/cainiao-chuanqi/p/11300138.html">Java学习：Lambda表达式</a></strong></li>
</ul>
<h4>&nbsp;File类与IO流</h4>
<ul>
<li><strong><a id="post_title_link_11326624" href="https://www.cnblogs.com/cainiao-chuanqi/p/11326624.html">Java学习：File类</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11320972" href="https://www.cnblogs.com/cainiao-chuanqi/p/11320972.html">Java学习：递归</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11326729" href="https://www.cnblogs.com/cainiao-chuanqi/p/11326729.html">Java学习：File类中的过滤器接口</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11326793" href="https://www.cnblogs.com/cainiao-chuanqi/p/11326793.html">Java中的Filter过滤器</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11328209" href="https://www.cnblogs.com/cainiao-chuanqi/p/11328209.html">Java学习：Properties类</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11327934" href="https://www.cnblogs.com/cainiao-chuanqi/p/11327934.html">Java学习：IO流</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11328070" href="https://www.cnblogs.com/cainiao-chuanqi/p/11328070.html">JavaIO学习：字符流</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11328140" href="https://www.cnblogs.com/cainiao-chuanqi/p/11328140.html">JavaIO学习：字节流</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11328278" href="https://www.cnblogs.com/cainiao-chuanqi/p/11328278.html">JavaIO学习：缓冲流</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11328383" href="https://www.cnblogs.com/cainiao-chuanqi/p/11328383.html">JavaIO学习：打印流</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11328422" href="https://www.cnblogs.com/cainiao-chuanqi/p/11328422.html">JavaIO学习：转换流</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11328503" href="https://www.cnblogs.com/cainiao-chuanqi/p/11328503.html">JavaIO学习：序列化流</a></strong></li>
</ul>
<hr />
<h2 style="text-align: center;"><strong>JDBC</strong></h2>
<ul>
<li><strong><a id="post_title_link_11131043" href="https://www.cnblogs.com/cainiao-chuanqi/p/11131043.html">Java学习：JDBC快速入门</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11146258" href="https://www.cnblogs.com/cainiao-chuanqi/p/11146258.html">Java学习：JDBC各类详解</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11146348" href="https://www.cnblogs.com/cainiao-chuanqi/p/11146348.html">Java学习：数据库连接池技术</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 style="text-align: center;">&nbsp;<strong>数据库</strong></h2>
<ul>
<li><strong><a id="post_title_link_11191647" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191647.html">数据库知识总结（全）</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_11190999" href="https://www.cnblogs.com/cainiao-chuanqi/p/11190999.html">数据库知识总结</a></strong></li>
</ul>
<ul>
<li><strong>&nbsp;<a id="post_title_link_11191112" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191112.html">什么是SQL ？</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191227" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191227.html">SQL分类之DDL：操作数据库表</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191360" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191360.html">SQL分类之DML：增删改表中的数据</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191387" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191387.html">SQL分类之DQL：查询表中的记录</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191639" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191639.html">SQL分类之DCL:管理用户、授权</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191539" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191539.html">数据库的查询语句的约束和范式</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11191600" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191600.html">数据库的多表查询和事务</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 style="text-align: center;">&nbsp;大数据</h2>
<ul>
<li><strong><a id="post_title_link_9463342" href="https://www.cnblogs.com/cainiao-chuanqi/p/9463342.html">大数据的行业与技术趋势</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_10581017" href="https://www.cnblogs.com/cainiao-chuanqi/p/10581017.html">大数据学习路线</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11251795" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251795.html">大数据简介</a></strong></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11006061" href="https://www.cnblogs.com/cainiao-chuanqi/p/11006061.html">FusionInsight大数据开发学习总结</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11006088" href="https://www.cnblogs.com/cainiao-chuanqi/p/11006088.html">FusionInsight大数据开发---HDFS应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11010227" href="https://www.cnblogs.com/cainiao-chuanqi/p/11010227.html">FusionInsight大数据开发--HBase应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11251503" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251503.html">FusionInsight大数据开发---MapReduce应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11251556" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251556.html">FusionInsight大数据开发---Hive应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11251594" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251594.html">FusionInsight大数据开发---sorl应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11251625" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251625.html">FusionInsight大数据开发---Kafka应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11251666" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251666.html">FusionInsight大数据开发---Spark应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11251740" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251740.html">FusionInsight大数据开发---SparkStreaming概述</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11251787" href="https://www.cnblogs.com/cainiao-chuanqi/p/11251787.html">FusionInsight大数据开发---Redis应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11259328" href="https://www.cnblogs.com/cainiao-chuanqi/p/11259328.html">FusionInsight大数据开发---Streaming应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11259342" href="https://www.cnblogs.com/cainiao-chuanqi/p/11259342.html">FusionInsight大数据开发---Flume应用开发</a></strong></span></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11259348" href="https://www.cnblogs.com/cainiao-chuanqi/p/11259348.html">FusionInsight大数据开发---Oozie应用开发</a></strong></span></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 style="text-align: center;">&nbsp;<strong>&nbsp;linux&nbsp;</strong></h2>
<ul>
<li><strong><a id="post_title_link_11268522" href="https://www.cnblogs.com/cainiao-chuanqi/p/11268522.html">Linux 常用命令</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11268497" href="https://www.cnblogs.com/cainiao-chuanqi/p/11268497.html">Linux命令注释&mdash;HDFS运维</a></strong></li>
</ul>
<ul>
<li><span style="text-decoration: line-through;"><strong><a id="post_title_link_11268557" href="https://www.cnblogs.com/cainiao-chuanqi/p/11268557.html">HDFS 其他命令---fsck</a></strong></span></li>
</ul>
<hr />
<h2 style="text-align: center;">&nbsp;其他</h2>
<ul>
<li><strong><a id="post_title_link_11041924" href="https://www.cnblogs.com/cainiao-chuanqi/p/11041924.html">Windows中DOS简单命令的总结</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11051813" href="https://www.cnblogs.com/cainiao-chuanqi/p/11051813.html">JDK9版本以上Java独有的一个轻量级小工具，你知道吗？jshell</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11287052" href="https://www.cnblogs.com/cainiao-chuanqi/p/11287052.html">我的随笔---博客园标题与点击效果自定义</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11287963" href="https://www.cnblogs.com/cainiao-chuanqi/p/11287963.html">我的随笔---博客园自定义样式</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11301471" href="https://www.cnblogs.com/cainiao-chuanqi/p/11301471.html">关于颜色的十六进制对照表</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<h2 style="text-align: center;">&nbsp;项目</h2>
<ul>
<li><strong><a id="post_title_link_11110442" href="https://www.cnblogs.com/cainiao-chuanqi/p/11110442.html">案例分析发红包</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11216046" href="https://www.cnblogs.com/cainiao-chuanqi/p/11216046.html">斗地主案例的代码实现（单列）</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223281" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223281.html">斗地主综合案例：有序版本（双列）</a></strong></li>
</ul>
<ul>
<li><strong><a id="post_title_link_11223248" href="https://www.cnblogs.com/cainiao-chuanqi/p/11223248.html">计算一个字符串中每一个字符出现的次数</a></strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><strong>更新中...</strong></span></p>]]></description></item><item><title>FusionInsight大数据开发---HDFS应用开发（2）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/11/11006088.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 11 Jun 2019 13:12:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/11/11006088.html</guid><description><![CDATA[<h1 style="text-align: center;">HDFS应用开发</h1>
<p><strong>HDFS(Dadoop Distributed File System)</strong></p>
<h3>HDFS概述</h3>
<ul>
<li>高容错性</li>
<li>高吞吐量</li>
<li>大文件存储</li>
</ul>
<h3>HDFS架构包含三部分</h3>
<ol>
<li>Name Node</li>
<li>DataNode</li>
<li>Client</li>
</ol>
<h3>HDFS数据写入流程</h3>
<p>&nbsp;</p>
<h3>HDFS应用开发方式</h3>
<ul>
<li><strong>HDFS Client</strong></li>
</ul>
<p>Java/shell/Web UI</p>
<ul>
<li><strong>Kerbors控制</strong></li>
</ul>
<h3>HDFSJava应用开发</h3>
<p><strong>下载客户端/获取样例工程/生产样例工程/导入eclipse/编码</strong></p>
<h3>Java开发流程</h3>
<ul>
<li>初始化</li>
<li>目录操作</li>
<li>文件读取</li>
<li>文件写入/追加（</li>
</ul>
<ol>
<li>初始化FSDataOutputstream对象</li>
<li>使用FSDataOutputStream对象初始化BufferedOutputStream.</li>
<li>使用BufferedOutputStream.write写入HDFS数据。</li>
<li>使用BufferedOutputStream.flush和FSDataOutputstream.hflush()将数据刷新到HDFS。</li>
<li>关闭数据流。)</li>
</ol>
<h3>应用开发规范</h3>
<p><strong>规范1：Java开发时，申请资源需要及时释放。</strong><br /><strong>规范2：HDFS不适用于存储大量小文件。</strong><br /><strong>规范3：HDFS中数据备份3份即可。</strong><br /><strong>规范4：如果有多线程进行login的操作，当第一次登陆成功后，所有线程再次登陆时应该使用relogin的方式。</strong></p>
<p>&nbsp;</p>
<p><a href="https://www.cnblogs.com/cainiao-chuanqi/p/11009077.html" target="_blank">更新中......</a></p>
<p>&nbsp;</p>
<h2>HDFS</h2>
<p>在Hadoop的底层有个非常重要的部分，我们一般称之为&ldquo;核心&rdquo;&mdash;&mdash;分布式文件存储系统，即HDFS。我之前说过，单个服务器的内存和磁盘空间是有上限的，不可能无限支持线性增加。面对海量的大数据，单个服务器是存不下的，这辈子都不可能存的下的。面对传统存储的技术瓶颈，&ldquo;分布式&rdquo;的概念就很好的解决了问题。</p>
<p>&nbsp;</p>
<h3>一、什么是HDFS</h3>
<p>　GFS的设计理念有两个很重要的假设：只存储大文件、不能修改（update）只能追加（append）。他有几个显著的特性：</p>
<ul>
<li>高容错性</li>
<li>高吞吐量</li>
<li>支持大文件（TB、PB）的存储</li>
</ul>
<h3>二、HDFS的重要角色和概念</h3>
<p>　　1、NameNode（NN节点）</p>
<ul>
<li>HDFS的管理者。负责监控DataNode，记录文件的存储信息，协调客户端的读写请求，等。相当于目录。</li>
</ul>
<p>　　2、DataNode（DN节点）</p>
<ul>
<li>HDFS的执行者。负责文件的存储，以块为存储单位，数据分散在不同DN节点，支持一次写入多次读取，等。相当于正文。</li>
</ul>
<p>　　3、SecondaryNameNode</p>
<ul>
<li>NameNode的冷备份,同步NameNode的日志(EditLog)和镜像文件(FsImage),并将日志和镜像合并成新的镜像文件回传给NameNode</li>
</ul>
<p>　　4、Editlog</p>
<ul>
<li>日志文件,记录每次元数据的变化</li>
</ul>
<p>　　5、FsImage</p>
<ul>
<li>镜像文件,内存中元数据在本地磁盘的映射</li>
</ul>
<p>　　PS:NameNode的内存中是FsImage+EditLog</p>
<p>　　6、热备份</p>
<ul>
<li>NameNode停止工作后,热备份NameNode马上接替NameNode的工作</li>
</ul>
<p>　　7、冷备份</p>
<p>　　同SecondaryNmaeNode</p>
<p>　　</p>
<h3>三、HDFS的读写流程</h3>
<p>这个我们可以类比图书馆，写就是新书入馆，读就是客户借书。大家应该听过一个问题：把大象装进冰箱分几步？我们就以3大步来看这个问题。</p>
<p>先看看写流程。有一批新书要入馆，我们要走哪些流程？</p>
<ul>
<li>员工先找到馆长，告诉他你要的货&hellip;&hellip;你要的书我带来了：打开了冰箱门。</li>
<li>馆长看到书来了先是喜上眉梢，紧接着眉头一皱，发现事情并不简单：大象怎么塞进冰箱？</li>
<li>馆长终于想起来&ldquo;目录&rdquo;这么个玩意，费了老半天劲指挥员工把书存好，然后把目录放好：关上冰箱门。</li>
</ul>
<p>根据图书馆的例子，运用到HDFS上：</p>
<p>Round1 写流程</p>
<p><img src="https://img2018.cnblogs.com/blog/1747630/201908/1747630-20190803221952843-1690012592.png" alt="" width="530" height="320" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>A：打开冰箱门</p>
<p>　　1、用户在客户端（Client）发起写命令，存入一个文件</p>
<p>　　　　①用户需先将文件分块，一般块大小为128MB</p>
<p>　　　　②还需要制定文件的副本参数,一般为3</p>
<p>　　2、客户端向NN节点发起写请求</p>
<p>　　　　①请求信息中包含但不限于文件大小(块)、副本参数</p>
<p>　　3、NN节点收到请求，给Client发送一个回复信息</p>
<p>　　　　　①NN从自己管理的(DN)节点信息中找出适合的3个(与副本参数一致)DN节点</p>
<p>　　　　　②将选中的DN节点地址和路径参数的等信息发送给Client</p>
<p>B：把大象塞进去</p>
<p>　　1、Client收到回复信息，开始发送第一个数据块(Block)</p>
<p>　　　　　①Client通过NN的回复信息找到第一个DN节点，开始发送数据块，以及备份副本DN地址列表</p>
<p>　　　　　②第一个DN开始按数据包分批接受Block存盘，每存盘一个数据包同时将相同的数据包再转发给的二个DN节点，以此类推直到最后一个DN节点存盘后不在转发</p>
<p>　　　　　③所有DN都接受到了完整的Block后，向NN节点发送确认信息，第一个DN节点还要向Client发送确认信息</p>
<p>　　2、Client收到第一个Block存盘完毕的信息后开始执行第二个Block的操作，重新向NN节点发送请求</p>
<p>C：关闭冰箱门</p>
<p>　　1、Client收到DN节点最后一个Block存盘成功的确认信息后，向NN节点发送结束信息</p>
<p>　　2、NN节点收到Client发来的结束信息，关闭目录文件，此时存储文件的元数据信息已经记录在了目录文件中</p>
<p>小结：在写流程中，Client负责发起命令，将文件分块和设置副本参数；NN节点负责协调Client和DN节点的交互，包括为每个文件的多个数据块分配存储地址及记录元数据；DN负责干活，存储从Client发来的数据，同时多副本机制保障了数据的高可靠性。</p>
<p>&nbsp;</p>
<p>　　Round2 读流程</p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1747630/201908/1747630-20190803215448883-604684801.png" alt="" width="530" height="320" /></p>
<p>读流程相较于写流程基本一致，且实现更加简单，我就简单描述一下：</p>
<ul>
<li>Client向NN节点发出读请求，包含文件名等信息</li>
<li>NN收到请求，根据文件名查找该文件所对应的所有块信息</li>
<li>NN根据块信息找到相对应的DN节点，将所有DN节点的位置及路径开销回复给Client</li>
<li>Client根据收到的DN节点信息，选取每个块所在路径开销最小的DN节点执行读取操作。</li>
</ul>
<p>&nbsp;</p>
<h3>四、HDFS的高可靠性</h3>
<p>1、NN的高可靠性</p>
<p>　　NN节点作为HDFS的管理者，里面存储了所有文件数据的元数据和节点的状态信息。一旦NN节点宕机那么所有文件的元数据将会丢失，海量的文件数据被存放在不同的DN节点上，元数据的丢失意味着丢失了查找数据的能力。为防止由于NN节点的宕机而导致的元数据丢失，我们采用NN节点的冗余备份机制。NN节点的备份分为冷备份和热备份，在第二部分也将这两个备份的概念简单说了一下，现在详细介绍一下。</p>
<p>　　　　<img src="https://img2018.cnblogs.com/blog/1747630/201908/1747630-20190803224942778-1638735682.png" alt="" width="530" height="320" /></p>
<p>　　上一篇随笔简单讲到Hadoop分为三个层次，中间层负责资源协调。ZooKeeper就是协调机制，在HDFS中主要就是协调选举主备NameNode节点。每个NN节点都会通过&ldquo;心跳&rdquo;与ZooKeeper保持联系，报告自己的状态信息。ZooKeeper通过这些状态信息选举出主NN节点作为整个HDFS的管理节点，其他作为备份。备份NN一般不工作，但数据会与主NN节点同步更新。当主NN节点宕机后，其与ZooKeeper的联系就会中断，ZooKeeper接受不到主NN发来的心跳信息就默认主NN节点损坏，会在备选NN节点中重新选举主NN节点。虽然备NN节点不工作，但它里面的元数据信息和DN节点状态信息跟主NN节点是同步更新的，所以一旦备NN被选为主NN节点，会立刻接替主NN节点的工作。当然，这是热备份。</p>
<p>冷备份，即SecondaryNameNode。它与主NN节点之间有个&ldquo;元数据持久化&rdquo;机制</p>
<p><img src="https://img2018.cnblogs.com/blog/1747630/201908/1747630-20190803232420778-401318747.png" alt="" width="530" height="320" /></p>
<p>①当有对元数据执行操作时，NN节点会生成新的对应日志文件(Editlog.new)</p>
<p>②NN节点内存里存放的是日志文件(Editlog)和元数据镜像文件(Fsimage)，SecondaryNN通过NN节点同步获取得到</p>
<p>③SecondaryNN中将二者合并成新的镜像文件Fsimage.ckpt文件</p>
<p>④SecondaryNN将新生成的镜像文件上传到主节点上</p>
<p>⑤Fsimage.ckpt在主节点上回滚成Fsimage文件，其实就是将原来的镜像文件更新NN</p>
<p>⑥此时在之前过程中新的日志文件(Editlog.new)已经变成Editlog，不在是新日志，与更新后的镜像文件重新同步到SecondaryNN上，重复以上操作</p>
<p>NN和SecondaryNN的工作目录存储结构完全相同，所以，当NN故障退出需要重新恢复时，可以从SecondaryNN的工作目录中将Fsimage拷贝到NN的工作目录，以恢复NN中的元数据。</p>
<p>2、DN的高可靠性</p>
<p>　　DN节点作为实际存储数据的执行者，其高可靠性主要就是数据的副本机制，即数据冗余存储。当数据写入HDFS时，Client有个&rdquo;副本参数&ldquo;设置，这就是我们对数据的备份。而且我们在备份时选择的时不同的DN节点来进行存储，一次来保证在一台DN损坏的情况下，依靠其他DN节点依然可以恢复数据。</p>
<p>　　DN节点受NN节点的监控，它们之间也有&rdquo;心跳&ldquo;联系的机制。DN节点定时向NN节点发送自己的状态信息，NN节点通过这些信息监控DN节点。当NN节点在一段时间内没有接受到某台DN节点的心跳信息，则认为该DN节点损坏。此时NN节点会根据自己的元数据信息确定其所存放数据的副本的DN节点，重新找一带DN节点，根据副本数据进行备份。同时修改元数据信息和DN节点状态信息。这样，通过NN节点的调控备份，始终使数据保持一定数量的副本，保证了数据的完整性。</p>]]></description></item><item><title>FusionInsight大数据开发学习总结（1）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/11/11006061.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 11 Jun 2019 13:08:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/11/11006061.html</guid><description><![CDATA[<h1 style="text-align: center;">FusionInsight大数据开发</h1>
<p><strong>FusionInsight HD是一个大数据全栈商用平台，支持各种通用大数据应用场景。</strong></p>
<p><strong>技能需求</strong></p>
<ul>
<li>扎实的编程基础</li>
<li>Java/Scala/python/SQL/shell常见命令</li>
<li>掌握FusionInsight</li>
<li>熟悉业务开发</li>
</ul>
<p><strong>大数据应用开发流程</strong></p>
<ul>
<li>业务分析和方案设计</li>
<li>应用开发</li>
<li>应用调试</li>
<li>应用部署</li>
</ul>
<p><strong>应用开发关键点</strong></p>
<ul>
<li>账号</li>
<li>安全认证</li>
<li>场景约束</li>
</ul>
<p><strong>应用开发指南--调试</strong></p>
<ul>
<li>常规手段</li>
<li>协助资料</li>
<li>保障团队</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><strong>认证是应用开发的关键点，要根据业务需求，申请合适账号，完成安全认证。</strong></li>
<li><strong>华为FusionInsight易集成开发，提供了包括应用开发指南，样例代码和支持团队等各类协助。</strong></li>
</ol>
<p><a href="https://www.cnblogs.com/cainiao-chuanqi/p/11009077.html" target="_blank"><strong>更新中......</strong></a></p>]]></description></item><item><title>GoF的23种设计模式之行为型模式的特点和分类(2)</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/05/10979389.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 05 Jun 2019 06:27:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/05/10979389.html</guid><description><![CDATA[<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p><strong>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。</strong>由于组合关系或聚合关系比继承关系耦合度低，满足<strong>&ldquo;合成复用原则&rdquo;</strong>，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式，下面我将详细介绍它们的特点、结构与应用。</p>
<p>&nbsp;</p>
<h2 style="text-align: center;">观察者模式</h2>
<p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。<br />在软件世界也是这样，例如，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。</p>
<h3>模式的定义与特点</h3>
<p>
观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<p>观察者模式是一种对象行为型模式，其主要<strong>优点</strong>如下。</p>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>


</ol>
<p>它的主要<strong>缺点</strong>如下。</p>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>



</ol>
<h3>模式的结构与实现</h3>
<p>
实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。</p>
<h4>1. 模式的结构</h4>
<p>
观察者模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete&nbsp;&nbsp;&nbsp; Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>


</ol>
<p>观察者模式的结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161A6221S.gif" alt="观察者模式的结构图" /><br />图1 观察者模式的结构图</div>
<h3>模式的应用场景</h3>
<p style="text-align: left;">通过前面的分析与应用实例可知观察者模式适合以下几种情形。</p>
<ol>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>


</ol>
<h3>模式的扩展</h3>
<p style="text-align: left;">在 Java中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p>
<h4>1. Observable类</h4>
<p style="text-align: left;">
Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>
<ol>
<li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。</li>
<li>void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update。方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。</li>
<li>void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。</li>



</ol>
<h4>2. Observer 接口</h4>
<p style="text-align: left;">
Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。</p>
<p style="text-align: left;">&nbsp;</p>
<h2 style="text-align: center;">中介者模式</h2>
<p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是&ldquo;网状结构&rdquo;，它要求每个对象都必须知道它需要交互的对象。<br />如果把这种&ldquo;网状结构&rdquo;改为&ldquo;星形结构&rdquo;的话，将大大降低它们之间的&ldquo;耦合性&rdquo;，这时只要找一个&ldquo;中介者&rdquo;就可以了。<br />在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的&ldquo;中介者&rdquo;是 QQ 服务器。所有这些，都可以采用&ldquo;中介者模式&rdquo;来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。</p>
<h3>模式的定义与特点</h3>
<p>
中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。<br /><br />中介者模式是一种对象行为型模式，其主要<strong>优点</strong>如下。</p>
<ol>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>


</ol>
<p>其主要<strong>缺点</strong>是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<h3>模式的结构与实现</h3>
<p>
中介者模式实现的关键是找出&ldquo;中介者&rdquo;，下面对它的结构和实现进行分析。</p>
<h4>1. 模式的结构</h4>
<p>
中介者模式包含以下主要角色。</p>
<ol>
<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>


</ol>
<p>中介者模式的结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161I532V0.gif" alt="中介者模式的结构图" /><br />图1 中介者模式的结构图</div>
<h3>模式的应用场景</h3>
<p style="text-align: left;">前面分析了中介者模式的结构与特点，下面分析其以下应用场景。</p>
<ul>
<li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>


</ul>
<h3>模式的扩展</h3>
<p style="text-align: left;">在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单。</p>
<ol>
<li>不定义中介者接口，把具体中介者对象实现成为单例。</li>
<li>同事对象不持有中介者，而是在需要的时f矣直接获取中介者对象并调用。</li>


</ol>
<p>图2所示是简化中介者模式的结构图。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161IA5242.gif" alt="简化中介者模式的结构图" /><br />图2 简化中介者模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">迭代器模式</h2>
<p>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如&ldquo;数据结构&rdquo;中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了<strong>&rdquo;开闭原则&ldquo;。</strong></p>
<p>既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个<strong>缺点</strong>：</p>
<ol>
<li>暴露了聚合类的内部表示，使其数据不安全；</li>
<li>增加了客户的负担。</li>


</ol>
<p>&ldquo;迭代器模式&rdquo;能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足&ldquo;单一职责原则&rdquo;和&ldquo;开闭原则&rdquo;，如 Java中的 Collection、List、Set、Map 等都包含了迭代器。</p>
<h3>模式的定义与特点</h3>
<p>
迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要<strong>优点</strong>如下。</p>
<ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>遍历任务交由迭代器完成，这简化了聚合类。</li>
<li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li>
<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
<li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>

</ol>
<p>其主要<strong>缺点</strong>是：增加了类的个数，这在一定程度上增加了系统的复杂性。</p>
<h3>模式的结构与实现</h3>
<p>
迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。</p>
<h4>1. 模式的结构</h4>
<p>
迭代器模式主要包含以下角色。</p>
<ol>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>


</ol>
<p>其结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161PU9528.gif" alt="迭代器模式的结构图" /><br />图1 迭代器模式的结构图</div>
<h3>模式的应用场景</h3>
<p>前面介绍了关于迭代器模式的结构与特点，下面介绍其应用场景，迭代器模式通常在以下几种情况使用。</p>
<ol>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>


</ol>
<p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p>
<h3>模式的扩展</h3>
<p>
迭代器模式常常与组合模式结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问，其结构图如图 2 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161Q152626.gif" alt="组合迭代器模式的结构图" /><br />图2 组合迭代器模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">访问者模式</h2>
<p>在现实生活中，有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。</p>
<p>这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在&ldquo;购物车&rdquo;中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。</p>
<p>这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用&ldquo;访问者模式&rdquo;来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。</p>
<h3>模式的定义与特点</h3>
<p>
访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<p>访问者（Visitor）模式是一种对象行为型模式，其主要<strong>优点</strong>如下。</p>
<ol>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>


</ol>
<p>访问者（Visitor）模式的主要<strong>缺点</strong>如下。</p>
<ol>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了&ldquo;开闭原则&rdquo;。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>



</ol>
<h3>模式的结构与实现</h3>
<p>
访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类，其基本结构与实现方法如下。</p>
<h4>1. 模式的结构</h4>
<p>
访问者模式包含以下主要角色。</p>
<ol>
<li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li>
<li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li>
<li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li>
<li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li>


</ol>
<p>其结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><a href="http://c.biancheng.net/uploads/allimg/181119/3-1Q119101429D6.gif"><img src="http://c.biancheng.net/uploads/allimg/181119/3-1Q11910135Y25.gif" alt="访问者（Visitor）模式的结构图" /></a><br />图1 访问者（Visitor）模式的结构图</div>
<h3>模式的应用场景</h3>
<p>通常在以下情况可以考虑使用访问者（Visitor）模式。</p>
<ol>
<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li>
<li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li>


</ol>
<h3>模式的扩展</h3>
<p>访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。</p>
<p>(1)与<strong>&ldquo;迭代器模式&rdquo;</strong>联用。因为访问者模式中的&ldquo;对象结构&rdquo;是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。</p>
<p>(2)访问者（Visitor）模式同&ldquo;<strong>组合模式&rdquo;</strong>联用。因为访问者（Visitor）模式中的&ldquo;元素对象&rdquo;可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式。</p>
<p>其结构图如图2 所示。</p>
<p>&nbsp;</p>
<p style="text-align: center;">&nbsp;<img src="http://c.biancheng.net/uploads/allimg/181119/3-1Q11910210Jc.gif" alt="包含组合模式的访问者模式的结构图" /><br />图2 包含组合模式的访问者模式的结构图</p>
<p style="text-align: center;">&nbsp;</p>
<h2 style="text-align: center;">备忘录模式</h2>
<p>其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</p>
<h3>模式的定义与特点</h3>
<p>
备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。<br /><br />备忘录模式是一种对象行为型模式，其主要<strong>优点</strong>如下。</p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>


</ul>
<p>其主要<strong>缺点</strong>是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<h3>模式的结构与实现</h3>
<p>
备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类，现在我们来学习其结构与实现。</p>
<h4>1. 模式的结构</h4>
<p>
备忘录模式的主要角色如下。</p>
<ol>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>

</ol>
<p>备忘录模式的结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181119/3-1Q119130413927.gif" alt="备忘录模式的结构图" /><br />图1 备忘录模式的结构图</div>
<p style="text-align: center;">&nbsp;</p>
<h3>模式的应用场景</h3>
<p>前面学习了备忘录模式的定义与特点、结构与实现，现在来看该模式的以下应用场景。</p>
<ol>
<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li>
<li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>


</ol>
<h3>模式的扩展</h3>
<p>在前面介绍的备忘录模式中，有单状态备份的例子，也有多状态备份的例子。下面介绍备忘录模式如何同<strong>原型模式</strong>混合使用。在备忘录模式中，通过定义&ldquo;备忘录&rdquo;来备份&ldquo;发起人&rdquo;的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类。</p>
<p>其结构图如图 2 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181119/3-1Q119130HW56.gif" alt="带原型的备忘录模式的结构图" /><br />图2带原型的备忘录模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">解释器模式</h2>
<p>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用&ldquo;编译原理&rdquo;中的解释器模式来实现了。</p>
<h3>模式的定义与特点</h3>
<p>
解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p>
<p>这里提到的文法和句子的概念同编译原理中的描述相同，&ldquo;文法&rdquo;指语言的语法规则，而&ldquo;句子&rdquo;是语言集中的元素。例如，汉语中的句子有很多，&ldquo;我是中国人&rdquo;是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。</p>
<p>解释器模式是一种类行为型模式，其主要<strong>优点</strong>如下。</p>
<ol>
<li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li>
<li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>


</ol>
<p>解释器模式的主要<strong>缺点</strong>如下。</p>
<ol>
<li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>



</ol>
<h3>模式的结构与实现</h3>
<p>
解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的&ldquo;文法、句子、语法树&rdquo;等相关概念。</p>
<h4>1) 文法</h4>
<p>
文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是&ldquo;相互吸引、感情专一、任何一方都没有恋爱经历&rdquo;，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的&ldquo;句子&rdquo;的文法如下。</p>
<div class="cnblogs_code">
<pre>〈句子〉=<span style="color: #000000;">〈主语〉|〈谓语〉|〈宾语〉
〈主语〉</span>=〈代词〉|<span style="color: #000000;">〈名词〉
〈谓语〉</span>=<span style="color: #000000;">〈动词〉
〈宾语〉</span>=〈代词〉|<span style="color: #000000;">〈名词〉
〈代词〉= 你</span>|我|<span style="color: #000000;">他
〈名词〉= 大学生|英语
〈动词〉</span>= 是|学习<br /><strong>注：这里的符号&ldquo;=&rdquo;表示&ldquo;定义为&rdquo;的意思，用&ldquo;〈&rdquo;和&ldquo;〉&rdquo;括住的是非终结符，没有括住的是终结符。</strong></pre>
</div>
<h4>2) 句子</h4>
<p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由&ldquo;文法&rdquo;推导出。例如，上述文法可以推出&ldquo;我是大学生&rdquo;，所以它是句子。</p>
<h4>3) 语法树</h4>
<p> 语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。图 1 所示是&ldquo;我是大学生&rdquo;的语法树。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181119/3-1Q119150550114.gif" alt="句子&ldquo;我是大学生&rdquo;的语法树" /><br />图1 句子&ldquo;我是大学生&rdquo;的语法树</div>
<p>
<br />有了以上基础知识，现在来介绍解释器模式的结构就简单了。解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。</p>
<h4>1. 模式的结构</h4>
<p>
解释器模式包含以下主要角色。</p>
<ol>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal&nbsp;&nbsp;&nbsp; Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>


</ol>
<p>解释器模式的结构图如图 2 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181119/3-1Q119150626422.gif" alt="解释器模式的结构图" /><br />图2 解释器模式的结构图</div>
<h3>模式的应用场景</h3>
<p>前面介绍了解释器模式的结构与特点，下面分析它的应用场景。</p>
<ol>
<li>当语言的文法较为简单，且执行效率不是关键问题时。</li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li>


</ol>
<p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在&nbsp;<a href="http://c.biancheng.net/java/" target="_blank">Java</a>&nbsp;中可以用 Expression4J 或 Jep 等来设计。</p>
<h3>模式的扩展</h3>
<p>
在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。</p>
<p>现在以 Jep 为例来介绍该工具包的使用方法。Jep 是 Java expression parser 的简称，即 Java 表达式分析器，它是一个用来转换和计算数学表达式的 Java 库。通过这个程序库，用户可以以字符串的形式输入一个任意的公式，然后快速地计算出其结果。而且 Jep 支持用户自定义变量、常量和函数，它包括许多常用的数学函数和常量。</p>
<p>&nbsp;</p>]]></description></item><item><title>GoF的23种设计模式之行为型模式的特点和分类(1)</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/05/10979160.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 05 Jun 2019 05:52:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/05/10979160.html</guid><description><![CDATA[<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p><strong>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。</strong>由于组合关系或聚合关系比继承关系耦合度低，满足<strong>&ldquo;合成复用原则&rdquo;</strong>，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式，下面我将详细介绍它们的特点、结构与应用。</p>
<h2 style="text-align: center;">模板方法模式</h2>
<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<h3>模式的定义与特点</h3>
<p>模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<p>该模式的主要<strong>优点</strong>如下。</p>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ol>
<p>该模式的主要<strong>缺点</strong>如下。</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
<h3>模式的结构与实现</h3>
<p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及&ldquo;不用调用我，让我来调用你&rdquo;的反向控制技术。现在来介绍它们的基本结构。</p>
<h4>1. 模式的结构</h4>
<p> 模板方法模式包含以下主要角色。<br /><br />(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。<br /><br /><strong>1. 模板方法</strong>：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<p><strong>2.基本方法：</strong>是整个算法中的一个步骤，包含以下几种类型。</p>
<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>








</ul>
<p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。<br /><br />模板方法模式的结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116095405308.gif" alt="模板方法模式的结构图" /><br />图1 模板方法模式的结构图</div>
<h3>模式的应用场景</h3>
<p style="text-align: left;">模板方法模式通常适用于以下场景。</p>
<ol>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>








</ol>
<h3>模式的扩展</h3>
<p style="text-align: left;">在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用&ldquo;钩子方法&rdquo;可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图如图2 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116095550123.gif" alt="含钩子方法的模板方法模式的结构图" /><br />图2 含钩子方法的模板方法模式的结构图</div>
<h2 style="text-align: center;">策略模式</h2>
<p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。<br /><br />在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。<br /><br />如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。</p>
<h3>策略模式的定义与特点</h3>
<p>
策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。<br /><br />策略模式的主要<strong>优点</strong>如下。</p>
<ol>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>









</ol>
<p><br />其主要<strong>缺点</strong>如下。</p>
<ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类。</li>









</ol>
<h3>策略模式的结构与实现</h3>
<p>
策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。</p>
<h4>1. 模式的结构</h4>
<p>
策略模式的主要角色如下。</p>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>









</ol>
<p><br />其结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116103K1205.gif" alt="策略模式的结构图" /><br />图1 策略模式的结构图</div>
<h3>策略模式的应用场景</h3>
<p style="text-align: left;">策略模式在很多地方用到，如JavaSE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。</p>
<ol>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>








</ol>
<h3>策略模式的扩展</h3>
<p style="text-align: left;">在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度，其结构图如图2所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116104010550.gif" alt="策略工厂模式的结构图" /><br />图2策略工厂模式的结构图</div>
<h2 style="text-align: center;">命令模式</h2>
<p>在软件开发系统中，常常出现&ldquo;方法的请求者&rdquo;与&ldquo;方法的实现者&rdquo;之间存在紧密的耦合关系。这不利于软件功能的扩展与维护。例如，想对行为进行&ldquo;撤销、重做、记录&rdquo;等处理都很不方便，因此&ldquo;如何将方法的请求者与方法的实现者解耦？&rdquo;变得很重要，命令模式能很好地解决这个问题。<br /><br />在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的&ldquo;功能键&rdquo;等。</p>
<h3>命令模式的定义与特点</h3>
<p>
命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<p>命令模式的主要<strong>优点</strong>如下。</p>
<ol>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足&ldquo;开闭原则&rdquo;，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>









</ol>
<p><br />其<strong>缺点</strong>是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p>
<h3>命令模式的结构与实现</h3>
<p>
可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离，其结构如下。</p>
<h4>1. 模式的结构</h4>
<p>
命令模式包含以下主要角色。</p>
<ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>
<li>具体命令角色（Concrete&nbsp;&nbsp;&nbsp; Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>








</ol>
<p>其结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q11611335E44.gif" alt="命令模式的结构图" /><br />图1 命令模式的结构图</div>
<h3>命令模式的应用场景</h3>
<p style="text-align: left;">命令模式通常适用于以下场景。</p>
<ol>
<li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li>
<li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li>
<li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li>








</ol>
<h3>命令模式的扩展</h3>
<p style="text-align: left;">在软件开发中，有时将命令模式与前面学的组合模式联合使用，这就构成了宏命令模式，也叫组合命令模式。宏命令包含了一组命令，它充当了具体命令与调用者的双重角色，执行它时将递归调用它所包含的所有命令，其具体结构图如图2 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161135322R.gif" alt="组合命令模式的结构图" /><br />图2组合命令模式的结构图</div>
<h2 style="text-align: center;">责任链模式</h2>
<p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。</p>
<h3>模式的定义与特点</h3>
<p>
责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。<br /><br /><strong>注意：责任链模式也叫职责链模式。</strong></p>
<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p>
<p>责任链模式是一种对象行为型模式，其主要<strong>优点</strong>如下。</p>
<ol>
<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if&middot;&middot;&middot;else 语句。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>








</ol>
<p>其主要<strong>缺点</strong>如下。</p>
<ol>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>









</ol>
<h3>模式的结构与实现</h3>
<p>
通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p>
<h4>1. 模式的结构</h4>
<p>
职责链模式主要包含以下角色。</p>
<ol>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>









</ol>
<p><br />其结构图如图 1 所示。客户端可按图 2 所示设置责任链。<br /><br /></p>
<div style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190605135539835-1083742055.png" alt="" /><br /><br />图1 责任链模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q11613592TF.gif" alt="责任链" /><br />图2 责任链</div>
<h3>模式的应用场景</h3>
<p>前边已经讲述了关于责任链模式的结构与特点，下面介绍其应用场景，责任链模式通常在以下几种情况使用。</p>
<ol>
<li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li>
<li>可动态指定一组对象处理请求，或添加新的处理者。</li>
<li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>





</ol>
<h3>模式的扩展</h3>
<p>职责链模式存在以下两种情况。</p>
<ol>
<li>纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li>
<li>不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。</li>





</ol>
<h2 style="text-align: center;">&nbsp;状态模式</h2>
<p>在软件开发过程中，应用程序中的有些对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。<br /><br />对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 语句来做状态判断，再进行不同情况的处理。但当对象的状态很多时，程序会变得很复杂。而且增加新的状态要添加新的 if-else 语句，这违背了&ldquo;开闭原则&rdquo;，不利于程序的扩展。<br /><br />以上问题如果采用&ldquo;状态模式&rdquo;就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关&ldquo;判断逻辑&rdquo;提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。</p>
<h3>状态模式的定义与特点</h3>
<p>
状态（State）模式的定义：对有状态的对象，把复杂的&ldquo;判断逻辑&rdquo;提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p>状态模式是一种对象行为型模式，其主要<strong>优点</strong>如下。</p>
<ol>
<li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足&ldquo;单一职责原则&rdquo;。</li>
<li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>


</ol>
<p>状态模式的主要<strong>缺点</strong>如下。</p>
<ol>
<li>状态模式的使用必然会增加系统的类与对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>




</ol>
<h3>状态模式的结构与实现</h3>
<p>
状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。现在我们来分析其基本结构和实现方法。</p>
<h4>1. 模式的结构</h4>
<p>
状态模式包含以下主要角色。</p>
<ol>
<li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete&nbsp;&nbsp;&nbsp; State）角色：实现抽象状态所对应的行为。</li>


</ol>
<p>其结构图如图 1 所示。</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q11615412U55.gif" alt="状态模式的结构图" /><br />图1 状态模式的结构图</div>
<h3>状态模式的应用场景</h3>
<p style="text-align: left;">通常在以下情况下可以考虑使用状态模式。</p>
<ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>


</ul>
<h3>状态模式的扩展</h3>
<p style="text-align: left;">在有些情况下，可能有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享，其结构图如图2所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116154539147.gif" alt="共享状态模式的结构图" /><br />图2共享状态模式的结构图</div>
<p style="text-align: left;">
<br />分析：共享状态模式的不同之处是在环境类中增加了一个 HashMap 来保存相关状态，当需要某种状态时可以从中获取。</p>]]></description></item><item><title>GoF的23种设计模式之结构型模式的特点和分类</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/05/10978331.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 05 Jun 2019 02:52:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/05/10978331.html</guid><description><![CDATA[<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。<strong>它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</strong></p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足<strong>&ldquo;合成复用原则&rdquo;</strong>，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
<p>以上 7 种结构型模式，除了<strong>适配器模式</strong>分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>两种，其他的全部属于对象结构型模式，下面我会分别、详细地介绍它们的特点、结构与应用。</p>
<p>&nbsp;</p>
<h2 style="text-align: center;">代理模式</h2>
<p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。</p>
<h3>代理模式的定义与特点</h3>
<p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要<strong>优点</strong>有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p>其主要<strong>缺点</strong>是：</p>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<h3>代理模式的结构与实现</h3>
<p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。<br /><strong>1. 模式的结构</strong><br />代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>






</ol>
<p>其结构图如图 1 所示。</p>
<p style="text-align: center;">代理模式的结构图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190605102028705-831254283.png" alt="" /></p>
<p style="text-align: center;">图1 代理模式的结构图</p>
<h3>代理模式的应用场景</h3>
<p style="text-align: left;">前面分析了代理模式的结构与特点，现在来分析以下的应用场景。</p>
<ul>
<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
<li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
<li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li>





</ul>
<h3>代理模式的扩展</h3>
<p style="text-align: left;">在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个<strong>缺点。</strong></p>
<ol>
<li>真实主题与代理主题一一对应，增加真实主题也要增加代理。</li>
<li>设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP，其结构图如图 2 所示。</li>





</ol>
<p style="text-align: left;">&nbsp;</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115093255227.gif" alt="动态代理模式的结构图" /><br />图2动态代理模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">&nbsp;适配器模式</h2>
<p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。</p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p>
<h3>模式的定义与特点</h3>
<p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<strong>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</strong></p>
<p>该模式的主要<strong>优点</strong>如下。</p>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>





</ul>
<p>其<strong>缺点</strong>是：对类适配器来说，更换适配器的实现过程比较复杂。</p>
<h3>模式的结构与实现</h3>
<p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</p>
<p><strong>1. 模式的结构</strong></p>
<p>适配器模式（Adapter）包含以下主要角色。</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>





</ul>
<p>类适配器模式的结构图如图 1 所示。</p>
<p style="text-align: center;">类适配器模式的结构图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190605102550600-1252560962.png" alt="" /></p>
<p style="text-align: center;">图1 类适配器模式的结构图</p>
<p>对象适配器模式的结构图如图 2 所示。</p>
<p style="text-align: center;">对象适配器模式的结构图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190605102613148-2048427674.png" alt="" /></p>
<p style="text-align: center;">图2 对象适配器模式的结构图</p>
<h3 style="text-align: left;">模式的应用场景</h3>
<p style="text-align: left;">适配器模式（Adapter）通常适用于以下场景。</p>
<ul style="text-align: left;">
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>



</ul>
<h3 style="text-align: left;">模式的扩展</h3>
<p style="text-align: left;">适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图 3 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115104Q1604.gif" alt="双向适配器模式的结构图" /><br />图3 双向适配器模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">桥接模式</h2>
<p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m&times;n 种，不但对应的子类很多，而且扩展困难。</p>
<p>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p>
<h3>桥接模式的定义与特点</h3>
<p>
桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>



</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p>
<h3>桥接模式的结构与实现</h3>
<p>
可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h4>1. 模式的结构</h4>
<p>
桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined&nbsp;&nbsp;&nbsp; Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>



</ol>
<p>其结构图如图 1 所示。</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115125253H1.gif" alt="桥接模式的结构图" /><br />图1 桥接模式的结构图</div>
<div style="text-align: left;">
<h3>桥接模式的应用场景</h3>



桥接模式通常适用于以下场景。<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li>



</ol>
<h3>桥接模式模式的扩展</h3>



在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如图2 所示。<br /><br />
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151255004c.gif" alt="桥接模式与适配器模式联用的结构图" /><br />图2桥接模式与适配器模式联用的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">装饰器模式</h2>
<p>在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等。在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。</p>
<h3>装饰模式的定义与特点</h3>
<p>
装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰（Decorator）模式的主要<strong>优点</strong>有：</p>
<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>



</ul>
<p>其主要<strong>缺点</strong>是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<h3>装饰模式的结构与实现</h3>
<p>
通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。</p>
<h4>1. 模式的结构</h4>
<p>
装饰模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete&nbsp;&nbsp;&nbsp; Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>



</ol>
<p>装饰模式的结构图如图 1 所示。</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115142115M2.gif" alt="装饰模式的结构图" /><br />图1 装饰模式的结构图</div>



</div>
<h3>装饰模式的应用场景</h3>
<p>前面讲解了关于装饰模式的结构与特点，下面介绍其适用的应用场景，装饰模式通常在以下几种情况使用。</p>
<ul>
<li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li>
<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。</li>
<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li>



</ul>
<p>装饰模式在Java语言中的最著名的应用莫过于Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>
<p>下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：</p>
<div class="cnblogs_code">
<pre>BufferedReader in=<span style="color: #0000ff;">new</span> BufferedReader(<span style="color: #0000ff;">new</span> FileReader("filename.txtn));
String s=in.readLine();</pre>
</div>
<h3>装饰模式的扩展</h3>
<p> 装饰模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。<br /><br />(1) 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件，其结构图如图 2 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q11514230H05.gif" alt="只有一个具体构件的装饰模式" /><br />图2只有一个具体构件的装饰模式</div>
<p>(2) 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并，其结构图如图 3 所示。</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115142333D3.gif" alt="只有一个具体装饰的装饰模式" /><br />图3 只有一个具体装饰的装饰模式</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">&nbsp;外观模式</h2>
<p>在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。</p>
<p>软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了&ldquo;开闭原则&rdquo;，也违背了&ldquo;迪米特法则&rdquo;，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。</p>
<p>图 1 给出了客户去当地房产局办理房产证过户要遇到的相关部门。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q11515205E60.gif" alt="办理房产证过户的相关部门" /><br />图1 办理房产证过户的相关部门</div>
<h3>外观模式的定义与特点</h3>
<p>
外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。<br /><br />外观（Facade）模式是<strong>&ldquo;迪米特法则&rdquo;</strong>的典型应用，它有以下主要<strong>优点</strong>。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>



</ol>
<p>外观（Facade）模式的主要<strong>缺点</strong>如下。</p>
<ol>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了&ldquo;开闭原则&rdquo;。</li>




</ol>
<h3>外观模式的结构与实现</h3>
<p>
外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p>
<h4>1. 模式的结构</h4>
<p>
外观（Facade）模式包含以下主要角色。</p>
<ol>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li>



</ol>
<p>其结构图如图 2 所示。</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115152143509.gif" alt="外观模式的结构图" /><br />图2 外观（Facade）模式的结构图</div>
<h3>外观模式的应用场景</h3>
<p style="text-align: left;">通常在以下情况下可以考虑使用外观模式。</p>
<ol>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>



</ol>
<h3>外观模式的扩展</h3>
<p style="text-align: left;">在外观模式中，当增加或移除子系统时需要修改外观类，这违背了&ldquo;开闭原则&rdquo;。如果引入抽象外观类，则在一定程度上解决了该问题，其结构图如图 3 所示。</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151524262a.gif" alt="引入抽象外观类的外观模式的结构图" /><br />图3引入抽象外观类的外观模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>
<h2 style="text-align: center;">享元模式</h2>
<p>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。</p>
<h3>享元模式的定义与特点</h3>
<p>
享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>其主要缺点是：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>




</ol>
<h3>享元模式的结构与实现</h3>
<p>
享元模式中存在以下两种状态：</p>
<ol>
<li><strong>内部状态，</strong>即不会随着环境的改变而改变的可共享部分；</li>
<li><strong>外部状态，</strong>指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</li>




</ol>
<h4>1. 模式的结构</h4>
<p>
享元模式的主要角色有如下。</p>
<ol>
<li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>
<li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>
<li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>



</ol>
<p>图 1 是享元模式的结构图。图中的 UnsharedConcreteFlyweight 是与淳元角色，里面包含了非共享的外部状态信息 info；而 Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；FlyweightFactory 是享元工厂角色，它逝关键字 key 来管理具体享元；客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115161342242.gif" alt="享元模式的结构图" /><br />图1 享元模式的结构图</div>
<div style="text-align: left;">
<h3>享元模式的应用场景</h3>



前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。<ol>
<li>系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</li>
<li>大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</li>
<li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</li>



</ol>
<h3>享元模式的扩展</h3>



在前面介绍的享元模式中，其结构图通常包含可以共享的部分和不可以共享的部分。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：单纯享元模式和复合享元模式，下面分别对它们进行简单介绍。<br /><br />(1)&nbsp;单纯享元模式，这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类，其结构图如图2 所示。<br /><br />
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115161549429.gif" alt="单纯享元模式的结构图" /><br />图2单纯享元模式的结构图</div>




<br />(2) 复合享元模式，这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享，其结构图如图 3所示。<br /><br />
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q11516162C42.gif" alt="复合享元模式的结构图" /><br />图3复合享元模式的结构图</div>
<div style="text-align: center;">&nbsp;</div>



</div>
<h2 style="text-align: center;">&nbsp;组合模式</h2>
<p>&nbsp;在现实生活中，存在很多&ldquo;部分-整体&rdquo;的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣月艮与衣柜以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。</p>
<h3>组合模式的定义与特点</h3>
<p>
组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示&ldquo;部分-整体&rdquo;的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>组合模式的主要<strong>优点</strong>有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足&ldquo;开闭原则&rdquo;；</li>



</ol>
<p>其主要<strong>缺点</strong>是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>




</ol>
<h3>组合模式的结构与实现</h3>
<p>
组合模式的结构不是很复杂，下面对它的结构和实现进行分析。</p>
<h4>1. 模式的结构</h4>
<p>
组合模式包含以下主要角色。</p>
<ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>



</ol>
<p>组合模式分为透明式的组合模式和安全式的组合模式。</p>
<p>(1) <strong>透明方式：</strong>在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如图 1 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151G62L17.gif" alt="透明式的组合模式的结构图" /><br />图1 透明式的组合模式的结构图</div>
<p>
<br />(2) <strong>安全方式：</strong>在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如图 2 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GF5221.gif" alt="安全式的组合模式的结构图" /><br />图2 安全式的组合模式的结构图</div>
<h3>组合模式的应用场景</h3>
<p style="text-align: left;">前面分析了组合模式的结构与特点，下面分析它适用的以下应用场景。</p>
<ol>
<li>在需要表示一个对象整体与部分的层次结构的场合。</li>
<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li>



</ol>
<h3>组合模式的扩展</h3>
<p style="text-align: left;">如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 Java AWT/Swing中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。复杂的组合模式的结构图如图 3 所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151H632613.gif" alt="复杂的组合模式的结构图" /><br />图3 复杂的组合模式的结构图</div>
<p>&nbsp;</p>]]></description></item><item><title>GoF的23种设计模式之创建型模式的特点和分类</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/03/10966300.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 03 Jun 2019 02:54:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/03/10966300.html</guid><description><![CDATA[<p><strong>创建型模式的主要关注点是&ldquo;怎样创建对象？&rdquo;，它的主要特点是&ldquo;将对象的创建与使用分离&rdquo;。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</strong><br /><br />创建型模式分为以下几种。</p>
<ul>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>










</ul>
<h2 style="text-align: center;">单列模式</h2>
<p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p>
<h3>单例模式的定义与特点</h3>
<p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p>
<p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p>
<p>单例模式有 3 个特点：</p>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点；</li>










</ol>
<h3>单例模式的结构与实现</h3>
<p>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过&ldquo;new 构造函数()&rdquo;来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>
<p>下面来分析其基本结构和实现方法。</p>
<p><strong>1. 单例模式的结构</strong><br />单例模式的主要角色如下。</p>
<ul>
<li>单例类：包含一个实例且能自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>










</ul>
<p>其结构如图1所示。</p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q1131K441K2.gif" alt="单例模式的结构图" /><br />图1单例模式的结构图</div>
<div style="text-align: left;">
<p><strong>2. 单例模式的实现</strong><br />Singleton 模式通常有两种实现形式。<br /><strong>第 1 种：懒汉式单例</strong><br />该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。</p>
<p><strong>第 2 种：饿汉式单例</strong><br />该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p>
<h3>单例模式的应用场景</h3>
<p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p>
<ul>
<li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li>
<li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>









</ul>
<h3>单例模式的扩展</h3>
<p>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArmyList 中，客户需要时可随机获取，其结构图如图2所示。</p>









</div>
<h1 style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q1131KQ4K8.gif" alt="有限的多例模式的结构图" /></h1>
<p style="text-align: center;">图2有限的多例模式的结构图</p>
<p>&nbsp;</p>
<h2 style="text-align: center;">原型模式</h2>
<p>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。</p>
<h3>原型模式的定义与特点</h3>
<p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。</p>
<h3>原型模式的结构与实现</h3>
<p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。<br />1. 模式的结构<br />原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>










</ol>
<p>其结构图如图1所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181114/3-1Q114101Fa22.gif" alt="原型模式的结构图" /><br />图1原型模式的结构图</div>
<p><strong>2. 模式的实现</strong><br />原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p>
<h3>原型模式的应用场景</h3>
<p>原型模式通常适用于以下场景。</p>
<ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>对象的创建过程比较麻烦，但复制比较简单的时候。</li>









</ul>
<h3>原型模式的扩展</h3>
<p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图如图2所示。</p>
<p>带原型管理器的原型模式的结构图</p>
<p style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181114/3-1Q114102049214.gif" alt="带原型管理器的原型模式的结构图" /><br />图2带原型管理器的原型模式的结构图</p>
<p style="text-align: center;">&nbsp;</p>
<h2 style="text-align: center;">工厂方法模式</h2>
<p>在现实生活中社会分工越来越细，越来越专业化。各种产品有专门的工厂生产，彻底告别了自给自足的小农经济时代，这大大缩短了产品的生产周期，提高了生产效率。同样，在软件开发中能否做到软件对象的生产和使用相分离呢？能否在满足&ldquo;开闭原则&rdquo;的前提下，客户随意增删或改变对软件相关对象的使用呢？</p>
<h3>模式的定义与特点</h3>
<p><strong>工厂方法（FactoryMethod）模式</strong>的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的&ldquo;创建与使用相分离&rdquo;的特点。</p>
<p>我们把被创建的对象称为&ldquo;产品&rdquo;，把创建产品的对象称为&ldquo;工厂&rdquo;。<strong>如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫&ldquo;简单工厂模式&rdquo;，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背&ldquo;开闭原则&rdquo;。</strong></p>
<p>这里介绍的&ldquo;工厂方法模式&rdquo;是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<p>工厂方法模式的主要优点有：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>










</ul>
<p>其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p>
<h3>模式的结构与实现&nbsp;</h3>
<p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。这里来分析其基本结构和实现方法。<br /><strong>1. 模式的结构</strong><br />工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>









</ol>
<p>&nbsp;其结构图如图1所示。<br /><br /></p>
<div style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181114/3-1Q114135A2M3.gif" alt="工厂方法模式的结构图" /><br />图1工厂方法模式的结构图</div>
<h3>模式的应用场景</h3>
<p>工厂方法模式通常适用于以下场景。</p>
<ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌。</li>









</ul>
<h3>模式的扩展</h3>
<p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式，其结构图如图2所示。</p>
<p style="text-align: center;"><img src="http://c.biancheng.net/uploads/allimg/181114/3-1Q114135306120.gif" alt="简单工厂模式的结构图" /><br />图2简单工厂模式的结构图</p>
<p style="text-align: center;">&nbsp;</p>
<h2 style="text-align: center;">抽象工厂模式</h2>
<p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机。</p>
<p>同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调。</p>
<p>下面要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。</p>
<p>电器工厂的产品等级与产品族</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190603104019029-988425255.png" alt="" /></p>
<p style="text-align: center;"><br />图1 电器工厂的产品等级与产品族</p>
<h3 style="text-align: left;"><br />模式的定义与特点</h3>
<p style="text-align: left;">抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>








</ul>
<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要<strong>优点</strong>如下。</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>








</ul>
<p>其<strong>缺点</strong>是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h3>模式的结构与实现</h3>
<p>抽象工厂模式同工厂方法模式一样，也是由<strong>抽象工厂、具体工厂、抽象产品和具体产品</strong>等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。<br /><strong>1. 模式的结构</strong><br />抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>








</ol>
<p>抽象工厂模式的结构图如图 2 所示。</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190603104229554-453808449.png" alt="" /></p>
<p style="text-align: center;">图2 抽象工厂模式的结构图</p>
<p style="text-align: left;"><br /><strong>2. 模式的实现</strong><br />从图 2 可以看出抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。</p>
<h3>模式的应用场景</h3>
<p><strong>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。</strong>如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。</p>
<p>抽象工厂模式通常适用于以下场景：</p>
<ol>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>







</ol>
<h3>模式的扩展</h3>
<p>抽象工厂模式的扩展有一定的&ldquo;开闭原则&rdquo;倾斜性：</p>
<ol>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>







</ol>
<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>
<p>&nbsp;</p>
<h2 style="text-align: center;">建造者模式</h2>
<p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p>
<p>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p>
<p>以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。</p>
<h3>模式的定义与特点</h3>
<p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>该模式的主要<strong>优点</strong>如下：</p>
<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>







</ol>
<p>其<strong>缺点</strong>如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>







</ol>
<p>建造者（Builder）模式和工厂模式的关注点不同：<strong>建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</strong></p>
<h3>模式的结构与实现</h3>
<p>建造者（Builder）模式由<strong>产品、抽象建造者、具体建造者、指挥者</strong>等 4 个要素构成，现在我们来分析其基本结构和实现方法。<br /><strong>1. 模式的结构</strong><br />建造者（Builder）模式的主要角色如下。</p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>







</ol>
<p>其结构图如图 1 所示。</p>
<p style="text-align: center;">建造者模式的结构图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190603104809573-779050946.png" alt="" /></p>
<p style="text-align: center;">图1 建造者模式的结构图</p>
<h3>模式的应用场景</h3>
<p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>






</ul>
<h3>模式的扩展</h3>
<p>建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。</p>
<p style="text-align: left;">&nbsp;</p>]]></description></item><item><title>软件设计的七大原则</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/01/10959800.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 01 Jun 2019 07:40:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/01/10959800.html</guid><description><![CDATA[<p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。我来依次来总结这 7 条原则。</p>
<p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中<strong>，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</strong></p>
<h2 style="text-align: center;">开闭原则</h2>
<h3 style="text-align: left;">开闭原则的定义</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('763ed499-ea2b-418d-9ccb-b99459ae2d99')"><img id="code_img_closed_763ed499-ea2b-418d-9ccb-b99459ae2d99" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_763ed499-ea2b-418d-9ccb-b99459ae2d99" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('763ed499-ea2b-418d-9ccb-b99459ae2d99',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_763ed499-ea2b-418d-9ccb-b99459ae2d99" class="cnblogs_code_hide">
<pre>开闭原则（Open Closed Principle，OCP）由勃兰特&middot;梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open <span style="color: #0000ff;">for</span> extension，but closed <span style="color: #0000ff;">for</span><span style="color: #000000;"> modification），这就是开闭原则的经典定义。

这里的软件实体包括以下几个部分：
</span>1<span style="color: #000000;">.项目中划分出的模块
</span>2<span style="color: #000000;">.类与接口
</span>3<span style="color: #000000;">.方法

开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</span></pre>
</div>
<span class="cnblogs_code_collapse">开闭原则的定义</span></div>
<h3 style="text-align: left;">开闭原则的作用</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('64943498-39b0-4f38-93c1-4eed08b72c43')"><img id="code_img_closed_64943498-39b0-4f38-93c1-4eed08b72c43" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_64943498-39b0-4f38-93c1-4eed08b72c43" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('64943498-39b0-4f38-93c1-4eed08b72c43',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_64943498-39b0-4f38-93c1-4eed08b72c43" class="cnblogs_code_hide">
<pre><span style="color: #000000;">开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。

1. 对软件测试的影响
软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
2. 可以提高代码的可复用性
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
3. 可以提高软件的可维护性
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</span></pre>
</div>
<span class="cnblogs_code_collapse">开闭原则的作用</span></div>
<h3>开闭原则的实现方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('8e2cf757-8402-45e2-983b-ff94517c0b57')"><img id="code_img_closed_8e2cf757-8402-45e2-983b-ff94517c0b57" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8e2cf757-8402-45e2-983b-ff94517c0b57" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8e2cf757-8402-45e2-983b-ff94517c0b57',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8e2cf757-8402-45e2-983b-ff94517c0b57" class="cnblogs_code_hide">
<pre><span style="color: #000000;">可以通过&ldquo;抽象约束、封装变化&rdquo;来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</span></pre>
</div>
<span class="cnblogs_code_collapse">开闭原则的实现方法</span></div>
<p>下面以 Windows 的桌面主题为例介绍开闭原则的应用。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">【例1】Windows 的桌面主题设计。

分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如图 1 所示。</span></pre>
</div>
<p>Windows的桌面主题类图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601154711747-1474570341.gif" alt="" /><br />图1 Windows的桌面主题类图</p>
<p style="text-align: center;">&nbsp;</p>
<h2 style="text-align: center;">里氏替换原则</h2>
<h3>里氏替换原则的定义</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('4054fdbe-7754-418b-b15c-dc1d5c02dc02')"><img id="code_img_closed_4054fdbe-7754-418b-b15c-dc1d5c02dc02" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4054fdbe-7754-418b-b15c-dc1d5c02dc02" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4054fdbe-7754-418b-b15c-dc1d5c02dc02',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4054fdbe-7754-418b-b15c-dc1d5c02dc02" class="cnblogs_code_hide">
<pre>里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的&ldquo;面向对象技术的高峰会议&rdquo;（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds <span style="color: #0000ff;">for</span><span style="color: #000000;"> subtype objects）。

里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</span></pre>
</div>
<span class="cnblogs_code_collapse">里氏替换原则的定义</span></div>
<h3>里氏替换原则的作用</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('3b6c67b8-ec87-4dcb-a435-5900119d1513')"><img id="code_img_closed_3b6c67b8-ec87-4dcb-a435-5900119d1513" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3b6c67b8-ec87-4dcb-a435-5900119d1513" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3b6c67b8-ec87-4dcb-a435-5900119d1513',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3b6c67b8-ec87-4dcb-a435-5900119d1513" class="cnblogs_code_hide">
<pre><span style="color: #000000;">里氏替换原则的主要作用如下。

里氏替换原则是实现开闭原则的重要方式之一。
它克服了继承中重写父类造成的可复用性变差的缺点。
它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</span></pre>
</div>
<span class="cnblogs_code_collapse">里氏替换原则的作用</span></div>
<h3>里氏替换原则的实现方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('5b78feab-7956-4088-8a54-72b9d6c8c2fc')"><img id="code_img_closed_5b78feab-7956-4088-8a54-72b9d6c8c2fc" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5b78feab-7956-4088-8a54-72b9d6c8c2fc" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5b78feab-7956-4088-8a54-72b9d6c8c2fc',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5b78feab-7956-4088-8a54-72b9d6c8c2fc" class="cnblogs_code_hide">
<pre><span style="color: #000000;">里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

关于里氏替换原则的例子，最有名的是&ldquo;正方形不是长方形&rdquo;。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承&ldquo;鸟&rdquo;会飞的功能，所以它们不能定义成&ldquo;鸟&rdquo;的子类。同样，由于&ldquo;气球鱼&rdquo;不会游泳，所以不能定义成&ldquo;鱼&rdquo;的子类；&ldquo;玩具炮&rdquo;炸不了敌人，所以不能定义成&ldquo;炮&rdquo;的子类等。</span></pre>
</div>
<span class="cnblogs_code_collapse">里氏替换原则的实现方法</span></div>
<p>下面以&ldquo;几维鸟不是鸟&rdquo;为例来说明里氏替换原则。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">【例2】里氏替换原则在&ldquo;几维鸟不是鸟&rdquo;实例中的应用。

分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生&ldquo;除零异常&rdquo;或是&ldquo;无穷大&rdquo;，明显不符合预期，其类图如图 1 所示。</span></pre>
</div>
<p>&nbsp;</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601160739133-1031722696.gif" alt="" /></p>
<p style="text-align: center;">图1 &ldquo;几维鸟不是鸟&rdquo;实例的类图</p>
<p style="text-align: left;">程序代码如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('dade6d6a-a6c7-4b2e-987f-90adc891f5f5')"><img id="code_img_closed_dade6d6a-a6c7-4b2e-987f-90adc891f5f5" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_dade6d6a-a6c7-4b2e-987f-90adc891f5f5" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('dade6d6a-a6c7-4b2e-987f-90adc891f5f5',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_dade6d6a-a6c7-4b2e-987f-90adc891f5f5" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> principle;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> LSPtest
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)
    {
        Bird bird1</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Swallow();
        Bird bird2</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> BrownKiwi();
        bird1.setSpeed(</span>120<span style="color: #000000;">);
        bird2.setSpeed(</span>120<span style="color: #000000;">);
        System.out.println(</span>"如果飞行300公里："<span style="color: #000000;">);
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">
        {
            System.out.println(</span>"燕子将飞行"+bird1.getFlyTime(300)+"小时."<span style="color: #000000;">);
            System.out.println(</span>"几维鸟将飞行"+bird2.getFlyTime(300)+"小时。"<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(Exception err)
        {
            System.out.println(</span>"发生错误了!"<span style="color: #000000;">);
        }
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">鸟类</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Bird
{
    </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> flySpeed;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setSpeed(<span style="color: #0000ff;">double</span><span style="color: #000000;"> speed)
    {
        flySpeed</span>=<span style="color: #000000;">speed;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> getFlyTime(<span style="color: #0000ff;">double</span><span style="color: #000000;"> distance)
    {
        </span><span style="color: #0000ff;">return</span>(distance/<span style="color: #000000;">flySpeed);
    }
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">燕子类</span>
<span style="color: #0000ff;">class</span> Swallow <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Bird{}
</span><span style="color: #008000;">//</span><span style="color: #008000;">几维鸟类</span>
<span style="color: #0000ff;">class</span> BrownKiwi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Bird
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> setSpeed(<span style="color: #0000ff;">double</span><span style="color: #000000;"> speed)
    {
           flySpeed</span>=0<span style="color: #000000;">;
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p style="text-align: left;">程序的运行结果如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">如果飞行300公里：
燕子将飞行2.5小时.
几维鸟将飞行Infinity小时。</span></pre>
</div>
<div class="cnblogs_code">
<pre>程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(<span style="color: #0000ff;">double</span> speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。</pre>
</div>
<p style="text-align: left;">其类图如图 2 所示。</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601161004771-1744668503.gif" alt="" /></p>
<p style="text-align: center;">&nbsp;</p>
<p style="text-align: center;">图2 &ldquo;几维鸟是动物&rdquo;实例的类图、</p>
<h2 style="text-align: center;">依赖倒置原则</h2>
<h3>依赖倒置原则的定义</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('7e089010-36eb-4ce8-8412-8102bc8ad3bd')"><img id="code_img_closed_7e089010-36eb-4ce8-8412-8102bc8ad3bd" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7e089010-36eb-4ce8-8412-8102bc8ad3bd" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7e089010-36eb-4ce8-8412-8102bc8ad3bd',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7e089010-36eb-4ce8-8412-8102bc8ad3bd" class="cnblogs_code_hide">
<pre>依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特&middot;马丁（Robert C.Martin）于 1996 年在 C++<span style="color: #000000;"> Report 上发表的文章。

依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>依赖倒置原则的作用</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('7f5fbf00-4d44-495f-bfb7-8ae4113bba71')"><img id="code_img_closed_7f5fbf00-4d44-495f-bfb7-8ae4113bba71" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_7f5fbf00-4d44-495f-bfb7-8ae4113bba71" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('7f5fbf00-4d44-495f-bfb7-8ae4113bba71',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_7f5fbf00-4d44-495f-bfb7-8ae4113bba71" class="cnblogs_code_hide">
<pre><span style="color: #000000;">依赖倒置原则的主要作用如下。
依赖倒置原则可以降低类间的耦合性。
依赖倒置原则可以提高系统的稳定性。
依赖倒置原则可以减少并行开发引起的风险。
依赖倒置原则可以提高代码的可读性和可维护性。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>依赖倒置原则的实现方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('5445bc90-c324-4037-a82d-b9e21ed9e9a3')"><img id="code_img_closed_5445bc90-c324-4037-a82d-b9e21ed9e9a3" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_5445bc90-c324-4037-a82d-b9e21ed9e9a3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5445bc90-c324-4037-a82d-b9e21ed9e9a3',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_5445bc90-c324-4037-a82d-b9e21ed9e9a3" class="cnblogs_code_hide">
<pre><span style="color: #000000;">依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
每个类尽量提供接口或抽象类，或者两者都具备。
变量的声明类型尽量是接口或者是抽象类。
任何类都不应该从具体类派生。
使用继承时尽量遵循里氏替换原则。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>下面以&ldquo;顾客购物程序&rdquo;为例来说明依赖倒置原则的应用。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">【例1】依赖倒置原则在&ldquo;顾客购物程序&rdquo;中的应用。

分析：本程序反映了 &ldquo;顾客类&rdquo;与&ldquo;商店类&rdquo;的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：</span></pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('6996ceec-a04b-48bb-b027-814e0bc51fb7')"><img id="code_img_closed_6996ceec-a04b-48bb-b027-814e0bc51fb7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6996ceec-a04b-48bb-b027-814e0bc51fb7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6996ceec-a04b-48bb-b027-814e0bc51fb7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6996ceec-a04b-48bb-b027-814e0bc51fb7" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Customer
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> shopping(ShaoguanShop shop)
{
</span><span style="color: #008000;">//</span><span style="color: #008000;">购物</span>
<span style="color: #000000;">System.out.println（shop.sell());
}
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code">
<pre>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('b9c6d851-a985-4e89-83e4-660b1459803d')"><img id="code_img_closed_b9c6d851-a985-4e89-83e4-660b1459803d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_b9c6d851-a985-4e89-83e4-660b1459803d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b9c6d851-a985-4e89-83e4-660b1459803d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_b9c6d851-a985-4e89-83e4-660b1459803d" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Customer
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> shopping(WuyuanShop shop)
{
</span><span style="color: #008000;">//</span><span style="color: #008000;">购物</span>
<span style="color: #000000;">System.out.println(shop.sell());
}
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code">
<pre>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义&ldquo;婺源网店&rdquo;和&ldquo;韶关网店&rdquo;的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('af12c42f-e91a-4fea-a035-0c689181f686')"><img id="code_img_closed_af12c42f-e91a-4fea-a035-0c689181f686" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_af12c42f-e91a-4fea-a035-0c689181f686" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('af12c42f-e91a-4fea-a035-0c689181f686',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_af12c42f-e91a-4fea-a035-0c689181f686" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Customer
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> shopping(Shop shop)
{
</span><span style="color: #008000;">//</span><span style="color: #008000;">购物</span>
<span style="color: #000000;">System.out.println(shop.sell());
}
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code">
<pre>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。</pre>
</div>
<p>顾客购物程序的类图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601162128254-856377288.gif" alt="" /><br />图1 顾客购物程序的类图</p>
<p>程序代码如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e795a295-7380-4ac7-a826-89e1c8625a78')"><img id="code_img_closed_e795a295-7380-4ac7-a826-89e1c8625a78" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e795a295-7380-4ac7-a826-89e1c8625a78" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e795a295-7380-4ac7-a826-89e1c8625a78',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e795a295-7380-4ac7-a826-89e1c8625a78" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> principle;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> DIPtest
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)
{
Customer wang</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Customer();
System.out.println(</span>"顾客购买以下商品："<span style="color: #000000;">); 
wang.shopping(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> ShaoguanShop()); 
wang.shopping(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> WuyuanShop());
}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">商店</span>
<span style="color: #0000ff;">interface</span><span style="color: #000000;"> Shop
{
</span><span style="color: #0000ff;">public</span> String sell(); <span style="color: #008000;">//</span><span style="color: #008000;">卖</span>
<span style="color: #000000;">}
</span><span style="color: #008000;">//</span><span style="color: #008000;">韶关网店</span>
<span style="color: #0000ff;">class</span> ShaoguanShop <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Shop
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String sell()
{
</span><span style="color: #0000ff;">return</span> "韶关土特产：香菇、木耳&hellip;&hellip;"<span style="color: #000000;">; 
} 
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">婺源网店</span>
<span style="color: #0000ff;">class</span> WuyuanShop <span style="color: #0000ff;">implements</span><span style="color: #000000;"> Shop
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String sell()
{
</span><span style="color: #0000ff;">return</span> "婺源土特产：绿茶、酒糟鱼&hellip;&hellip;"<span style="color: #000000;">; 
}
} 
</span><span style="color: #008000;">//</span><span style="color: #008000;">顾客</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Customer
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> shopping(Shop shop)
{
</span><span style="color: #008000;">//</span><span style="color: #008000;">购物</span>
<span style="color: #000000;">System.out.println(shop.sell()); 
}
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>程序的运行结果如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">顾客购买以下商品：
韶关土特产：香菇、木耳&hellip;&hellip;
婺源土特产：绿茶、酒糟鱼&hellip;&hellip;</span></pre>
</div>
<p>&nbsp;</p>
<h2 style="text-align: center;"><span style="text-align: center;">&nbsp;单一职责原则</span></h2>
<h3>单一职责原则的定义</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('2a52e8a0-4abe-4daa-9699-090d6c9cc5b9')"><img id="code_img_closed_2a52e8a0-4abe-4daa-9699-090d6c9cc5b9" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2a52e8a0-4abe-4daa-9699-090d6c9cc5b9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2a52e8a0-4abe-4daa-9699-090d6c9cc5b9',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2a52e8a0-4abe-4daa-9699-090d6c9cc5b9" class="cnblogs_code_hide">
<pre>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特&middot;C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason <span style="color: #0000ff;">for</span> a <span style="color: #0000ff;">class</span><span style="color: #000000;"> to change）。


该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：
一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>单一职责原则的优点</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('72e217b5-fc6f-46bb-addc-538117e02a77')"><img id="code_img_closed_72e217b5-fc6f-46bb-addc-538117e02a77" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_72e217b5-fc6f-46bb-addc-538117e02a77" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('72e217b5-fc6f-46bb-addc-538117e02a77',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_72e217b5-fc6f-46bb-addc-538117e02a77" class="cnblogs_code_hide">
<pre><span style="color: #000000;">单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。
降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
提高类的可读性。复杂性降低，自然其可读性会提高。
提高系统的可维护性。可读性提高，那自然更容易维护了。
变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>单一职责原则的实现方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('520f4db7-b48f-4ccf-b47e-ffeb5c57fb4d')"><img id="code_img_closed_520f4db7-b48f-4ccf-b47e-ffeb5c57fb4d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_520f4db7-b48f-4ccf-b47e-ffeb5c57fb4d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('520f4db7-b48f-4ccf-b47e-ffeb5c57fb4d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_520f4db7-b48f-4ccf-b47e-ffeb5c57fb4d" class="cnblogs_code_hide">
<pre>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">【例1】大学学生工作管理程序。
分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图 </span>1 所示。</pre>
</div>
<p>大学学生工作管理程序的类图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601162722785-1553197684.gif" alt="" /><br />图1 大学学生工作管理程序的类图</p>
<div class="cnblogs_code">
<pre>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</pre>
</div>
<h2 style="text-align: center;">接口隔离原则</h2>
<h3>接口隔离原则的定义</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('80c0a03f-4f3b-4696-ae7c-167c06f7d9a1')"><img id="code_img_closed_80c0a03f-4f3b-4696-ae7c-167c06f7d9a1" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_80c0a03f-4f3b-4696-ae7c-167c06f7d9a1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('80c0a03f-4f3b-4696-ae7c-167c06f7d9a1',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_80c0a03f-4f3b-4696-ae7c-167c06f7d9a1" class="cnblogs_code_hide">
<pre><span style="color: #000000;">接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

</span>2002 年罗伯特&middot;C.马丁给&ldquo;接口隔离原则&rdquo;的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they <span style="color: #0000ff;">do</span> not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one <span style="color: #0000ff;">class</span> to another one should depend on the smallest possible <span style="color: #0000ff;">interface</span><span style="color: #000000;">）。

以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>接口隔离原则的优点</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('501feb69-2d4d-4392-ab3d-43f0742f5e18')"><img id="code_img_closed_501feb69-2d4d-4392-ab3d-43f0742f5e18" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_501feb69-2d4d-4392-ab3d-43f0742f5e18" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('501feb69-2d4d-4392-ab3d-43f0742f5e18',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_501feb69-2d4d-4392-ab3d-43f0742f5e18" class="cnblogs_code_hide">
<pre><span style="color: #000000;">接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>接口隔离原则的实现方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('6c68fd24-c7c1-4db6-910c-675981757e7d')"><img id="code_img_closed_6c68fd24-c7c1-4db6-910c-675981757e7d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_6c68fd24-c7c1-4db6-910c-675981757e7d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6c68fd24-c7c1-4db6-910c-675981757e7d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_6c68fd24-c7c1-4db6-910c-675981757e7d" class="cnblogs_code_hide">
<pre><span style="color: #000000;">在具体应用接口隔离原则时，应该根据以下几个规则来衡量。

接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>下面以学生成绩管理程序为例介绍接口隔离原则的应用。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">【例1】学生成绩管理程序。

分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。</span></pre>
</div>
<p>学生成绩管理程序的类图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601163623261-1942952964.gif" alt="" /><br />图1 学生成绩管理程序的类图<br />程序代码如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4d630219-803e-4a46-8dcb-5a5a2009962b')"><img id="code_img_closed_4d630219-803e-4a46-8dcb-5a5a2009962b" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_4d630219-803e-4a46-8dcb-5a5a2009962b" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4d630219-803e-4a46-8dcb-5a5a2009962b',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_4d630219-803e-4a46-8dcb-5a5a2009962b" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> principle;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ISPtest
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)
{
InputModule input </span>=<span style="color: #000000;">StuScoreList.getInputModule();
CountModule count </span>=<span style="color: #000000;">StuScoreList.getCountModule();
PrintModule print </span>=<span style="color: #000000;">StuScoreList.getPrintModule();
input.insert();
count.countTotalScore();
print.printStuInfo();
</span><span style="color: #008000;">//</span><span style="color: #008000;">print.delete();</span>
<span style="color: #000000;">}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">输入模块接口</span>
<span style="color: #0000ff;">interface</span><span style="color: #000000;"> InputModule
{
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> insert();
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> delete();
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> modify();
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">统计模块接口</span>
<span style="color: #0000ff;">interface</span><span style="color: #000000;"> CountModule
{
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> countTotalScore();
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> countAverage();
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">打印模块接口</span>
<span style="color: #0000ff;">interface</span><span style="color: #000000;"> PrintModule
{
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> printStuInfo();
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> queryStuInfo();
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">实现类</span>
<span style="color: #0000ff;">class</span> StuScoreList <span style="color: #0000ff;">implements</span><span style="color: #000000;"> InputModule,CountModule,PrintModule
{
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> StuScoreList(){}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> InputModule getInputModule()
{
</span><span style="color: #0000ff;">return</span> (InputModule)<span style="color: #0000ff;">new</span><span style="color: #000000;"> StuScoreList();
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> CountModule getCountModule()
{
</span><span style="color: #0000ff;">return</span> (CountModule)<span style="color: #0000ff;">new</span><span style="color: #000000;"> StuScoreList();
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> PrintModule getPrintModule()
{
</span><span style="color: #0000ff;">return</span> (PrintModule)<span style="color: #0000ff;">new</span><span style="color: #000000;"> StuScoreList();
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> insert()
{
System.out.println(</span>"输入模块的insert()方法被调用！"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> delete()
{
System.out.println(</span>"输入模块的delete()方法被调用！"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> modify()
{
System.out.println(</span>"输入模块的modify()方法被调用！"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> countTotalScore()
{
System.out.println(</span>"统计模块的countTotalScore()方法被调用！"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> countAverage()
{
System.out.println(</span>"统计模块的countAverage()方法被调用！"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printStuInfo()
{
System.out.println(</span>"打印模块的printStuInfo()方法被调用！"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> queryStuInfo()
{
System.out.println(</span>"打印模块的queryStuInfo()方法被调用！"<span style="color: #000000;">);
}
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>程序的运行结果如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">输入模块的insert()方法被调用！
统计模块的countTotalScore()方法被调用！
打印模块的printStuInfo()方法被调用！</span></pre>
</div>
<p>&nbsp;</p>
<h2 style="text-align: center;"><span style="text-align: center;">&nbsp;迪米特法则</span></h2>
<h3>迪米特法则的定义</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('8813a91b-41fe-4725-b4a0-5e3f8027531c')"><img id="code_img_closed_8813a91b-41fe-4725-b4a0-5e3f8027531c" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8813a91b-41fe-4725-b4a0-5e3f8027531c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8813a91b-41fe-4725-b4a0-5e3f8027531c',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8813a91b-41fe-4725-b4a0-5e3f8027531c" class="cnblogs_code_hide">
<pre>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987<span style="color: #000000;"> 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩&middot;荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。


迪米特法则的定义是：只与你的直接朋友交谈，不跟&ldquo;陌生人&rdquo;说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。


迪米特法则中的&ldquo;朋友&rdquo;是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>迪米特法则的优点</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('aaa5a69f-4ab2-43ec-8fe0-d707fe1188cf')"><img id="code_img_closed_aaa5a69f-4ab2-43ec-8fe0-d707fe1188cf" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_aaa5a69f-4ab2-43ec-8fe0-d707fe1188cf" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('aaa5a69f-4ab2-43ec-8fe0-d707fe1188cf',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_aaa5a69f-4ab2-43ec-8fe0-d707fe1188cf" class="cnblogs_code_hide">
<pre><span style="color: #000000;">迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。
降低了类之间的耦合度，提高了模块的相对独立性。
由于亲合度降低，从而提高了类的可复用率和系统的扩展性。


但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>迪米特法则的实现方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('94d8a6fc-31eb-4572-a4c2-c708b97745ea')"><img id="code_img_closed_94d8a6fc-31eb-4572-a4c2-c708b97745ea" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_94d8a6fc-31eb-4572-a4c2-c708b97745ea" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('94d8a6fc-31eb-4572-a4c2-c708b97745ea',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_94d8a6fc-31eb-4572-a4c2-c708b97745ea" class="cnblogs_code_hide">
<pre><span style="color: #000000;">从迪米特法则的定义和特点可知，它强调以下两点：
从依赖者的角度来说，只依赖应该依赖的对象。
从被依赖者的角度说，只暴露应该暴露的方法。


所以，在运用迪米特法则时要注意以下 </span>6<span style="color: #000000;"> 点。
在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
在类的结构设计上，尽量降低类成员的访问权限。
在类的设计上，优先考虑将一个类设置成不变类。
在对其他类的引用上，将引用其他对象的次数降到最低。
不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
谨慎使用序列化（Serializable）功能。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">【例1】明星与经纪人的关系实例。
分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图 </span>1 所示。</pre>
</div>
<p>&nbsp;</p>
<p>明星与经纪人的关系图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601164058537-850563971.gif" alt="" /><br />图1 明星与经纪人的关系图</p>
<p>程序代码如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('709af045-6bf9-4778-964f-f11e1eeee116')"><img id="code_img_closed_709af045-6bf9-4778-964f-f11e1eeee116" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_709af045-6bf9-4778-964f-f11e1eeee116" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('709af045-6bf9-4778-964f-f11e1eeee116',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_709af045-6bf9-4778-964f-f11e1eeee116" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> principle;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> LoDtest
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args)
{
Agent agent</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Agent();
agent.setStar(</span><span style="color: #0000ff;">new</span> Star("林心如"<span style="color: #000000;">));
agent.setFans(</span><span style="color: #0000ff;">new</span> Fans("粉丝韩丞"<span style="color: #000000;">));
agent.setCompany(</span><span style="color: #0000ff;">new</span> Company("中国传媒有限公司"<span style="color: #000000;">));
agent.meeting();
agent.business();
}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">经纪人</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Agent
{
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Star myStar;
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Fans myFans;
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Company myCompany;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setStar(Star myStar)
{
</span><span style="color: #0000ff;">this</span>.myStar=<span style="color: #000000;">myStar;
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setFans(Fans myFans)
{
</span><span style="color: #0000ff;">this</span>.myFans=<span style="color: #000000;">myFans;
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setCompany(Company myCompany)
{
</span><span style="color: #0000ff;">this</span>.myCompany=<span style="color: #000000;">myCompany;
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> meeting()
{
System.out.println(myFans.getName()</span>+"与明星"+myStar.getName()+"见面了。"<span style="color: #000000;">);
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> business()
{
System.out.println(myCompany.getName()</span>+"与明星"+myStar.getName()+"洽淡业务。"<span style="color: #000000;">);
}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">明星</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Star
{
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
Star(String name)
{
</span><span style="color: #0000ff;">this</span>.name=<span style="color: #000000;">name;
}
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName()
{
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">粉丝</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Fans
{
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
Fans(String name)
{
</span><span style="color: #0000ff;">this</span>.name=<span style="color: #000000;">name;
}
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName()
{
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
}
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">媒体公司</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Company
{
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String name;
Company(String name)
{
</span><span style="color: #0000ff;">this</span>.name=<span style="color: #000000;">name;
}
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getName()
{
</span><span style="color: #0000ff;">return</span><span style="color: #000000;"> name;
}
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>程序的运行结果如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">粉丝韩丞与明星林心如见面了。
中国传媒有限公司与明星林心如洽淡业务。</span></pre>
</div>
<h2 style="text-align: center;">合成复用原则</h2>
<h3 style="text-align: left;">合成复用原则的定义</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('06a42830-0362-41ac-99b1-980e7a66e9e7')"><img id="code_img_closed_06a42830-0362-41ac-99b1-980e7a66e9e7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_06a42830-0362-41ac-99b1-980e7a66e9e7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('06a42830-0362-41ac-99b1-980e7a66e9e7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_06a42830-0362-41ac-99b1-980e7a66e9e7" class="cnblogs_code_hide">
<pre>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/<span style="color: #000000;">Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>合成复用原则的重要性</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('aa67d43f-cc54-45d9-92c2-c60af40a21c7')"><img id="code_img_closed_aa67d43f-cc54-45d9-92c2-c60af40a21c7" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_aa67d43f-cc54-45d9-92c2-c60af40a21c7" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('aa67d43f-cc54-45d9-92c2-c60af40a21c7',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_aa67d43f-cc54-45d9-92c2-c60af40a21c7" class="cnblogs_code_hide">
<pre><span style="color: #000000;">通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
</span>1<span style="color: #000000;">.继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为&ldquo;白箱&rdquo;复用。
</span>2<span style="color: #000000;">.子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
</span>3<span style="color: #000000;">.它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
</span>1<span style="color: #000000;">.它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为&ldquo;黑箱&rdquo;复用。
</span>2<span style="color: #000000;">.新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
</span>3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>合成复用原则的实现方法</h3>
<div class="cnblogs_code" onclick="cnblogs_code_show('1325bcb6-0812-4a91-a01f-879438909f0d')"><img id="code_img_closed_1325bcb6-0812-4a91-a01f-879438909f0d" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_1325bcb6-0812-4a91-a01f-879438909f0d" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1325bcb6-0812-4a91-a01f-879438909f0d',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_1325bcb6-0812-4a91-a01f-879438909f0d" class="cnblogs_code_hide">
<pre>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>下面以汽车分类管理程序为例来介绍合成复用原则的应用。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">【例1】汽车分类管理程序。
分析：汽车按&ldquo;动力源&rdquo;划分可分为汽油汽车、电动汽车等；按&ldquo;颜色&rdquo;划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 </span>1 所示是用继淨：关系实现的汽车分类的类图。</pre>
</div>
<p>用继承关系实现的汽车分类的类图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601164735836-149349286.gif" alt="" /><br />图1 用继承关系实现的汽车分类的类图</p>
<div class="cnblogs_code">
<pre>从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的&ldquo;动力源&rdquo;或者增加新的&ldquo;颜色&rdquo;都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。</pre>
</div>
<p>用组合关系实现的汽车分类的类图</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601164748224-1510979176.gif" alt="" /><br />图2 用组合关系实现的汽车分类的类图&nbsp;</p>
<p>结合前几节的内容，我们一共介绍了 7 种设计原则，它们分别为<strong>开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和本节所介绍的合成复用原则</strong>。</p>
<p>&nbsp;</p>]]></description></item><item><title>UML统一建模语言介绍</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/01/10958780.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 01 Jun 2019 02:41:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/01/10958780.html</guid><description><![CDATA[<h2 style="text-align: center;">统一建模语言简介</h2>
<p style="text-align: left;"><strong>　　统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，</strong>1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。<strong>它的特点是简单、统一、图形化、能表达软件设计中的动态</strong><strong>与静态信息。</strong></p>
<p style="text-align: left;">&nbsp;</p>
<p>统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。</p>
<p>UML 从目标系统的不同角度出发，定义了<strong>用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图</strong>等 9 种图。</p>
<p>这篇主要介绍软件设计模式中经常用到的类图，以及类之间的关系。另外，在实验部分将简单介绍 UML 建模工具的使用方法，当前业界使用最广泛的是 Rational Rose。使用 Umlet 的人也很多，它是一个轻量级的开源 UML 建模工具，简单实用，常用于小型软件系统的开发与设计。</p>
<h2 style="text-align: center;"><br />类、接口和类图</h2>
<h3 style="text-align: left;">1. 类</h3>
<p style="text-align: left;"><strong>类（Class）</strong>是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。</p>
<p style="text-align: left;">&nbsp;</p>
<p><strong>(1) 类名（Name）</strong>是一个字符串，例如，Student。</p>
<p><strong>(2) 属性（Attribute）</strong>是指类的特性，即类的成员变量。UML 按以下格式表示：</p>
<div class="cnblogs_code">
<pre>[可见性]属性名:类型[=默认值]</pre>
</div>
<p><strong>例如：-name:String</strong></p>
<p>注意：<strong>&ldquo;可见性&rdquo;</strong>表示该属性对类外的元素是否可见，包括<strong>公有（Public）、私有（Private）、受保护（Protected）</strong>和朋友（Friendly）4 种，在类图中分别用符号<strong>+、-、#</strong>、~表示。</p>
<p><strong>(3) 操作（Operations）</strong>是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：</p>
<div class="cnblogs_code">
<pre>[可见性]名称(参数列表)[:返回类型]</pre>
</div>
<p><strong>例如：+display():void。</strong></p>
<p>图 1 所示是学生类的 UML 表示。</p>
<p>Student 类</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601102539584-1060562196.gif" alt="" /></p>
<p style="text-align: center;">图1 Student 类</p>
<h3><br />2. 接口</h3>
<p><strong>接口（Interface）</strong>是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。</p>
<p>图 2 所示是图形类接口的 UMDL 表示。</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601102618570-289813809.gif" alt="" /><br />图2 Graph 接口</p>
<p>&nbsp;</p>
<h3>3. 类图</h3>
<p><strong>类图（ClassDiagram）</strong>是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p>
<p>类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。图 3 所示是&ldquo;计算长方形和圆形的周长与面积&rdquo;的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601102725594-169505579.gif" alt="" /></p>
<p style="text-align: center;">图3 &ldquo;计算长方形和圆形的周长与面积&rdquo;的类图</p>
<h2 style="text-align: center;"><br />类之间的关系</h2>
<p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。<strong>根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</strong></p>
<h3><br />1. 依赖关系</h3>
<p><strong>依赖（Dependency）</strong>关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>
<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601102902042-400367339.gif" alt="" /></p>
<p style="text-align: center;">图4 依赖关系的实例</p>
<h3><br />2. 关联关系</h3>
<p><strong>关联（Association）</strong>关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>
<p>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p>
<p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。图 5 所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601103047372-957677193.gif" alt="" /></p>
<p style="text-align: center;">图5 关联关系的实例</p>
<h3><br />3. 聚合关系</h3>
<p><strong>聚合（Aggregation）</strong>关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p>
<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>
<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。图 6 所示是大学和教师的关系图。</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601103130388-1178336813.gif" alt="" /></p>
<p style="text-align: center;">图6 聚合关系的实例</p>
<h3><br />4.组合关系</h3>
<p><strong>组合（Composition）</strong>关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。图 7 所示是头和嘴的关系图。</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601103237931-1187698623.gif" alt="" /></p>
<p style="text-align: center;">图7 组合关系的实例</p>
<h3><br />5.泛化关系</h3>
<p><strong>泛化（Generalization）</strong>关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。</p>
<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如图 8 所示。</p>
<p>泛化关系的实例</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601103337399-1799214524.gif" alt="" /><br />图8 泛化关系的实例</p>
<h3>6.实现关系</h3>
<p><strong>实现（Realization）</strong>关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>
<p>实现关系的实例</p>
<p style="text-align: center;"><img src="https://img2018.cnblogs.com/blog/1444343/201906/1444343-20190601103418976-1695239117.gif" alt="" /><br />图9 实现关系的实例</p>
<p>上述介绍了UML建模中的常见的属性，UML是一门可以深入研究的语言模式。这里只是简单的概述了其内容。以便以后查阅方便。</p>]]></description></item><item><title>23种设计模式</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/01/10957708.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 01 Jun 2019 01:31:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/06/01/10957708.html</guid><description><![CDATA[<h2 style="text-align: center;">23种设计模式简介</h2>
<h3>1. 根据目的来分</h3>
<p>根据模式是用来<strong>完成什么工作</strong>来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。</p>
<p><br /><strong>创建型模式：</strong>用于描述&ldquo;怎样创建对象&rdquo;，它的主要特点是&ldquo;将对象的创建与使用分离&rdquo;。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p>
<p><br /><strong>结构型模式：</strong>用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p>
<p><br /><strong>行为型模式：</strong>用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p>
<h3><br />2. 根据作用范围来分</h3>
<p>根据模式是主要用于<strong>类</strong>上还是主要用于<strong>对象</strong>上来分，这种方式可分为类模式和对象模式两种。</p>
<p><br /><strong>类模式：</strong>用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。设计模式中的<strong>工厂方法、（类）适配器、模板方法、解释器</strong>属于该模式。</p>
<p><br /><strong>对象模式：</strong>用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。设计模式中除了以上 4 种，其他的都是对象模式。</p>
<p>&nbsp;</p>
<h3>3. GoF的23种设计模式的功能</h3>
<p>前面说明了设计模式的 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p>
<p><strong>创建型模式：</strong></p>
<ol>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>


</ol>
<p><strong>结构型模式：</strong></p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>


</ol>
<p><strong>行为型模式：</strong></p>
<ol>
<li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>


</ol>
<p>需要强调的是，这 23 种设计模式<strong>不是孤立存在的，很多模式之间存在一定的关联关系</strong>，在大的系统开发中常常同时使用多种设计模式，大家必须要认真学好它们。</p>]]></description></item><item><title>面向对象设计模式总结</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/05/31/10957617.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 31 May 2019 13:30:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/05/31/10957617.html</guid><description><![CDATA[<h2 style="text-align: center;">软件设计模式的产生背景</h2>
<p>这一篇是后面学习的基础，它从整体上介绍软件设计模式的概念与特点、软件设计模式的基本要素，以及设计模式的由来。</p>
<p>&nbsp;</p>
<p>&ldquo;设计模式&rdquo;这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p>
<p>1977 年，美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫&middot;亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p>
<p>1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。</p>
<p>1987 年，肯特&middot;贝克（Kent Beck）和沃德&middot;坎宁安（Ward Cunningham）首先将克里斯托夫&middot;亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。</p>
<p>直到 1990 年，软件工程界才开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。</p>
<p>1995 年，艾瑞克&middot;伽马（ErichGamma）、理査德&middot;海尔姆（Richard Helm）、拉尔夫&middot;约翰森（Ralph Johnson）、约翰&middot;威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的&ldquo;四人组&rdquo;（Gang of Four，GoF）匿名著称。</p>
<p>&nbsp;</p>
<h2 style="text-align: center;">软件设计模式的概念与意义</h2>
<h3>1. 软件设计模式的概念</h3>
<p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p>
<h3>2. 学习设计模式的意义</h3>
<p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。</p>
<ul>
<li>可以提高程序员的思维能力、编程能力和设计能力。</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ul>
<p>当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p>
<h2 style="text-align: center;">软件设计模式的基本要素</h2>
<p>软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：<strong>模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式</strong>等，其中最关键的元素包括以下 4 个主要部分。</p>
<h3>1. 模式名称</h3>
<p>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p>
<h3>2. 问题</h3>
<p>问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p>
<h3>3. 解决方案</h3>
<p>模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的组合）来解决这个问题。</p>
<h3>4. 效果</h3>
<p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</p>
<p>&nbsp;</p>]]></description></item><item><title>大数据学习路线</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/22/10581017.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 22 Mar 2019 13:17:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/22/10581017.html</guid><description><![CDATA[<h1 style="text-align: center;">大数据学习路线</h1>
<blockquote>云计算 大数据 物联网 人工智能的时代已经到来。</blockquote>
<p>或许我们昨天还在畅想着未来，可是不知不觉，那个被我们畅想的未来已经悄然降临。不断的改变我们身边的方方面面。</p>
<p>我们必须跟上时代，才能不被时代所抛弃。</p>
<p>新时代人工智能的出现，让人类担心是否会被替代，我觉得大家大可不用担心。学习是我们人类天赋，只要你肯学习，就不会被取代。</p>
<p>当然我们也不能盲目的学，要有目标，有计划</p>
<p>我给大家分享一下学习大数据的学习路线。</p>
<blockquote>这只是比较粗犷的阶段，我后面会继续分享我学习的经验。也希望大家可以分享分享自己的学习路程！！！</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/261fdf29a39445fba1fe5cfa92d6f7ce" alt="" data-ic="false" data-ic-uri="" data-height="300" data-width="540" data-story_id="0" data-image_ids="[]" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h2>阶段一：Java语言基础</h2>
<p>Java开发介绍 熟悉Eclipse开发工具 Java语言基础 Java控制流程 Java字符串 Java数组与类和对象 数字处理类与核心技术 I/O与反射 多线程 Swing程序类</p>
<p>为啥要学Java？Java太难 学python不行么？</p>
<p>python也肯定要学的，但是你知不知道大数据生态系统Hadoop是Java写的。里面的大部分接口都是Java语言写的，所以Java是必学的，Java会了python学起来就快多了。</p>
<h2>阶段二：HTML CSS与JS</h2>
<p>HTML5与CSS3基础知识，WebApp页面布局。原生Java交互功能开发 Ajax异步交互 jQury应用这些都是基础。用于再网上收集数据，分析数据的必备基础知识。</p>
<h2>阶段三：JavaWeb和数据库</h2>
<p>数据库基本知识 JavaWeb开发核心 Java Web开发内幕 同前端一样，数据库也是大数据学习必不可少的一个基础本领，数据的存放提取和数据的一些基本的增删改查。</p>
<h2>阶段四：Linux和Hadoop体系</h2>
<p>Linux体系，Hadoop离线计算Map Reduce 分布式数据库 HDFS Hbase 数据仓库Hive 数据迁移工具Sqoop Flume分布式日志框架等一些Hadoop生态系统里面的组件，都是处理大数据集的利器。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/ad2779c8d52c4e81a0c766a6fa0f262a" alt="" data-ic="false" data-ic-uri="" data-height="220" data-width="395" data-story_id="0" data-image_ids="[]" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>前面这些大家可以没事的时候自主学习，然后后面的阶段可能不能继续更好的练习，大家以后进了公司可以进一步的加以学习。</blockquote>
<h2>阶段五：实战（一线公司真实项目）</h2>
<p>数据获取 数据处理 数据分析 数据展现和数据应用</p>
<h2>阶段六：spark生态系统</h2>
<p>这一阶段学习的东西就比较高端了。。。</p>
<p>python编程语言 Scala编程语言（有了前面的Java编程语言的基础这些学起来都快）spark大数据处理 Spark-Milb机器学习 Spark-Graphx图计算</p>
<p>实战（基于Spark的推荐系统：一线公司真实项目）</p>
<h2>阶段七：Storm生态系统</h2>
<p>。。。。。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/6780a92b2c354137a3802091c83f1397" alt="" data-ic="false" data-ic-uri="" data-height="300" data-width="533" data-story_id="0" data-image_ids="[]" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>技术是不断进步不断更新的，所以学习是没有止境的。</p>
<p>现在学的以后或许都用不上了，但是我们那学习的初心却永不停歇。</p>
<p>历史的滚轮不断向前，那是一代代人的共同努力的结果。</p>]]></description></item><item><title>软考自查：数据结构及算法应用</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/04/10469692.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 04 Mar 2019 03:30:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/04/10469692.html</guid><description><![CDATA[<div id="scontent">
<div id="preview-pgc" class="wrap1 sclearfix">
<div id="preview-content" class="center">
<div class="container-main">
<div class="article-detail">
<div class="article-content">
<h1 style="text-align: center;">数据结构及算法应用</h1>
<h2>内容提要</h2>
<ul>
<li>分治法</li>
<li>回溯法</li>
<li>贪心法</li>
<li>动态规划法</li>
</ul>
<hr />
<h2 style="text-align: left;">分治法</h2>
<blockquote>
<p>对于一个规模为n的问题,若该问题可以容易地解决(比如说规模n较小)则直接解决;否则将其分解为k个规模较小的子问题,这些子问题互相独立且与原问题形式相同,递归地解这些子问题,然后将各子问题的解合并得到原问题的解。</p>
<p>该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>该问题可以分解为若干个规模较小的相同问题</p>
<p>利用该问题分解出的子问题的解可以合并为该问题的解</p>
<p>该问题所分解出的各个子问题是相互独立的</p>
</blockquote>
<ul>
<li>分解</li>
<li>解决</li>
<li>合并</li>
</ul>
<hr />
<h3>分治法-递归技术</h3>
<p>递归，就是在运行的过程中调用自己</p>
<pre class="source-code"><code>int F(int n)
{
 if(n=0) return 1;
 if(n=1) return 1;
 if(n&gt;1) return F(n-1)+F(n-2);
}
</code></pre>
<div class="pgc-img"><img src="http://p3.pstatp.com/large/pgc-image/4a4956b28c60458c88d0b9615ea26f85" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<h3>分治法-二分法查找</h3>
<pre class="source-code"><code>function Binary_Search(L,a,b,x) {
 if(a&gt;b) return(-1);
 else {
 m=(a+b)/2;
 if(x=L [m]) return(m);
 else if(x&gt;L[m])
 return(Binary_Search(L,m+1,b,x));
 else
 return(Binary_Search(L,a,m-1,x));
 }
}
</code></pre>
<hr />
<h2>回溯法</h2>
<blockquote>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。这种走不通就退回再走的技术就是回溯法。</p>
</blockquote>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/d3e0fbbba07f4483b7cc57a28d4f2c44" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p3.pstatp.com/large/pgc-image/1cc92b0b14af4e7689844a1c3763d4c6" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<hr />
<h2>贪心法</h2>
<blockquote>
<p>总是做出在当前来说是最好的选择,而并不从整体上加以考虑,它所做的每步选择只是当前步骤的局部最优选择,但从整体来说不一定是最优的选择。由于它不必为了寻找最优解而穷尽所有可能解,因此其耗费时间少,一般可以快速得到满意的解,但得不到最优解。</p>
</blockquote>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/d46499d3e58542419df380df097b812e" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<hr />
<h2>动态规划法</h2>
<blockquote>
<p>在求解问题中,对于每一步决策,列出各种可能的局部解,再依据某种判定条件,舍弃那些肯定不能得到最优解的局部解,在每步都经过筛选,以每一步都是最优解来保证全局是最优解。</p>
</blockquote>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/9b2ce04b1b2845609928769b981f5c67" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<hr />
<h2>例题</h2>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/888caa66cb794c639bd7924b239869b1" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/0437e7adaeb14d12aa412804eb16de6f" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/efe10c8016c44b0db0cffe3894cfce8b" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p3.pstatp.com/large/pgc-image/6ec578a29c714319b706e82e4cd38d91" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/b019fd8a80d842418d0065772e41f8ab" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<pre class="source-code"><code>(1)j=0
(2)b[j]=b[j]+s[i]
(3)min=temp
(4)b[m]=b[m]+s[i]
</code></pre>
<h2>例题2</h2>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/60bcc990856c4450ae2e394e66a8940a" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p3.pstatp.com/large/pgc-image/0f9443699bb340a2a15b19f4708bb059" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/0868348c6e804a1194e9d51389523cc6" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p3.pstatp.com/large/pgc-image/0c8abc5863cf45b5a9fb1f8f499ca5d4" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/8bac3862b4dc4c40b2daf48d9ef27fda" alt="" />
<p class="pgc-img-caption">&nbsp;</p>
</div>
<blockquote>
<p>更多软考自查在我的&ldquo;随笔&rdquo;中查看！！！</p>
</blockquote>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sfoot_p">&nbsp;</div>]]></description></item><item><title>软考自查：面向对象设计</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/04/10469308.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 04 Mar 2019 02:38:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/04/10469308.html</guid><description><![CDATA[<h1>面向对象程序设计</h1>
<h1>内容提要</h1>
<ul>
<li>C++及Java语法要点</li>
<li>设计模式程序实现</li>
<li>C++ - 类与派生类的定义</li>
</ul>
<p>&nbsp;</p>
<hr />
<h1>C++ - 类与派生类的定义</h1>
<pre>class类名
{
&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;公有数据成员或公有函数成员的定义;
&nbsp;&nbsp;protected:&nbsp;
&nbsp;&nbsp;&nbsp;保护数据成员或保护函数成员的定义;
&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;私有数据成员或私有函数成员的定义;
};
</pre>
<p>&nbsp;</p>
<pre>class派生类名:继承方式1 基类名1,继承方式2 基类名2...&nbsp;
{
&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;派生类的私有数据和函数
&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;派生类的公有数据和函数
&nbsp;&nbsp;protected:
&nbsp;&nbsp;&nbsp;派生类的保护数据和函数
};
</pre>
<p>&nbsp;</p>
<h1>C++ - 构造函数与析构函数</h1>
<p>构造函数相对于般函数来说,具有如下特殊的性质:</p>
<blockquote>构造函数的函数名必须与定义它的类同名。构造函数没有返回值。如果在构造函数前加void是错误的。构造函数被声明定义为公有函数。构造函数在建立对象时由系统自动调用。</blockquote>
<p>构造函数相对于一般函数来说,具有如下特殊的性质:</p>
<blockquote>析构函数没有任何参数,不能被重载,但可以是虚函数,一个类只有一个析构函数。析构函数没有返回值。析构函数名与类名相同,但在类名前加上一个逻辑非运算符"~" ,以示与构造函数对比区别。析构函数一般由用户自己定义,在对象消失时由系统自动调用,如果用户没有定义析构函数,系统将自动生成一个不做任何事的默认析构函数。</blockquote>
<h1>C++ - 对象指针与对象引用</h1>
<p>对象指针的语法定义形式如下:</p>
<p>类名 *对象指针名;</p>
<p>&nbsp;</p>
<p>对象引用的定义形式如下:</p>
<p>类名 &amp;对象引用名=被引用对象;</p>
<p>&nbsp;</p>
<blockquote>注意:通过对象名或对象引用访问对象的成员,使用的运算符是&ldquo;.&rdquo;;而使用对象指针访问对象的成员,使用的运算符是"-&gt;"。如:对象指针名-&gt;数据成员名或:对象指针名-&gt;成员函数名(参数表)。</blockquote>
<h1>C++ - 虚函数</h1>
<p>虚函数定义的一般语法形式如下:</p>
<pre>virtual 函数类型 函数名 (形参表)&nbsp;
{
&nbsp;&nbsp;函数体;
}
</pre>
<p>纯虚函数定义形式如下:</p>
<pre>virtual 函数名= 0;
</pre>
<h1>JAVA - 类的定义</h1>
<p>类的定义格式如下:</p>
<pre>[import包]
[类修饰符]class xxxclass [extends超类](implements 接口]&nbsp;
{
&nbsp;&nbsp;public:
&nbsp;&nbsp;&nbsp;公有数据成员或公有函数成员的定义;
&nbsp;&nbsp;protected:
&nbsp;&nbsp;&nbsp;保护数据成员或保护函数成员的定义;
&nbsp;&nbsp;private:
&nbsp;&nbsp;&nbsp;私有数据成员或私有函数成员的定义;
}
</pre>
<p>说明:</p>
<blockquote>import包:引入包中的类。类修饰符:主要有四个修饰符, public、abstract、 final、private。class为关键字, xxxclass为类名,命名遵循Java标识符的命名规则。extends为继承关键字,implements为接口关键字。</blockquote>
<h1>JAVA - 接口的定义</h1>
<pre>interface IFactory{}
class SqlServerFactory implements IFactory
</pre>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>例题：</h1>
<pre>import java.util.* ;
(1)class Beverage {&nbsp;//饮料
String description = "Unknown Beverage";
public(2)( ){return description;}
&nbsp;&nbsp;&nbsp;public(3);
}
abstract class CondimentDecorator extends Beverage
{//配料
&nbsp;(4);
}
</pre>
<blockquote>(1)abstract</blockquote>
<blockquote>(2)String getDescription</blockquote>
<blockquote>(3)abstract int cost ( )(</blockquote>
<blockquote>4)Beverage beverage</blockquote>
<h1>例题</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/d8fc841fb0334a72ba00b8186b247534" alt="" data-ic="false" data-ic-uri="" data-height="706" data-width="1128" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/5a1b791fcced46ef907104ddf7ef21ed" alt="" data-ic="false" data-ic-uri="" data-height="661" data-width="1122" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/e82bdec300ea4283899a47cbcd2c5437" alt="" data-ic="false" data-ic-uri="" data-height="510" data-width="1146" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>（1）void Insert(Department department)（</blockquote>
<blockquote>2）Department GetDepartment(int id）</blockquote>
<blockquote>（3）implements IDepartment</blockquote>
<blockquote>（4）implements IDepartment</blockquote>
<blockquote>（5）interface IFactory</blockquote>
<blockquote>（6）Idepartment CreateDepartment()</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/3d4aafe4570a43828ff689d4ca8ccca9" alt="" data-ic="false" data-ic-uri="" data-height="707" data-width="1134" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/3a850242ebc94e7080440a98196a5276" alt="" data-ic="false" data-ic-uri="" data-height="661" data-width="1129" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/7751a6bae7174987ad097a8849797319" alt="" data-ic="false" data-ic-uri="" data-height="653" data-width="1142" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/8dc42ff3acb344468a0f283fbbb1b1f3" alt="" data-ic="false" data-ic-uri="" data-height="459" data-width="1122" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>(1)interface</blockquote>
<blockquote>(2)void drawLine(double x1,double y1.double x2,double y2)</blockquote>
<blockquote>(3)void drawCircle(double x,double y,double r)</blockquote>
<blockquote>(4)DP1.draw_a_circle(x,y,r)</blockquote>
<blockquote>(5)DP2.drawcircle(x,y,r)</blockquote>
<blockquote>(6)abstract public void draw()</blockquote>
<p>&nbsp;</p>
<p>更多软考自查在我的&ldquo;文章&rdquo;中可以查看！！！</p>]]></description></item><item><title>软考自查：UML建模</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/03/10464952.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 03 Mar 2019 05:31:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/03/10464952.html</guid><description><![CDATA[<h1>UML建模</h1>
<h1>内容提要</h1>
<ul>
<li>用例图</li>
<li>类图与对象图</li>
<li>顺序图</li>
<li>活动图</li>
<li>状态图</li>
<li>通信图</li>
<li>构件图</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>用例图</h1>
<ul>
<li>包含关系</li>
<li>扩展关系</li>
<li>泛化关系</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/efa89827961a445e9c007ff720172205" alt="" data-ic="false" data-ic-uri="" data-height="674" data-width="771" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>类图与对象图</h1>
<ul>
<li>填类名，方法名，属性名</li>
<li>填多重度</li>
<li>填关系</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/312aeacd08c3473f8d74ca02d4384052" alt="" data-ic="false" data-ic-uri="" data-height="708" data-width="603" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>1: 表示一个集合中的一个对象对应另一个集合中1个对象。0..*:表示一个集合中的一个对象对应另一个集合中的0个或多个对象。(可以不对应)1..* :表示一个集合中的一个对象对应另一个集合中的一个或多个对象。(至少对应一个)* :表示一个集合中的一个对象对应另一个集合中的多个的对象。</blockquote>
<ul>
<li>依赖关系</li>
<li>泛化关系</li>
<li>关联关系</li>
<li>聚合关系</li>
<li>组合关系</li>
<li>实现关系</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/5563cceaceda45ca903f92501c917495" alt="" data-ic="false" data-ic-uri="" data-height="341" data-width="239" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>顺序图</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/13b4318b37834a7ab90c9612c5d8f3a9" alt="" data-ic="false" data-ic-uri="" data-height="660" data-width="1023" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>活动图</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/bb33bfa7c00146d9b7bf2422ea5515f7" alt="" data-ic="false" data-ic-uri="" data-height="629" data-width="1052" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/99af3efca2684050b94ea149cb698a6e" alt="" data-ic="false" data-ic-uri="" data-height="643" data-width="968" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>状态图</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/f5b51c2243f840fa9a233a82b829bdd8" alt="" data-ic="false" data-ic-uri="" data-height="532" data-width="983" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>通信图</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/19d580c4b98549b5887a88ad684525ae" alt="" data-ic="false" data-ic-uri="" data-height="606" data-width="1117" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>例题１</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/8262f11a9d1142a2ae57c9d387ecc2c0" alt="" data-ic="false" data-ic-uri="" data-height="582" data-width="1125" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/3b84c7be1f3d4167b03c87dd4b7955c1" alt="" data-ic="false" data-ic-uri="" data-height="756" data-width="1192" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/60df06af6da444be8c017af534fb3a61" alt="" data-ic="false" data-ic-uri="" data-height="589" data-width="1170" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/d0636664e2d0431abbd666e86ce58e2a" alt="" data-ic="false" data-ic-uri="" data-height="592" data-width="1137" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>例题２</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/ae357c8483624a76acd3ba030c674378" alt="" data-ic="false" data-ic-uri="" data-height="628" data-width="1155" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/cfda63ad09ba4649b4ad988ccc62faf4" alt="" data-ic="false" data-ic-uri="" data-height="686" data-width="1115" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/ab320cff49d24c83bc54694f04fabddc" alt="" data-ic="false" data-ic-uri="" data-height="449" data-width="1143" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/a445dd9fd87b401090349f94e1141873" alt="" data-ic="false" data-ic-uri="" data-height="763" data-width="1192" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/4fe9f6b1594344f5908fedff0aaa657e" alt="" data-ic="false" data-ic-uri="" data-height="727" data-width="1174" /></div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<blockquote>更多软考自查可在我的&ldquo;随笔&ldquo;中查看！！！</blockquote>]]></description></item><item><title>软考自查：数据库设计</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/03/10464843.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 03 Mar 2019 05:00:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/03/10464843.html</guid><description><![CDATA[<h1>数据库设计</h1>
<h1>内容提要</h1>
<ul>
<li>数据库设计过程</li>
<li>ER模型</li>
<li>答题技巧</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>数据库设计过程</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/9bde4afc999d4cdaa631e16d2072be0b" alt="" data-ic="false" data-ic-uri="" data-height="635" data-width="1024" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>ER模型－实体间联系类型</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/a258734f29044d4b9c2fe270bf280691" alt="" data-ic="false" data-ic-uri="" data-height="559" data-width="1099" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>E-R图向关系模型的转换</h1>
<p>转换的基本原则是：实体和联系分别转换成关系，属性则转换成相应关系的属性。</p>
<ul>
<li>一对一联系</li>
<li>一对多联系</li>
<li>多对多联系</li>
<li>多元联系</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>答题技巧</h1>
<p>详细分析试题说明</p>
<p>熟练掌握基本知识</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>试题</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/28ce4e88b89b4917864b1055e69e13a1" alt="" data-ic="false" data-ic-uri="" data-height="704" data-width="1155" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/fe3cc269f59d482aa9a45c0160875f75" alt="" data-ic="false" data-ic-uri="" data-height="651" data-width="1127" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/39d740db4e164b83abf737da4c343f68" alt="" data-ic="false" data-ic-uri="" data-height="612" data-width="1150" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/b1a0778b35b1405bb23ac50e4083d127" alt="" data-ic="false" data-ic-uri="" data-height="529" data-width="1146" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<blockquote>更多软考自查可在我的&ldquo;随笔&rdquo;中查看！！！
<p>&nbsp;</p>
</blockquote>]]></description></item><item><title>软考自查：数据流图（DFD）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/03/10464779.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 03 Mar 2019 04:37:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/03/10464779.html</guid><description><![CDATA[<h1 style="text-align: center;">数据流图（DFD）</h1>
<h2>内容提要</h2>
<ul>
<li>数据流图基本概念</li>
<li>数据字典</li>
<li>数据平衡原则</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>数据流图基本概念</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/1bc10ee98372468081d7ac3e21522c63" alt="" data-ic="false" data-ic-uri="" data-height="577" data-width="1097" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/662e031286ea4a57ba2cd986041966ef" alt="" data-ic="false" data-ic-uri="" data-height="598" data-width="971" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/3b3e8ead27d048b39218289f4a558609" alt="" data-ic="false" data-ic-uri="" data-height="527" data-width="1004" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>数据字典</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/53c0c601f31c487fba589470e5031de9" alt="" data-ic="false" data-ic-uri="" data-height="501" data-width="946" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>数据流图平衡原则</h2>
<h3>父图与子图之间的平衡</h3>
<p>子图内平衡</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/4a4a25fdaaa8445e8535fe4d5d12a46f" alt="" data-ic="false" data-ic-uri="" data-height="190" data-width="711" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/db79ec360db540fb8415853663758e86" alt="" data-ic="false" data-ic-uri="" data-height="301" data-width="589" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/021499e110214b6b9d19fadcd67e988d" alt="" data-ic="false" data-ic-uri="" data-height="554" data-width="722" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<hr />
<p>&nbsp;</p>
<h2>答题技巧</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/af338457e3314ac18611b4697053d588" alt="" data-ic="false" data-ic-uri="" data-height="631" data-width="1149" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>试题1</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/64e086796a2a41188e28b467c8f0d1c9" alt="" data-ic="false" data-ic-uri="" data-height="692" data-width="1155" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/e5cd53a219b34df78da130092bb69830" alt="" data-ic="false" data-ic-uri="" data-height="780" data-width="1182" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/0ecfc41ff1df471d8bc9ec63e2c5a470" alt="" data-ic="false" data-ic-uri="" data-height="681" data-width="1123" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/35f80eaa70d44342989eec8a2ec5e266" alt="" data-ic="false" data-ic-uri="" data-height="741" data-width="1158" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/c8086fa66e004b79be5a5cbea23ec99f" alt="" data-ic="false" data-ic-uri="" data-height="302" data-width="484" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>试题2</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/74228d7a3e2c4ad9a9fa49cd4e055f27" alt="" data-ic="false" data-ic-uri="" data-height="644" data-width="1153" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/427b820fc3464799af71585daae9506e" alt="" data-ic="false" data-ic-uri="" data-height="701" data-width="1170" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/c6869ca7ec0f48aba4282c8a7f28d82f" alt="" data-ic="false" data-ic-uri="" data-height="593" data-width="1158" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/0d2bf82bd2bc4116a710ecf03146b7c4" alt="" data-ic="false" data-ic-uri="" data-height="746" data-width="1164" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/db54d445604e444f80dc9ad0d4c0a589" alt="" data-ic="false" data-ic-uri="" data-height="788" data-width="994" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>]]></description></item><item><title>软考自查：多媒体基础知识</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/02/10460609.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 02 Mar 2019 05:07:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/02/10460609.html</guid><description><![CDATA[<h1>多媒体基础知识</h1>
<h2>内容提要</h2>
<ul>
<li>多媒体技术基本概念</li>
<li>多媒体相关计算问题</li>
<li>常见多媒体标准</li>
<li>数据压缩技术</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>多媒体技术基本概念-音频相关概念</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p6-tt.bytecdn.cn/large/pgc-image/cae3655e80ab4decab2247ef904be18b" alt="" data-ic="false" data-ic-uri="" data-height="569" data-width="1140" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h2>多媒体技术基本概念-图像相关概念</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/2e267af394ba43d4b3b0f48313482b17" alt="" data-ic="false" data-ic-uri="" data-height="527" data-width="1135" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/6764c7ad685a41c390568791f9a5db33" alt="" data-ic="false" data-ic-uri="" data-height="316" data-width="497" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><strong>彩色空间</strong></p>
<ul>
<li>RGB&nbsp;</li>
<li>YUV(电视，兼容）</li>
<li>CMY(CMYK)</li>
<li>HSV(HSB)</li>
</ul>
<h2>多媒体技术基本概念-媒体的种类</h2>
<blockquote>感觉媒体:指人们接触信息的感觉形式。如:视觉、听觉、触觉嗅觉和味觉等。表示媒体:指信息的表示形式。如:文字、图形、图像、动画、音频和视频等。显示媒体(表现媒体):表现和获取信息的物理设备。如:输入显示媒体键盘、鼠标和麦克风等;输出显示媒体显示器、打印机和音箱等。存储媒体:存储数据的物理设备,如磁盘、光盘和内存等。传输媒体:传输数据的物理载体，如电缆、光缆和交换机设备等。</blockquote>
<h2>多媒体技术基本概念-多媒体相关计算问题</h2>
<p>1、图像容量计算</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/1c9a29df04764be8ad94e8c32bd88305" alt="" data-ic="false" data-ic-uri="" data-height="244" data-width="1123" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>2、音频容量计算</p>
<p>容量=采样频率（HZ）*量化/采样位数（位）*声道数/8</p>
<p>3、视频容量计算</p>
<p>容量=每帧图像容量（Byte）*每秒帧数*时间+音频容量*时间</p>
<blockquote>1.图像容量计算实例某数码相机内置128MB的存储空间,拍摄分辨率设定为1600x1200像素,颜色深度为24位,若不采用压缩存储技术，使用内部存储器最多可以存储(D)张照片。(1)A.12&nbsp;B.22&nbsp;C.13&nbsp;D.23</blockquote>
<p>1600*1200*3=5760000，5760000/1024/1024=5.493，128/5.493=23.3</p>
<blockquote>2.音频容量计算实例CD上声音的采样频率为44.1kHz ,样本精度为16bit ,双声道立体声,那么其未经压缩的数据传输率为C 。A.88.2kb/s&nbsp;B.705.6kb/sC.1411.2kb/s&nbsp;D.1536.0kb/s</blockquote>
<p>44.1*16*2=1411.2kb</p>
<blockquote>3.视频容量计算实例若视频图像每帧的数据量为6.4MB ,帧速率为30帧/秒,则显示10秒的视频信息,其原始数据量为D MB。A.64&nbsp;B.192&nbsp;C.640&nbsp;D.1920</blockquote>
<p>6.4*30*10=1920</p>
<h2>常见多媒体标准</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p6-tt.bytecdn.cn/large/pgc-image/fc183da60fe448dfb5950e5be27458d0" alt="" data-ic="false" data-ic-uri="" data-height="682" data-width="1174" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>数据压缩基础</h2>
<ul>
<li>空间冗余（几何冗余）</li>
<li>时间冗余</li>
<li>视觉冗余</li>
<li>信息熵冗余</li>
<li>结构冗余</li>
<li>知识冗余</li>
</ul>
<h2>有损压缩与无损压缩</h2>
<p>一类是无损压缩编码法（Lossless compression coding),也称冗余压缩法或熵编码法；另一类是有损压缩编码法（Loss compression coding),也称为熵压缩法。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/758fcf65b91a4454a86e62cd8f401adb" alt="" data-ic="false" data-ic-uri="" data-height="508" data-width="978" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>更多软考自查可在我的&ldquo;随笔&rdquo;中可以查看！！！</blockquote>]]></description></item><item><title>软考自查：法律法规与标准化知识</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/02/10460476.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sat, 02 Mar 2019 04:15:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/02/10460476.html</guid><description><![CDATA[<h1>法律法规与标准化知识</h1>
<h1>内容提要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</h1>
<p>从所涉及的法律法规角度</p>
<ul>
<li>著作权法</li>
<li>计算机软件保护条例</li>
<li>商标法</li>
<li>专利法</li>
</ul>
<p>从试题考点分布的角度</p>
<ul>
<li>保护期限</li>
<li>知识产权人确定</li>
<li>侵权判断</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>知识产权</h1>
<ul>
<li>著作权及邻接权;</li>
<li>专利权;</li>
<li>工业品外观设计权;</li>
<li>商标权;</li>
<li>地理标志权</li>
<li>集成电路布图设计权</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>法律法规-保护期限</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/8b57b07270d44b35aeb4d6aa426e87e4" alt="" data-ic="false" data-ic-uri="" data-height="671" data-width="1120" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>法律法规-知识产权人确定</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/e63e8020d7354213838910e0cff52097" alt="" data-ic="false" data-ic-uri="" data-height="630" data-width="1033" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/1633b70caf0046569d0d0e09d8a2bee9" alt="" data-ic="false" data-ic-uri="" data-height="470" data-width="1062" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>侵权判定</h1>
<p>中国公民、法人或者其他组织的作品，不论是否发表,都享有著作权。</p>
<p>&nbsp;</p>
<p>开发软件所用的思想、处理过程、操作方法或者数学概念不受保护</p>
<p>&nbsp;</p>
<blockquote>著作权法不适用于下列情形:法律、法规，国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文;时事新闻;历法、通用数表、通用表格和公式。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/8706879401d14cf3a4bc226e0487c98a" alt="" data-ic="false" data-ic-uri="" data-height="470" data-width="1045" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>标准化基础知识-标准的分类</h1>
<ul>
<li>国际标准:ISO、IEC等国际标准化组织</li>
<li>国家标准:GB-中国、ANSI-美国、BS-英国、JIS一日本</li>
<li>区域标准:又称为地区标准,如PASC-太平洋地区标准会议、CEN-欧洲标准委员会、ASAC-亚洲标准咨询委员会、ARSO非洲地区标准化组织</li>
<li>行业标准:GJB-中国军用标准、MIT-S-美国军用标准、 IEEE-美国电气电子工程师协会</li>
<li>地方标准:国家的地方-级行政机构制订的标准</li>
<li>企业标准</li>
<li>项目规范</li>
</ul>
<h1>标准化基础知识-标准的编号</h1>
<ul>
<li>国际、国外标准代号:标准代号+专业类号+顺序号+年代号</li>
<li>我国国家标准代号:强制性标准代号为GB推荐性标准代号为GB/T，指导性标准代号为GB/Z、实物标准代号GSB</li>
<li>行业标准代号:由汉语拼音大写字母组成(如电子行业为SJ )</li>
<li>地方标准代号:由DB加上省级行政区划代码的前两位</li>
<li>企业标准代号:由Q加上企业代号组成</li>
</ul>
<blockquote>更多软考自查在我的&ldquo;随笔&rdquo;可以查看！！！</blockquote>]]></description></item><item><title>软考自查：程序设计语言与语言处理程序基础</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/01/10458382.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 01 Mar 2019 11:34:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/03/01/10458382.html</guid><description><![CDATA[<h1>程序设计语言与语言处理程序基础</h1>
<h1>内容提要</h1>
<ul>
<li>编译与解释</li>
<li>文法</li>
<li>正规式</li>
<li>有限自动机</li>
<li>表达式</li>
<li>传值与传址</li>
<li>多种程序语言特点</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>编译过程</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/0d545e7851e84d8cbdbda4ddf6b9da79" alt="" data-ic="false" data-ic-uri="" data-height="652" data-width="1148" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>文法定义</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/b33d30c02d3845be93964d2e63e688be" alt="" data-ic="false" data-ic-uri="" data-height="547" data-width="1047" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/0e83680860af4d5599b0b4aa60891751" alt="" data-ic="false" data-ic-uri="" data-height="525" data-width="1086" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>语法推导树</h1>
<p>一棵语法树应具有以下特征:</p>
<blockquote>1、每个结点都有一一个标记，此标记是V的一个符号；2、根的标记是S;3.若一结点n至少有一个它自己除外的子孙，并且有标记A,则A肯定在VN中:4如果结点n的直接子孙，从左到右的次序是结点n1， n2，..nk，其标记分别是:A1，A2，...，Ak那么A-&gt;A1，A2，...Ak，一定是P中的一个产生式。</blockquote>
<p>例:</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/22c8ceac37a2454ba7b3a26c828e7737" alt="" data-ic="false" data-ic-uri="" data-height="328" data-width="1112" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>有限自动机（重点）</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/c739e78cde254f359832b8ba917d9a4b" alt="" data-ic="false" data-ic-uri="" data-height="326" data-width="1118" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/a1754f7325db474c951ec1a44d9ebbc7" alt="" data-ic="false" data-ic-uri="" data-height="298" data-width="541" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>正规式</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/f4a91c5c04c4427bbc2ebdcc1db5b9f5" alt="" data-ic="false" data-ic-uri="" data-height="528" data-width="1095" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>文法推导与正规式例题</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/783d22830a8d418ea323f0c7137d549f" alt="" data-ic="false" data-ic-uri="" data-height="395" data-width="1114" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>（1）：D （2）：C</blockquote>
<h1>有限自动机例题</h1>
<p>例题：</p>
<blockquote>下图所示为一个有限自动机（其中，A是初态、C是终态），该自动机可识别（C）。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/f8a86d0d93ca4b07958dd0be85c269e4" alt="" data-ic="false" data-ic-uri="" data-height="306" data-width="560" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<blockquote>A：００００　B：１１１１　C：０１０１　D：１０１０</blockquote>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>程序语言基础－表达式</h1>
<ul>
<li>前缀表达式（＋ａｂ）</li>
<li>中缀表达式（ａ＋ｂ）</li>
<li>后缀表达式（ａｂ＋）</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/25ca9454ca064a9aab0e838aeade4cc5" alt="" data-ic="false" data-ic-uri="" data-height="182" data-width="258" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>例题：</p>
<blockquote>表达式（ａ－ｂ）＊（ｃ＋５）的后缀式是（D）。A：ａ　ｂ　ｃ　５　＋　＊　－B：ａ　ｂ　－　ｃ　＋　５　＊C：ａ　ｂ　ｃ　－　＊　５　＋D：ａ　ｂ　－　ｃ　５　＋　＊</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/3dcd8fae3e254ecb9d3300e35eddebe9" alt="" data-ic="false" data-ic-uri="" data-height="289" data-width="613" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>函数调用－传值与传址</h1>
<p>（重点）</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/90a375d097954497a8da32150a670732" alt="" data-ic="false" data-ic-uri="" data-height="286" data-width="651" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/cedd3e28a23745229fc2731acc73d7bd" alt="" data-ic="false" data-ic-uri="" data-height="286" data-width="1117" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>函数的调用</h1>
<p>传值</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/89c7ff71739d4fd6a90a18c8a0d8b01c" alt="" data-ic="false" data-ic-uri="" data-height="444" data-width="736" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<blockquote>输出结果是：４　３　３　４</blockquote>
<p>传址</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/4c68ea3bee524f87a9289b594ad403cb" alt="" data-ic="false" data-ic-uri="" data-height="459" data-width="498" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>输出结果：４　３　４　３</blockquote>
<h1>函数的调用</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/2ecd0aff7c3d4743a05e49ae54d39346" alt="" data-ic="false" data-ic-uri="" data-height="420" data-width="1078" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>程序语言基础－各种程序语言特点</h1>
<blockquote>1.Fortran语言(科学计算,执行效率高)2.Pascal语言(为教学而开发的,表达能力强, Delphi )3.C语言(指针操作能力强，高效)4.Lisp语言(函数式程序语言，符号处理，人工智能5.C++语言(面向对象，高效)6.Java语言(面向对象,中间代码,跨平台)7.C#语言(面向对象,中间代码,.Net)8.Prolog语言(逻辑推理,简洁性,表达能力,数据库和专家系统)９.python语言（面向对象，简单易懂，人工智能，大数据，现上升较快）</blockquote>
<p>&nbsp;</p>
<blockquote>更多软考自查可在我的&rdquo;随笔&ldquo;中查看！！！</blockquote>]]></description></item><item><title>软考自查-信息安全基础知识</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/28/10452163.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 28 Feb 2019 10:18:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/28/10452163.html</guid><description><![CDATA[<h1>系统安全分析与设计</h1>
<h1>内容提要</h1>
<ul>
<li>信息系统安全属性</li>
<li>加密算法</li>
<li>网络安全</li>
<li>防火墙技术</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>信息系统安全属性</h1>
<p>安全属性</p>
<ul>
<li>保密性:最小授权原则、防暴露、信息加密、物理保密</li>
<li>完整性:安全协议、校验码、密码校验、数字签名、公证</li>
<li>可用性:综合保障( IP过滤、业务流控制、路由选择控制、审计跟踪)</li>
<li>不可抵赖性:数字签名</li>
</ul>
<h1>对称加密技术</h1>
<p>缺陷：</p>
<p>1、加密强度不高</p>
<p>2、密钥分发困难</p>
<p>&nbsp;</p>
<p>常见对称密钥加密算法:</p>
<blockquote>DES:替换+移位、56位密钥、64位数据块、速度快、密钥易产生3DES(三重DES) :两个56位的密钥K1、K2&nbsp;加密:K1加密-&gt;K2解密-&gt;K1加密&nbsp;解密:K1解密-&gt;K2加密-&gt;K1解密AES:高级加密标准Rijndael加密法,是美国联邦政府采用的一-种区块加密标准。这个标准用来替代原先的DES。对其要求是&ldquo;至少与3DES-样安全"。RC-5 : RSA数据安全公司的很多产品都使用了RC-5。IDEA算法: 128位密钥、64位数据块、比DES的加密性好、对计算机功能要求相对低，PGP。</blockquote>
<h1>非对称加密技术</h1>
<p>缺陷：加密速度慢</p>
<p>&nbsp;</p>
<p>常见非对称密钥加密算法:&nbsp;</p>
<blockquote>RSA:512位(或1024位)密钥、计算量极大、难破解Elgamal:其基础是Diffie-Hellman密钥交换算法ECC:椭圆曲线算法其它非对称算法包括: 背包算法、Rabin、D-H</blockquote>
<h1>信息摘要</h1>
<p>单向散列函数（单向Hash函数）、固定长度的散列值。</p>
<pre>常用的消息摘要算法有MD5，SHA等，市场上广泛使用的MD5，SHA算法的散列值分别为128和160位，由于SHA通常采用的密钥长度较长，因此安全性高于MD5。
</pre>
<h1>数字签名</h1>
<p>用数字化的方式，在发送的信息，用以数字化的方式进行签名。</p>
<p>正文摘要，对摘要签名发送过去。</p>
<h1>数字信封与PGP</h1>
<ul>
<li>发送方将原文用对称密钥加密传输，而将对称密钥用接收方公钥加密发送给对方。</li>
<li>接收方收到电子信封，用自己的私钥解密信封，取出对称密钥解密得原文。</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>PGP可用于电子邮件，也可以用于文件存储。采用了杂合算法，包括IDEA、RSA、MD5、ZIP数据压缩算法。</li>
<li>PGP承认两种不同的证书格式: PGP证书和X.509证书。</li>
<li>PGP证书包含PGP版本号、证书持有者的公钥、证书持有者的信息、证书拥有者的数字签名、证书的有效期、密钥首选的对称加密算法。</li>
<li>X.509证书包含证书版本、证书的序列号、签名算法标识、证书有效期、以下数据:证书发行商名字、证书主体名、主体公钥信息、发布者的数字签名。</li>
</ul>
<h1>练习题-设计邮件加密系统</h1>
<p>要求邮件加密方式传输（加密解密技术），邮件最大附件内容可达500MB（对称加密），发送者不可抵赖（数字签名），若邮件被第三方截获，第三方无法篡改（信息摘要技术）。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/7403013844af498aac6a1e2fbb7d2644" alt="" data-ic="false" data-ic-uri="" data-height="460" data-width="1074" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>网络安全-各个网络层次的安全保障</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/1d1fdfdba63b4c93a82f97e0f8c7415b" alt="" data-ic="false" data-ic-uri="" data-height="639" data-width="847" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<h1>网络安全-网络威胁与攻击</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/1c97c958fb6d4771bb48bfd7f73e9f85" alt="" data-ic="false" data-ic-uri="" data-height="502" data-width="1112" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/f7e00b3f735f4a65aa5fb59c39e8fcd8" alt="" data-ic="false" data-ic-uri="" data-height="627" data-width="1115" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>网络安全-防火墙</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/27292ef05c1f4c93a4295216896958c0" alt="" data-ic="false" data-ic-uri="" data-height="669" data-width="1125" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>更多软考自查在我的随笔可以查看！！！</blockquote>]]></description></item><item><title>软考自查：软件工程</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/28/10449519.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 28 Feb 2019 04:02:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/28/10449519.html</guid><description><![CDATA[<h1>软件工程</h1>
<h1>内容提要</h1>
<ul>
<li>软件开发模型</li>
<li>需求的分类</li>
<li>结构化设计</li>
<li>测试原则与类型</li>
<li>系统运行与维护</li>
<li>项目管理基础知识</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>软件开发模型</h1>
<ul>
<li>瀑布模型</li>
<li>演化模型</li>
<li>增量模型</li>
<li>螺旋模型</li>
<li>快速原型模型</li>
<li>喷泉模型</li>
<li>V模型</li>
</ul>
<p>&nbsp;</p>
<ul>
<li>迭代模型/迭代开发方法</li>
<li>快速应用开发</li>
<li>构建组装模型/基于构件的开发方法</li>
<li>统一过程/统一开发方法</li>
<li>敏捷开发方法</li>
<li>模型驱动的开发方法</li>
<li>基于架构的开发方法</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/0e5cf8d6a9984df49dec6e672fabfb2c" alt="" data-ic="false" data-ic-uri="" data-height="391" data-width="864" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件开发模型-瀑布模型（SDLC）</h1>
<p>（有缺陷：需求阶段难以把握）</p>
<ul>
<li>软件计划</li>
<li>需求分析</li>
<li>软件设计</li>
<li>程序编码</li>
<li>软件测试</li>
<li>运行维护</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/aba830bd8ffe43c8aa77edcbede94b57" alt="" data-ic="false" data-ic-uri="" data-height="568" data-width="1032" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件开发模型-其他经典模型</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/d2934e39daa64ee796d4284523682b07" alt="" data-ic="false" data-ic-uri="" data-height="590" data-width="754" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件开发模型-增量模型与螺旋模型</h1>
<p>每一个增量均发布一个可操作的产品</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/a86157709cff4fab863863fa010c9534" alt="" data-ic="false" data-ic-uri="" data-height="372" data-width="411" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>螺旋模型</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/e433a396dbc243c0885053ab53f25ed1" alt="" data-ic="false" data-ic-uri="" data-height="622" data-width="739" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件开发模型-其他经典模型</h1>
<p>V模型与喷泉模型</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/fe55915ef6434bf4ba2ca0a7dc24c81d" alt="" data-ic="false" data-ic-uri="" data-height="558" data-width="1131" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件开发模型-构件组装模型(CBSD)</h1>
<ul>
<li>构建组装模型</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/ecd972eb2ea44e4a9c8338917ce20f89" alt="" data-ic="false" data-ic-uri="" data-height="518" data-width="1089" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件开发模型-统一过程</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/9ebf10a17df44f6f995de8438568e879" alt="" data-ic="false" data-ic-uri="" data-height="567" data-width="1114" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件开发模型-敏捷开发方法</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/da3ae6a055374b5e986d8560e936ebae" alt="" data-ic="false" data-ic-uri="" data-height="660" data-width="1129" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<hr />
<p>&nbsp;</p>
<h1>信息系统开发方法</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/3eba3c13bfcc45f1b1032afe5ce2eb4b" alt="" data-ic="false" data-ic-uri="" data-height="656" data-width="1071" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>需求开发-需求分类与需求获取</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/7fb9bee1624648379a9008ccd884153b" alt="" data-ic="false" data-ic-uri="" data-height="547" data-width="950" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>结构化设计-基本原则</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/92cb527781224728922497bc213dda2f" alt="" data-ic="false" data-ic-uri="" data-height="570" data-width="997" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>结构化设计-内聚与耦合</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/c924c7803c104a6697c9723a688eebe3" alt="" data-ic="false" data-ic-uri="" data-height="314" data-width="924" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/51341b0f18784e7db9df7196754ec8ff" alt="" data-ic="false" data-ic-uri="" data-height="325" data-width="1098" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>软件测试-测试原则与类型</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/93012b375d064d6e829c2916ef8a0780" alt="" data-ic="false" data-ic-uri="" data-height="617" data-width="896" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件测试-测试用例设计</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/83e16e1dd3b540f898c3cc23c7a33071" alt="" data-ic="false" data-ic-uri="" data-height="519" data-width="999" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h1>软件测试-测试阶段</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/263c82fff412411192108db737c56fb7" alt="" data-ic="false" data-ic-uri="" data-height="531" data-width="1147" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<h1>软件测试-McCabe复杂度</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/d618c80cf35a4a2ebb6bbba7733c4c4d" alt="" data-ic="false" data-ic-uri="" data-height="577" data-width="874" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>系统运行与维护</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/0be5aa5bc22540c0886fa6573a06675e" alt="" data-ic="false" data-ic-uri="" data-height="426" data-width="1087" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>软件过程改进-CMMI</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/29482c5e196041059ed8c58fafd8dd3a" alt="" data-ic="false" data-ic-uri="" data-height="277" data-width="1013" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/e4c4dea0465144a0a1ffd60bcc60339e" alt="" data-ic="false" data-ic-uri="" data-height="292" data-width="1005" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h1>项目管理&nbsp;</h1>
<p><strong>九大知识领域</strong></p>
<ul>
<li>范围管理</li>
<li>时间管理</li>
<li>成本管理</li>
<li>质量管理</li>
<li>人力资源管理</li>
<li>沟通管理</li>
<li>风险管理</li>
<li>采购管理</li>
<li>整体管理</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/9df81aab7f3145f9815f716eaceeb0ff" alt="" data-ic="false" data-ic-uri="" data-height="539" data-width="693" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>例题：</p>
<blockquote>进度安排的常用图形描述方法有Gantt图和PERT图。Gantt图不能清晰地描述_A_;PERT图可以给出哪些任务完成后才能开始另一些任务。下图所示的PERT图中，事件6的最晚开始时间是_C_。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/5bbee7e6c1a1448a8c3235da4e6b6278" alt="" data-ic="false" data-ic-uri="" data-height="350" data-width="823" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>（1）A：每个任务从何时开始B:每个任务到何时结束C:每个任务的进展的情况D：各任务之间的依赖关系（2）A：0 B：3 C:10 D:11</blockquote>
<h1>项目管理-风险</h1>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/e473ea2e13384cfb8ad2ca0dc5a33986" alt="" data-ic="false" data-ic-uri="" data-height="274" data-width="586" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><strong>风险曝光度( Risk Exposure) : 计算方法是风险出现的概率乘以风险可能造成的损失。</strong></p>
<pre>设正在开发的软件项目可能存在一个未被发现的错误,而这个错误出现的概率是0.5% ,给公司造成的损失将是1000000元,那么这个错误的风险曝光度就应为1000000x0.5% = 5000元。
</pre>
<p>&nbsp;</p>]]></description></item><item><title>软考自查：数据结构与算法基础</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/27/10445858.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Wed, 27 Feb 2019 10:38:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/27/10445858.html</guid><description><![CDATA[<h2>数据结构与算法基础</h2>
<h3>内容提要</h3>
<ul>
<li>数组与矩阵</li>
<li>线性表</li>
<li>广义表</li>
<li>树与二叉树</li>
<li>图</li>
<li>排序与查找</li>
<li>算法基础及常见的算法</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>数组</h2>
<ol>
<li>数组类型：存储地址计算</li>
<li>一维数组a[n]：a[i]的存储地址为：a+i*len</li>
<li>二维数组a[m][n]：</li>
</ol>
<ul>
<li>a[i][j]的存储地址（按行存储）为：a+(i*n+j)*len</li>
<li>a[i][j]的存储地址（按列存储）为：a+(j*n+i)*len</li>
</ul>
<h3>稀疏矩阵</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/60f8235323314304b4dac050f8cb1e7d" alt="" data-ic="false" data-ic-uri="" data-height="586" data-width="1055" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><strong>例题</strong></p>
<blockquote>设有如下所示的三角矩阵A[0..8,1..8]，将该三角矩阵的非零元素（即行下标不小于列下标的所有元素）按行优先压缩存储在数组M[1..m]中，则元素A[i,j](0&lt;=i，j&lt;=i)存储在数组M的（A）中。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/dcf36d806e734bc494a0398d003d24a9" alt="" data-ic="false" data-ic-uri="" data-height="350" data-width="552" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/b3a36dd70d5c4cec8b691236500db2b0" alt="" data-ic="false" data-ic-uri="" data-height="228" data-width="822" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h2>数据结构的定义</h2>
<p>1.数据结构的概念</p>
<p>2.数据逻辑结构</p>
<p>线性结构</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/6abcd3d59bff48f9bd284856c25f193a" alt="" data-ic="false" data-ic-uri="" data-height="201" data-width="339" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>非线性结构（树形结构：无环路，图：有环路）</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/d48a7e2ce9044de8a4d99c784fa4c37e" alt="" data-ic="false" data-ic-uri="" data-height="253" data-width="603" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>线性表的定义</h2>
<p>1、线性表的概念</p>
<p>（a1,a2,...,a3)</p>
<p>2、线性表常见的两种存储结构</p>
<p>顺序存储结构（顺序表）</p>
<p>链式存储结构（链表）</p>
<h3>线性表</h3>
<p>顺序表</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/6a4513bc4e1145ecbb3a6151f6fcf5b2" alt="" data-ic="false" data-ic-uri="" data-height="81" data-width="546" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>链表</p>
<ul>
<li>单链表</li>
<li>循环链表</li>
<li>双向链表</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/b9613851769943f7b12dec026fd5efb4" alt="" data-ic="false" data-ic-uri="" data-height="487" data-width="643" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<h2>链表的基本操作</h2>
<ul>
<li>单链表删除结点</li>
<li>单链表插入结点</li>
<li>双向链表删除结点</li>
<li>双向链表插入结点</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/210035a60b0c48c5850c5dec52f455f2" alt="" data-ic="false" data-ic-uri="" data-height="679" data-width="620" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>线性表-顺序存储与链式存储对比</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/0d0f355a739b4ab7aae1fe1143294538" alt="" data-ic="false" data-ic-uri="" data-height="433" data-width="1043" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>线性表-队列与栈</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/fca9f69fd2184407a78fc43b92d2528d" alt="" data-ic="false" data-ic-uri="" data-height="486" data-width="459" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/7c43455b2b594cf8b38b5ee98f24fd4b" alt="" data-ic="false" data-ic-uri="" data-height="503" data-width="539" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>例题</p>
<blockquote>输出受限的双端队列是指元素可以从队列的两端输入，但只能从队列的一端输出，如下图所示，若有e1,e2,e3,e4依次进入输出受限的双端队列，则得不到输出序列（D）</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/cbc9a70beecd401c99f8c75554f7030d" alt="" data-ic="false" data-ic-uri="" data-height="150" data-width="630" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>A:e4,e3,e2,e1</p>
<p>B:e4,e2,e1.e3</p>
<p>C:e4,e3,e1,e2</p>
<p>D:e4,e2,e3,e1</p>
<h3>广义表</h3>
<p>广义表是n个表元素组成的有限序列,是线性表的推广。</p>
<p>通常用递归的形式进行定义，记做:LS (a0，a1，....，an)。</p>
<pre>注:其中LS是表名，ai是表元素，它可以是表(称做子表),也可以是数据元素(称为原子)。其中n是广义表的长度(也就是最外层包含的元素个数),n=0的广义表为空表;而递归定义的重数就是广义表的深度,直观地说，就是定义中所含括号的重数(原子的深度为0，空表的深度为1)。
</pre>
<p>基本运算:取表头head(Ls)和取表尾tail(Ls)。</p>
<pre>若有:LS1=(a,(b,c),(d,e))
head(LS1)=a
tail(LS1)=((b,c)，(d,e))
</pre>
<blockquote>例1,有广义表LS1=(a,(b,c),(d,e)),则其长度为?深度为?答案：长度为3，深度为2.例2,有广义表LS1= (a,(b,c)，(d,e))),要将其中的b字母取出,操作就为?答案：head（head（tail（LS1）））</blockquote>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>树与二叉树</h2>
<ul>
<li>结点的度</li>
<li>树的度</li>
<li>叶子结点</li>
<li>分支结点</li>
<li>内部结点</li>
<li>父结点</li>
<li>子结点</li>
<li>兄弟结点</li>
<li>层次</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/5473ed15ff094029b085de09a1978887" alt="" data-ic="false" data-ic-uri="" data-height="323" data-width="525" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>树与二叉树</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/4764d8542d1745a2b18dd93be64bf66e" alt="" data-ic="false" data-ic-uri="" data-height="367" data-width="639" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>二叉树的重要特性:</p>
<ol>
<li>在二叉树的第i层上最多有2^i-1个结点(i&gt;=1);</li>
<li>深度为k的二叉树最多有2k -1个结点(k&gt;=1);</li>
<li>对任何棵二叉树,如果其叶子结点数为n0,度为2的结点数为n2 ,则n0=n2+1。</li>
<li>如果对一棵有n个结点的完全二叉树的结点按层序编号(从第1层到log2nJ+1层，每层从左到右)，则对任一结点i(1&lt;=i&lt;=n)，有:</li>
</ol>
<ul>
<li>*如果i=1,则结点i无父结点，是二叉树的根;如果i&gt;1 ,则父结点是【i/2】;</li>
<li>*如果2i&gt;n,则结点为i叶子结点，无左子结点;否则，其左子结点是结点2i;</li>
<li>*如果2i+1&gt;n,则结点无右子叶点，否则,其右子结点是结点2i+1。</li>
</ul>
<h3>树与二叉树遍历</h3>
<ol>
<li>前序遍历 12457836</li>
<li>中序遍历 42785136</li>
<li>后序遍历 48752631</li>
<li>层次遍历 12345678</li>
</ol>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/b4a0cce753b84669a6c1e17c4e4c8c1b" alt="" data-ic="false" data-ic-uri="" data-height="356" data-width="339" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>树与二叉树-反向构造二叉树</h3>
<p>由前序序列为ABHFDECG；中序序列为HBEDFAGC构造二叉树。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/ce914ab6cd744d648d64c72f6f1d2692" alt="" data-ic="false" data-ic-uri="" data-height="568" data-width="998" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/a4493b4e84264fc79a24958422272f69" alt="" data-ic="false" data-ic-uri="" data-height="580" data-width="613" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>树与二叉树-树转二叉树</h3>
<ul>
<li>孩子结点-左子树结点</li>
<li>兄弟结点-右孩子结点</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/56f44bf4201a478fa7b9d3eb27c5fe0a" alt="" data-ic="false" data-ic-uri="" data-height="578" data-width="722" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>树与二叉树-查找二叉树</h3>
<ul>
<li>二叉排序树</li>
<li>左孩子小于根</li>
<li>右孩子大于根</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/4e1a5d3fc78544f295fee5038514c129" alt="" data-ic="false" data-ic-uri="" data-height="321" data-width="278" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>插入结点:①若该键值结点已存在,则不再插入，如: 48;②若查找二叉树为空树,则以新结点为查找叉树;③将要插入结点键值与插入后父结点键值比较,就能确定新结点是父结点的左子结点，还是右子结点。<br />删除结点:①若待删除结点是叶子结点，则直接删除;②若待删除结点只有一个子结点,则将这个子结点与待删除结点的父结点直接连接，如: 56 ;③若待删除的结点p有两个子结点,则在其左子树上,用中序遍历寻找关键值最大的结点s ,用结点s的值代替结点p的值,然后删除节点s ,节点s必属于上述①，②情况之一,如89。</blockquote>
<h3>树与二叉树-最优二叉树（哈夫曼树）</h3>
<p>（在多媒体的压缩方式经常使用：无损压缩）</p>
<p>需要了解的基本概念：</p>
<ul>
<li>树的路径长度</li>
<li>权</li>
<li>带权路径长度</li>
<li>树的带权路径长度(树的代价）</li>




</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/4d0eaba756124424826343591db454ec" alt="" data-ic="false" data-ic-uri="" data-height="326" data-width="541" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<blockquote>例题：假如有一组权值5，29，7，8，14，23，3，11请尝试构造哈夫曼树。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/b0bf63f34b0a4133bd83315339034b87" alt="" data-ic="false" data-ic-uri="" data-height="496" data-width="405" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<h3>树与二叉树-线索二叉树</h3>
<ul>
<li>为什么要有线索二叉树</li>
<li>线索二叉树的概念</li>
<li>线索二叉树的表示</li>
<li>如何将二叉树转化为线索二叉树</li>




</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/786ae42a54cb4bd38796c8da0579a4ee" alt="" data-ic="false" data-ic-uri="" data-height="271" data-width="338" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/d21b3c43235549f6aee3d25939093c91" alt="" data-ic="false" data-ic-uri="" data-height="276" data-width="1112" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<h3>树与二叉树-平衡二叉树</h3>
<ul>
<li>平衡二叉树的提出原因</li>
<li>平衡二叉树的定义（</li>
<li>任意结点的左右子树深度相差不超过1</li>
<li>每结点的平衡度只能为-1、0或1）</li>
<li>平衡树的建立过程</li>
<li>动态调平衡问题</li>




</ul>
<blockquote>例题：对数列{1，5，7，9，8，39，73，88}构造序列二叉树，可以构造出多颗形式不同的排序二叉树。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/5bbd46b322e54f4284da7f63772873d2" alt="" data-ic="false" data-ic-uri="" data-height="363" data-width="533" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/2dc9af3aeb8f4112a4a2434fa4657632" alt="" data-ic="false" data-ic-uri="" data-height="321" data-width="657" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>图-基本概念</h2>
<p>完全图</p>
<ul>
<li>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图（complete graph）</li>




</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/2fb7a6a2835f4b7aa96a4a31066e053b" alt="" data-ic="false" data-ic-uri="" data-height="292" data-width="457" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<ul>
<li>在有向图中，若每对顶点之间都有两条有向边相互连接，则称该图为完全图。</li>




</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/2d8c25efc7884b2c81567e1844147f2b" alt="" data-ic="false" data-ic-uri="" data-height="274" data-width="490" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>


</div>
<h3>图的存储-邻接矩阵</h3>
<blockquote>用一个n阶方阵R来存放图中各结点的关联信息，其矩阵元素Rij定义为：</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/5adf339e3a5b43ccb534f6a631a29675" alt="" data-ic="false" data-ic-uri="" data-height="179" data-width="761" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/37f86cedd2a84b2089c907f64eba8ac3" alt="" data-ic="false" data-ic-uri="" data-height="360" data-width="930" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<h3>图的存储-邻接表</h3>
<p>首先把每个顶点的邻接顶点用链表示出来，然后用一个一维数组来顺序存储上面每个链表的头指针。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/add1850f965342c6bc84be83d8adaf8d" alt="" data-ic="false" data-ic-uri="" data-height="496" data-width="520" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/31ba1cd5db504f3d8b77ec02d6438c15" alt="" data-ic="false" data-ic-uri="" data-height="411" data-width="561" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<h3>图-图的遍历</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/fdc4e8e5531a4aa6a00e3eeba622e9dc" alt="" data-ic="false" data-ic-uri="" data-height="556" data-width="1105" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/eed172fc070b4eec85b241dd44c9ec54" alt="" data-ic="false" data-ic-uri="" data-height="460" data-width="1066" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<h3>图-拓扑排序</h3>
<p>我们把用有向边表示活动之间开始的先后关系。这种有向图称为用顶点表示活动网络，简称AOV网络</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/4fa983a693f240af961eb4760e9a23c7" alt="" data-ic="false" data-ic-uri="" data-height="247" data-width="727" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>




</div>
<p>&nbsp;</p>
<p>上图的拓扑序列有：02143567，01243657，02143657，01243567</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>图的最小生成树-普里姆算法</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/1c653ff5471c426795d4f316010dc461" alt="" data-ic="false" data-ic-uri="" data-height="472" data-width="556" />
<div class="editor-image-menu">&nbsp;</div>




</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>


</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/fbdd247c443e4386b1f68b367bcf2d70" alt="" data-ic="false" data-ic-uri="" data-height="402" data-width="502" />

</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>


</div>
<h2>算法基础-算法的特性</h2>
<ul>
<li>有穷性：执行有穷步之后结束</li>
<li>确定性：算法中每一条指令都必须有确切的含义，不能含糊不清。</li>
<li>输入（&gt;=0)</li>
<li>输出  (&gt;=1)</li>
<li>有效性：算法的每个步骤都能有效执行并能得到确定的结果。例如a=0,b/a就无效。</li>




</ul>
<h3>算法基础-算法的复杂度</h3>
<p>时间复杂度：</p>
<blockquote>是指程序运行从开始到结束所需要的时间。通常分析时间复杂度的方法是从算法中选取一种对于所研究的问题来说是基本运算的操作,以该操作重复执行的次数作为算法的时间度量。一般来说,算法中原操作重复执行的次数是规模n的某个函数T(n)。由于许多情况下要精确计算T(n)是困难的，因此引入了渐进时间复杂度在数量上估计一个算法的执行时间。其定义如下:</blockquote>
<pre>如果存在两个常数c和m ,对于所有的n ,当n&gt;=m时有f(n)&lt;=cg(n) ,则有f(n)=O(g(n))。也就是说,随着n的增大,f(n)渐进地不大于g(n)。例如，一个程序的实际执行时间为T(n)=3n^3+2n^2+n ,则T(n)=O(n^3).
&nbsp;常见的对算法执行所需时间的度量:
O(1)&lt;0(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;0(2^n)
</pre>
<p>空间复杂度:</p>
<blockquote>是指对一个算法在运行过程中临时占用存储空间大小的度量。-个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小。</blockquote>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>查找-顺序查找</h3>
<p>顺序查找的思路：将待查找的关键字为key的元素从头到尾与表中元素进行比较，如果中间存在关键字为key的元素，则返回成功；否则，则查找失败。</p>
<p>查找成功时，顺序查找的平均查找长度为（等概率情况下）:</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/b7bf137a2b454063a932812c79013114" alt="" data-ic="false" data-ic-uri="" data-height="259" data-width="814" /></div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>查找-二分查找</h3>
<p>二分法查找的基本思想是:(设R[low,..,high]是当前的查找区)</p>
<p>(1)确定该区间的中点位置:mid=[(low+high)/2];</p>
<p>(2)将待查的k值与R[mid].key比较,若相等,则查找成功并返回此位置，否则需确定新的查找区间,继续二分查找,具体方法如下。</p>
<pre>●若R[mid].key&gt; k,则由表的有序性可知R[mid,..,n].key均大于k,因此若表中存在关键字等于k的结点,则该结点必定是在位置mid左边的子表R[low，...,mid- 1]中。因此,新的查找区间是左子表R[low，..,high],其中high=mid-1。
●若R[mid].key&lt;k ,则要查找的k必在mid的右子表
R[mid+1...,high]中,即新的查找区间是右子表R[low,..,high],其中low=mid+1。
●若R[mid].key=k,则查找成功,算法结束。
</pre>
<p>(3)下一-次查找是针对新的查找区间进行,重复步骤(1)和(2)。</p>
<p>(4)在查找过程中，low逐步增加,而high逐步减少。如果high&lt;low ,则查找失败,算法结束。</p>
<p>例题：</p>
<blockquote>请给出在含有12个元素的有序表{1，4，10，16，17，18，23，29，33，40，50，51}中二分查找关键字17的过程。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/980a21ec5571445cbcbe73cb32d8045b" alt="" data-ic="false" data-ic-uri="" data-height="445" data-width="1120" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h2>查找-折半查找</h2>
<p>折半查找在查找成功时关键字的比较次数最多为[log2n]=1次。</p>
<p>折半查找的时间复杂度为O（log2n）。</p>
<h3>查找-散列表</h3>
<blockquote>散列表查找的基本思想是:已知关键字集合U,最大关键字为m,设计一个函数Hash,它以关键字为自变量,关键字的存储地址为因变量，将关键字映射到一个有限的、地址连续的区间T[0..n-1](n&lt;&lt;m)中,这个区间就称为散列表,散列查找中使用的转换函数称为散列函数。</blockquote>
<h3>查找-散列表冲突的解决方法</h3>
<blockquote>开放定址法是指当构造散列表发生冲突时,使用某种探测手段，产生-个探测的散列地址序列,并且逐个查找此地址中是否存储了数据元素,如果没有,则称该散列地址开放,并将关键字存入,否则继续查找下-个地址。只要散列表足够大,总能找到空的散列地址将数据元素存入。</blockquote>
<ul>
<li>线性探测法</li>
<li>伪随机数法</li>
</ul>
<blockquote>例:记录关键码为(3，8, 12, 17,9),取m=10(存储空间为10),p=5,散列函数h =key%p。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/5511d910d7404dd1925da6a773f5995e" alt="" data-ic="false" data-ic-uri="" data-height="342" data-width="718" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>排序</h2>
<p>1、排序的概念</p>
<ul>
<li>稳定与不稳定排序</li>
<li>内排序与外排序</li>
</ul>
<p>2、排序方法分类</p>
<ul>
<li>插入类排序</li>
<li>（直接插入排序</li>
<li>希尔排序）</li>
<li>交换类排序</li>
<li>（冒泡排序</li>
<li>快速排序）</li>
<li>选择类排序</li>
<li>（简单选择排序</li>
<li>推排序）</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<h3>排序-直接插入排序</h3>
<blockquote>直接插入排序：即当插入第i个记录，R1，R2，...，Ri-1均已排好序，因此，将第i个记录Ri依次与Ri-1，...，R2 ，R1进行比较，找到合适的位置插入。它简单明了，但速度很慢。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/2fea34ce108f4fbf9227472f65364959" alt="" data-ic="false" data-ic-uri="" data-height="388" data-width="982" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序-希尔排序</h3>
<blockquote>希尔(Shell)排序:先取-个小于n的整数d1作为第-个增量,把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序;然后,取第二个增量d2 &lt;d1,重复上述的分组和排序,直至所取的增量dt=1(dt&lt;dt-1&lt;O&lt;d2&lt;d1) ,即所有记录放在同组中进行直接插入排序为止。该方法实质上是一种分组插入方法。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/eafbbfda0aa3413da2f576080e1c8222" alt="" data-ic="false" data-ic-uri="" data-height="392" data-width="1016" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>排序-直接选择排序</h3>
<blockquote>直接选择排序的过程是，首先在所有记录中选出排序码最小的记录，把它与第一个记录交换，然后在其余的记录内选出排序码最小的记录，与第二个记录交换......依次类推，直到所有记录排完为止。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/370e192da68c43e5958db540827db0e2" alt="" data-ic="false" data-ic-uri="" data-height="314" data-width="794" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序-推排序的概念</h3>
<p>（最复杂的一种）</p>
<blockquote>设有n个元素的序列{K1，K2，...，Kn}，当且仅当满足下述关系之一时，称之为推。（1）ki&lt;=k2i且ki&lt;=k2i+1;（2）ki&gt;=k2i且ki&gt;=k2i+1;其中(1)称为小顶堆，（2）称为大顶堆</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/6cdd0405ff1e4f8c9c91bcc08602e02f" alt="" data-ic="false" data-ic-uri="" data-height="391" data-width="1098" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序-堆排序</h3>
<blockquote>堆排序的基本思想为:先将序列建立堆,然后输出堆顶元素,再将剩下的序列建立堆,然后再输出堆顶元素,依此类推,直到所有元素均输出为止,此时元素输出的序列就是一个有序序列。</blockquote>
<p>堆排序的算法步骤如下(以大顶堆为例):</p>
<pre>(1)初始时将顺序表R[1..n]中元素建立为一个大顶堆,堆顶位于R[1]待序区为R[1..n].
(2)循环执行步骤3 ~步骤4 ,共n-1次。
(3)假设为第次运行,则待序区为R[1..n-i+1],将堆顶元素R[1]与待序区尾元素R[n-i+1]交换,此时顶点元素被输出,新的待序区为R[1..n-i]。
(4)待序区对应的堆已经被破坏,将之重新调整为大顶堆。
</pre>
<p>例题：</p>
<blockquote>假设有数组A={1，3，4，5，7，2，6，8，0}，初建推过程如下：</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/f7fa0dc10c4d404b98eff3223f49eb5d" alt="" data-ic="false" data-ic-uri="" data-height="588" data-width="1188" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>例题</p>
<blockquote>将顺序表R{80，60，16，50，45，10，15，30，40，20}进行堆排序。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/6206d4d565cc47c986c573e457424692" alt="" data-ic="false" data-ic-uri="" data-height="608" data-width="1146" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序-冒泡排序</h3>
<blockquote>冒泡排序的基本思想是，通过相邻元素之间的比较和交换，将排序码较小的元素逐渐从底部移向顶部。由于整个排序的过程就像水底下的气泡一样逐渐向上冒，因此称为冒泡算法。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/45c25080f9e24aaf8af5336134e6c0ae" alt="" data-ic="false" data-ic-uri="" data-height="414" data-width="816" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序-快速排序</h3>
<blockquote>快速排序采用的是分治法,其基本思想是将原问题分解成若干个规模更小但结构与原问题相似的子问题。通过递归地解决这些子问题,然后再将这些子问题的解组合成原问题的解。</blockquote>
<p>快速排序通常包括两个步骤:</p>
<pre>第一步，在待排序的n个记录中任取一个记录,以该记录的排序码为准,将所有记录都分成两组,第1组都小于该数,第2组都大于该数,如图所示。
第二步，采用相同的方法对左、右两组分别进行排序,直到所有记录都排到相应的位置为止。&nbsp;&nbsp;
</pre>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/4c2c37d9965d46d68d20d3b8ddef748b" alt="" data-ic="false" data-ic-uri="" data-height="641" data-width="467" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序-归并排序</h3>
<blockquote>归并也称为合并,是将两个或两个以上的有序子表合并成-个新的有序表。若将两个有序表合并成个有序表,则称为二路合并。合并的过程是:比较A[i]和A[j]的排序码大小,若A[i]的排序码小于等于A[j]的排序码,则将第一个有序表中的元素A[i]复制到R[k]中,并令i和k分别加1;如此循环下去,直到其中一个有序表比较和复制完，然后再将另一个有序表的剩余元素复制到R中。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/971f493ac75946c1b47f6bc58d0a9f9c" alt="" data-ic="false" data-ic-uri="" data-height="327" data-width="635" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序-基数排序</h3>
<blockquote>基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。基数排序不是基于关键字比较的排序方法，它适合于元素很多而关键字较少的序列。基数的选择和关键字的分解是根据关键字的类型来决定的，例如关键字是十进制数，则按个位、十位来分解。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/6aa2f3317ebc43579a3b038919fdd397" alt="" data-ic="false" data-ic-uri="" data-height="654" data-width="724" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>排序</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/ff116dd6797a47cbb3098fdfd2d07cd3" alt="" data-ic="false" data-ic-uri="" data-height="523" data-width="1046" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>更多软考自查在我的主页&ldquo;文章&rdquo;中可以查看！！！</blockquote>]]></description></item><item><title>软考自查：计算机网络</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/26/10436628.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Tue, 26 Feb 2019 05:11:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/26/10436628.html</guid><description><![CDATA[<h1 style="text-align: center;">计算机网络</h1>
<h3>内容提要</h3>
<ul>
<li><strong>七层模型</strong></li>
<li><strong>网络技术标准与协议</strong></li>
<li><strong>网络类型与拓扑结构</strong></li>
<li><strong>网络规划与设计</strong></li>
<li><strong>IP地址与子网划分</strong></li>
<li><strong>特殊含义IP地址</strong></li>
<li><strong>HTML</strong></li>
<li><strong>无线网</strong></li>
<li><strong>网络接入技术</strong></li>
<li><strong>IPv6</strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>OSI/RM七层模型</h2>
<ul>
<li><strong>七层模型</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/b0ecb8f7569545099ce8c5d6d593ded7" alt="" data-ic="false" data-ic-uri="" data-height="476" data-width="1010" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<p>练习题</p>
<blockquote>某IP网络连接如图所示，在这种配置下IP全局广播分组不能够通过的路径是_B_。A：计算机P和计算机Q之间的路径B：计算机P和计算机S之间的路径C: 计算机Q和计算机R之间的路径D：计算机S和计算机T之间的路径</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/66434cb08d644ee3bc19c895e7925d8c" alt="" data-ic="false" data-ic-uri="" data-height="377" data-width="634" /></div>
</div>
<hr />
<p>&nbsp;</p>
<h2>网络技术标准与协议</h2>
<ul>
<li><strong>TCP/IP协议：Internet，可扩展，可靠，应用最广，牺牲速度和效率</strong></li>
<li><strong>IPX/SPX协议：NOVELL，路由，大型企业网</strong></li>
<li><strong>NETBEUI协议：IBM，非路由，快速</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p6-tt.bytecdn.cn/large/pgc-image/de022b99550d458586a63cd2b8817dca" alt="" data-ic="false" data-ic-uri="" data-height="434" data-width="998" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>TCP协议</h3>
<ul>
<li><strong>TCP三次握手</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/3782a416e5424d06a23b6e2555cd2423" alt="" data-ic="false" data-ic-uri="" data-height="310" data-width="853" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/262ecece0a8a475dad146fdb23850324" alt="" data-ic="false" data-ic-uri="" data-height="369" data-width="476" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/584542329e354952a4a9ef46b94857a5" alt="" data-ic="false" data-ic-uri="" data-height="348" data-width="601" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>DHCP协议</h3>
<p><strong>IP地址动态分配</strong></p>
<ol>
<li>客户机／服务器模型</li>
<li>租约默认为８天</li>
<li>当租约过半时，客户机需要向DHCP服务器申请续租；</li>
<li>当租约超过８７.５％时，如果仍然没有和当初提供IP的DHCP服务器联系上，则开始联系其他的DHCP服务器。</li>
<li>固定分配，动态分配和自动分配</li>
<li>１６９.２５４.X．Ｘ和０.０.０.０</li>
</ol>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/5ab1515d1ba647349fb099e3d8a5c7b5" alt="" data-ic="false" data-ic-uri="" data-height="422" data-width="517" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<h3>DNS协议</h3>
<p>主机向本地域名服务器的查询采用递归查询。</p>
<p>本地域名服务器向根域名服务器的查询通常采用迭代查询。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p6-tt.bytecdn.cn/large/pgc-image/7c8ca655fb9f4f188381d5ac6396f67b" alt="" data-ic="false" data-ic-uri="" data-height="400" data-width="576" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<ul>
<li>递归查询：服务器必须回答目标IP与域名的映射关系。</li>
<li>迭代查询：服务器收到一次迭代查询回复一次结果，这个结果不一定是目标IP与域名的映射关系，也可以是其他DNS服务器的地址。</li>
</ul>
<h3>DNS协议例题</h3>
<blockquote>主机host1对host2进行域名查询的过程如下图所示，下列说法真确的是（A）</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/6b2b613f769e4a86814a73ce54296c0c" alt="" data-ic="false" data-ic-uri="" data-height="409" data-width="450" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>A：根域名服务器采用迭代查询，中介域名服务器采用递归查询</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>计算机网络的分类-拓扑结构</h3>
<p>按分布范围分</p>
<ul>
<li>局域网（LAN）</li>
<li>城域网（MAN）</li>
<li>广域网（WAN）</li>
<li>因特网</li>
</ul>
<p>按拓扑结构分</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/0f3d1c6ec7af497a800e09fda77a4413" alt="" data-ic="false" data-ic-uri="" data-height="316" data-width="878" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<hr />
<p>&nbsp;</p>
<h3>网络规划与设计</h3>
<p><strong>网络规划原则</strong></p>
<ul>
<li>实则用性原则</li>
<li>开放性原则</li>
<li>先进性原</li>
</ul>
<p><strong>网络设计任务</strong></p>
<ul>
<li>确定网络总体目标</li>
<li>确定总体设计原则</li>
<li>通信子网设计</li>
<li>资源子网设计</li>
<li>设备选型</li>
<li>网络操作系统与服务器资源设备</li>
<li>网络安全设计</li>
</ul>
<p><strong>网络设计原则</strong></p>
<ul>
<li>可用性:指网络或网络设备可用于执行预期任务时间所占总量的百分比。</li>
<li>可靠性:网络设备或计算机持续执行预定功能的可能性。</li>
<li>可恢复性:指网络从故障中恢复的难易程度和时间。</li>
<li>适应性:指在用户改变应用要求时网络的应变能力。</li>
<li>可伸缩性:指网络技术或设备随着用户需求的增长而扩充的能力。</li>
</ul>
<p><strong>网络实施原则</strong></p>
<ul>
<li>可靠性原则</li>
<li>安全性原则</li>
<li>高效性原则</li>
<li>可扩展性原则</li>
</ul>
<p><strong>网络实施步骤</strong></p>
<ul>
<li>工程实施计划</li>
<li>网络设备到货验收</li>
<li>设备安装</li>
<li>系统测试</li>
<li>系统试运行</li>
<li>用户培训</li>
<li>系统转换</li>
</ul>
<h3>络规划与设计-逻辑网络设计</h3>
<p>利用需求分析和现有网络体系分析的结果来设计逻辑网络结构,最后得到一份逻辑网络设计文档,输出内容包括以下几点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<ul>
<li>逻辑网络设计图</li>
<li>IP地址方案</li>
<li>安全方案</li>
<li>具体的软硬件、广域网连接设备和基本服务</li>
<li>招聘和培训网络员工的具体说明</li>
<li>对软硬件、服务、员工和培训的费用初步估计</li>
</ul>
<h3>各规划与设计一物理网络设计</h3>
<p>物理网络设计是对逻辑网络设计的物理实现,通过对设备的具体物理分布、运行环境等确定,确保网络的物理连接符合逻辑连接的要求。输出如下内容:&nbsp;</p>
<ul>
<li>网络物理结构图和布线方案&nbsp;</li>
<li>设备和部件的详细列表清单</li>
<li>软硬件和安装费用的估算</li>
<li>安装日程表，详细说明服务的时间以及期限</li>
<li>安装后的测试计划</li>
<li>用户的培训计划</li>
</ul>
<h3>网络规划与设计-分层设计</h3>
<ul>
<li>分层设计</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/18f21b745c33487cbd9ee8c47b6442de" alt="" data-ic="false" data-ic-uri="" data-height="408" data-width="682" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<ul>
<li>接入层：向本地网段提供用户接入</li>
<li>汇聚层：网络访问策略控制，数据包处理、过滤、寻址</li>
<li>核心层：数据交换</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>IP地址</h3>
<ul>
<li>IP地址</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/a11e47442827421ba1d2c2c67b36a4cf" alt="" data-ic="false" data-ic-uri="" data-height="617" data-width="1021" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>172.18.129.0/24</p>
<h3>子网划分</h3>
<ul>
<li>1.子网掩码</li>
<li>2.将多个网络划分成多个子网（取部分主机号当子网号）</li>
<li>3.将多个网络合并成一个大的网络(取部分网络号当主机号）</li>
</ul>
<blockquote>例1，将B类IP地址168.195.0.0划分成27个子网，子网掩码为多少？</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/95059427c55a4a168d5c370a756347cf" alt="" data-ic="false" data-ic-uri="" data-height="395" data-width="1046" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<blockquote>例2：将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台，子网掩码为多少？</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p6-tt.bytecdn.cn/large/pgc-image/75d55ecacab147cea3133ab8d11e49ae" alt="" data-ic="false" data-ic-uri="" data-height="330" data-width="1021" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>无分类编址(无类域间路由)</h3>
<p><strong>IP地址 ::= {&lt;网络前缀)，&lt;主机号&gt;}</strong></p>
<blockquote>128.14.32.0/20表示的地址块共有2^12个地址。这个地址块的起始地址是128.14.32.0.在不需要指出地址块的起始地址时,也可将这样的地址块简称为"/20地址块128.14.32.0/20地址块的最小地址:128.14.32.0 128.14.32.0/20地址块的最大地址:128.14.47.255全0和全1的主机号地址一般不使用。</blockquote>
<p>例题</p>
<blockquote>分配给某公司网络的地址块是210.115.192.0/20，该网络可以被划分为16个C类子网。</blockquote>
<h3>特殊含义的IP地址</h3>
<ul>
<li>特殊含义的IP地址</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/5cbbc90bf61a470fba1bc603ac845810" alt="" data-ic="false" data-ic-uri="" data-height="543" data-width="999" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/fb0daee31f3c482abeba97686c89534f" alt="" data-ic="false" data-ic-uri="" data-height="547" data-width="1280" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>HTML</h3>
<p>是一种标签语言</p>
<p>用在web运用上</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/6ad05ea25fab49c09daea12f815be8fe" alt="" data-ic="false" data-ic-uri="" data-height="676" data-width="585" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>无线网</h3>
<p>优势</p>
<ol>
<li>移动性</li>
<li>灵活性</li>
<li>成本低</li>
<li>容易扩充</li>
</ol>
<ul>
<li>无线局域网（WLAN，802.11，WI-Fi）</li>
<li>无线城域网（WMAN，802.16，WiMax）</li>
<li>无线广域网（WWAN，3G/4G）</li>
<li>无线个人网(WPAN，802.15，Bluetooth）</li>
</ul>
<h3>网络接入技术</h3>
<p>有线接入</p>
<ul>
<li>公用交换电话网络(PSTN)</li>
<li>V数字数据网(DDN)</li>
<li>综合业务数字网(ISDN)</li>
<li>非对称数字用户线路(ADSL)</li>
<li>同轴光纤技术(HFC)</li>
</ul>
<p>无线接入</p>
<ul>
<li>IEEE 802.11(WiFi)</li>
<li>IEEE 802.15(蓝牙Bluetooth)</li>
<li>红外(IrDA)</li>
<li>WAPI</li>
</ul>
<p>3G/4G&nbsp;</p>
<ul>
<li>WCDMA</li>
<li>CDMA2000</li>
<li>TD SCDMA</li>
<li>LTE-Advanced</li>
<li>WirelessMAN-Advanced(802.16m)WiMAX)</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img src="http://p6-tt.bytecdn.cn/large/pgc-image/b5214b50c6a543a68ac5111a8e39390d" alt="" data-ic="false" data-ic-uri="" data-height="545" data-width="1280" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>IPv6</h3>
<p>IPv6是设计用于替代现行版本IP协议(IPv4)的下-代IP协议。（原因：IPv4不够用了）</p>
<blockquote>(1) IPv6地址长度为128位,地址空间增大了2^96倍;(2)灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPV4中可变长度的选项字段。IPv6中选项部分的出现方式也有所变化,使路由器可以简单路过选项而不做任何处理,加快了报文处理速度;&nbsp;(3)IPv6简化了报文头部格式,字段只有8个,加快报文转发,提高了吞吐量;(4)提高安全性。身份认证和隐私权是IPv6的关键特性;(5)支持更多的服务类型;(6)允许协议继续演变,增加新的功能，使之适应未来技术的发展;</blockquote>
<ul>
<li>单播地址(Unicast):用于单个接口的标识符。</li>
<li>任播地址(Anycast):泛播地址。一组接口的标识符, IPv4厂播地址。</li>
<li>组播地址(Multicast):IPv6中的组播在功能上IPv4中的组播类似。</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/a338c7b29e914d89b12ab6e76f7a2694" alt="" data-ic="false" data-ic-uri="" data-height="545" data-width="1280" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<blockquote>更多软考自查在我的主页＂文章＂中可以查看！！！</blockquote>]]></description></item><item><title>软考自查：数据库系统</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/25/10433188.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 25 Feb 2019 12:31:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/25/10433188.html</guid><description><![CDATA[<h2 style="text-align: center;">数据库系统</h2>
<h3>内容提要</h3>
<ul>
<li>数据库模式</li>
<li>ER模型</li>
<li>关系代数与元组演算</li>
<li>规范化理论</li>
<li>并发控制</li>
<li>数据库完整性约束</li>
<li>分布式数据库</li>
<li>数据仓库与数据挖掘</li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>三级模式-两级映射</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/ac19ecb2204b403da2f680e221f55890" alt="" data-ic="false" data-ic-uri="" data-height="621" data-width="812" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>数据库设计过程</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/836cd2dc2f7e43138436f0b4c5508bf1" alt="" data-ic="false" data-ic-uri="" data-height="596" data-width="868" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<hr />
<p>&nbsp;</p>
<h2>E-R模型</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/18e07d07632d49a38ead2edff3fb8f3c" alt="" data-ic="false" data-ic-uri="" data-height="607" data-width="885" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>集成的方法:</p>
<ul>
<li>多个局部E-R图次集成。</li>
<li>逐步集成，用累加的方式-次集成两个局部E-R。</li>
</ul>
<p>集成产生的冲突及解决办法:&nbsp;</p>
<ul>
<li>属性冲突:包括属性域冲突和属性取值冲突。</li>
<li>命名冲突:包括同名异义和异名同义。</li>
<li>结构冲突:包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。</li>
</ul>
<h3>E-R模型</h3>
<p>一个实体型转换为一个关系模式</p>
<p>1:1联系&nbsp;1: n联系 m：n联系</p>
<p>三个以上实体间的一个多元联系</p>
<p>&nbsp;</p>
<blockquote>在数据库逻辑结构的设计中，将E-R模型转换为关系模型应遵循相关原则。对于三个不同实体集和它们之间的多对多联系m：n: p, 最少可转换为__C__个 关系模式。A.2&nbsp;B.3&nbsp;C.4&nbsp;D.5</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/f4e397e94bee4cbd860ed5a3bdd04ceb" alt="" data-ic="false" data-ic-uri="" data-height="180" data-width="526" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>关系代数</h2>
<ol>
<li>并</li>
<li>交</li>
<li>差</li>
<li>笛卡儿积</li>
<li>投影</li>
<li>选择</li>
<li>联接</li>
</ol>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/dcaa60acddfa43b1bfab97a6b998a020" alt="" data-ic="false" data-ic-uri="" data-height="221" data-width="770" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/a43c13aead9d40039cd15694dece1e6a" alt="" data-ic="false" data-ic-uri="" data-height="291" data-width="779" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/42169bd111474f81bbaee14d05d35d24" alt="" data-ic="false" data-ic-uri="" data-height="170" data-width="364" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/27bff4e422b74d6784a9661ef920db80" alt="" data-ic="false" data-ic-uri="" data-height="410" data-width="661" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/2d75f51b69b84297aa7cc24b2a322450" alt="" data-ic="false" data-ic-uri="" data-height="202" data-width="683" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/20c2a321e6904c5ebfd992dae779a14b" alt="" data-ic="false" data-ic-uri="" data-height="187" data-width="454" /></div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>规范化理论-函数依赖</h2>
<blockquote>设R（U)是属性U上的一个关系模式，X和Y是U的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X],就有u[Y]=v[Y],则称X函数决定Y，或称Y函数依赖于X，记为X-&gt;Y。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative" style="text-align: center;"><img src="http://p1-tt.bytecdn.cn/large/pgc-image/adeaf35beee649c09530818ab8c63189" alt="" data-ic="false" data-ic-uri="" data-height="259" data-width="408" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/64a64f4d13b840508e1a4b62cb3c3a47" alt="" data-ic="false" data-ic-uri="" data-height="261" data-width="471" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>规范化理论-价值与用途</h3>
<p>非规范化的关系模式，可能存在的问题包括：数据冗余、更新异常、插入异常、删除异常</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/61bb30de490147f1be5e3669b3ca72c1" alt="" data-ic="false" data-ic-uri="" data-height="284" data-width="906" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>规范化理论-键</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/27ec2f65659c48108b22f8169e8926db" alt="" data-ic="false" data-ic-uri="" data-height="555" data-width="913" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<h3>规范化理论-求候选键</h3>
<blockquote>将关系模式的函数依赖关系用&ldquo;有向图&rdquo;的方式表示找入度为0的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些中间结点(既有入度，也有出度的结点)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键</blockquote>
<p>例题</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/fe95401f954148c39828e75a7eada68b" alt="" data-ic="false" data-ic-uri="" data-height="206" data-width="724" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>答案：A</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative" style="text-align: center;"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/6e3e89b36330460882d6cec372495232" alt="" data-ic="false" data-ic-uri="" data-height="237" data-width="282" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<h2>规范化理论-范式</h2>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/4baa35a80e2f4974bee99259325880e8" alt="" data-ic="false" data-ic-uri="" data-height="516" data-width="1023" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>规范化理论-第一范式</h3>
<blockquote>第一范式（1NF）：在关系模式R中，当且仅当所有域只包含原子值，即每个分量都是不可再分的数据项，则称R是第一范式。</blockquote>
<h3>规范化理论-第二范式</h3>
<blockquote>第二范式（2NF）：当且仅当R是1NF，且每一个非主属性完全依赖主键（不存在部分依赖）时，则称R是第二范式。</blockquote>
<h3>规范化理论-第三范式</h3>
<blockquote>第三范式（3NF）：当且仅当R是1NF，且E中没有非主属性传递依赖于码时，则称R是第三范式。</blockquote>
<h3>规范化理论-BC范式</h3>
<blockquote>BC范式（BCNF）：设R是一个关系模式，F是它的依赖集，R属于BCNF当且仅当其中F中每个依赖的决定因素必定包含R的莫个候选码。</blockquote>
<h3>规范化理论-模式分解</h3>
<p>保持函数依赖分解</p>
<blockquote>设数据库模式p={R1, R2, . Rk}是关系模式R的一个分解，F是R 上的函数依赖集，p 中每个模式Ri上的FD集是Fi。如果{F1, F2, - Fk} 与F是等价的(即相互逻辑蕴涵)，那么称分解p保持FD</blockquote>
<p>无损分解</p>
<blockquote>什么是有损，什么又是无损?&nbsp;有损:不能还原。&nbsp;无损:可以还原。</blockquote>
<p>&nbsp;</p>
<blockquote>无损联接分解:指将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式</blockquote>
<h3>规范化理论-模式分解-例题讲解</h3>
<p>思考题:</p>
<blockquote>有关系模式:成绩(学号,姓名，课程号，课程名，分数)函数依赖:学号一&gt;姓名，课程号-&gt;课程名，(学号，课程号)-&gt;分数&nbsp;若将其分解为:&nbsp;&nbsp;&nbsp;成绩(学号，课程号，分数)&nbsp;&nbsp;&nbsp;学生(学号，姓名)&nbsp;&nbsp;&nbsp;课程(课程号，课程名)<br />请思考该分解是否为无损分解?<br />由于有:学号-&gt;姓名，所以:成绩(学号，课程号，分数，姓名)由于有:课程号一&gt;课程名，所以:成绩(学号，课程号，分数,姓名，课程名)</blockquote>
<p>将一个具有函数依赖:学号-&gt;姓名，课程号-&gt;课程名，(学号，课程号)-&gt;分数的关系模式:成绩(学号，姓名，课程号，课程名，分数)，分解为:成绩(学号，课程号，分数);学生(学号，姓名);课程(课程号，课程名)。</p>
<p>初始表如下:</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/1533bca7d3174b5fa0ee8080f74aebec" alt="" data-ic="false" data-ic-uri="" data-height="189" data-width="926" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<p>根据学号-&gt;姓名，对上表进行处理，将b12改成符号a2；然后考虑课程号-&gt;课程名，将b14改为a4，得下表：</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/d1ece321a8774c0a8623e8f3e86a5b73" alt="" data-ic="false" data-ic-uri="" data-height="208" data-width="979" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<p>从上图中可以看出，第一行已全部为a，因此本次R分解时无损联接分解。</p>
<h3>规范化理论-模式分解</h3>
<blockquote>定理:如果R的分解为p={R1,R2},F为R所满足的函数依赖集合分解p具有无损联接性的充分必要条件是:&nbsp;R1&cap;R2-&gt;(R1-R2)或R1&cap;R2-&gt;(R2-R1)  其中，R1&cap;R2,表示模式的交，为R1与R2中公共属性组成，R1-R2,或R2 -R1表示模式的差集，R1一R2表示R1中去除R1和R2的公共属性所组成。当模式R分解成两个关系模式R1和R2时，如果R1与R2的公共属性能函数决定R1中或R2中的其它属性，这样的分解就具有无损联接性。</blockquote>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>并发控制-基本概念</h2>
<ul>
<li>基本概念</li>






</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/a5a4b80ffcea40e29fe0127689f29ab6" alt="" data-ic="false" data-ic-uri="" data-height="542" data-width="999" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<h3>并发控制-存在的问题实例</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/f851a738df9344f6b4720382cf53a0e1" alt="" data-ic="false" data-ic-uri="" data-height="627" data-width="1038" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<h3>并发控制-封锁协议</h3>
<p>一级封锁协议。事务T在修改数据R之前必须先对其加x锁，直到事务结束才释放。可防止丢失修改</p>
<p>二级封锁协议。一级封锁协议加上事务T在读取数据R之前先对其加S锁，读完后即可释放S锁。可防止丢失修改，还可防止读&ldquo;脏&rdquo;数据</p>
<p>三级封锁协议。一级封锁协议加上事务T在读取数据R之前先对其加S锁，直到事务结束才释放。可防止丢失修改、防止读&ldquo;脏&rdquo;数据与防止数据重复读</p>
<p>两段锁协议。可串行化的。可能发生死锁</p>
<h3>数据库完整性约束</h3>
<ol>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义完整性约束</li>






</ol>
<ul>
<li>触发器</li>






</ul>
<h2>数据库安全</h2>
<ul>
<li>数据库安全</li>






</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/b3592ef5cd8041309b2f4f1bbde62313" alt="" data-ic="false" data-ic-uri="" data-height="485" data-width="1043" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<h3>数据备份</h3>
<p>冷备份也称为静态备份，是将数据库正常关闭，在停止状态下，将数据库的文件全部备份(复制)下来。</p>
<p>热备份也称为动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来。</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/94fb0a8469dc4206baaa26b33e98f132" alt="" data-ic="false" data-ic-uri="" data-height="379" data-width="1104" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<h3>数据备份</h3>
<ul>
<li>完全备份:备份所有数据</li>
<li>差量备份:仅备份上一次完全备份之后变化的数据</li>
<li>增量备份:备份上-次备份之后变化的数据</li>






</ul>
<p>(1)静态海量转储:在系统中无运行事务时进行,每次转储全部数据库。</p>
<p>(2)静态增量转储:在系统中无运行事务时进行,每次只转储上一次转储后更新过的数据。</p>
<p>(3)动态海量转储:转储期间允许对数据库进行存取或修改,每次转储全部数据库。</p>
<p>(4动态增量转储:转储期间允许对数据库进行存取或修改,每次只转储上-次转储后更新过的数据。</p>
<p>日志文件:事务日志是针对数据库改变所做的记录。它可以记录针对数据库的任何操作，并将记录结果保存在独立的文件中</p>
<h3>数据库故障与恢复</h3>
<ul>
<li>数据库故障与恢复</li>






</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/c7d045b956d542fc9262432d6892cfcd" alt="" data-ic="false" data-ic-uri="" data-height="448" data-width="958" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<h3>数据仓库与数据挖掘</h3>
<p><strong>面向主题</strong></p>
<p><strong>集成的</strong></p>
<p><strong>相对稳定的（非易失的）</strong></p>
<p><strong>反映历史变化（随着时间的变化）</strong></p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/ce17a4003c6d427fa3bc3ec9f141a4ed" alt="" data-ic="false" data-ic-uri="" data-height="447" data-width="853" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<h3>数据挖掘方法分类</h3>
<p><strong>方法</strong></p>
<ul>
<li>决策树</li>
<li>神经网络</li>
<li>遗传算法</li>
<li>关联规则挖掘算法</li>






</ul>
<p><strong>分类</strong></p>
<ul>
<li>关联分析:挖掘出隐藏在数据间的相互关系。</li>
<li>序列模式分析:侧重点是分析数据间的前后关系(因果关系)。</li>
<li>分类分析:为每一个记录赋予一个标记再按标记分类。</li>
<li>聚类分析:分类分析法的逆过程。</li>






</ul>
<h3>反规范化</h3>
<p>由于规范化会使表不断的拆分,从而导致数据表过多。这样虽然减少了数据冗余，提高了增、删、改的速度,但会增加查询的工作量。系统需要进行多次连接,才能进行查询操作,使得系统效率大大下降</p>
<p>技术手段</p>
<ul>
<li>增加派生性冗余列</li>
<li>增加冗余列</li>
<li>重新组表</li>
<li>分割表</li>






</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2>大数据</h2>
<p>对海量数据处理的技术</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/5db3fa7c72e44f7ead1b98ab173305da" alt="" data-ic="false" data-ic-uri="" data-height="544" data-width="1138" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<h3>传统数据和大数据的比较</h3>
<ul>
<li>传统数据和大数据的比较</li>






</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/b698bdb8adb24473b0a9b3c642a73b0f" alt="" data-ic="false" data-ic-uri="" data-height="212" data-width="951" />
<div class="editor-image-menu">&nbsp;</div>






</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>






</div>
<p>&nbsp;</p>
<p><strong>大数据处理系统应该具有的重要特征</strong></p>
<ul>
<ul>
<li>高度可扩展性</li>
<li>高性能</li>
<li>高度容错</li>
<li>支持异构环境</li>
<li>较短的分析延迟</li>
<li>易用且开放的接口</li>
<li>较低成本</li>
<li>向下兼容性</li>
</ul>
</ul>]]></description></item><item><title>软考自查：操作系统基本原理</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/24/10427704.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 24 Feb 2019 12:20:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/24/10427704.html</guid><description><![CDATA[<h3>操作系统基本原理</h3>
<h3>操作系统-概述</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/52eea0f6168d4982a5fef06f558517c1" alt="" data-ic="false" data-ic-uri="" data-height="327" data-width="500" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<ul>
<li><strong>操作系统</strong></li>
<li><strong>管理系统的硬件、软件、数据资源</strong></li>
<li><strong>控制程序运行</strong></li>
<li><strong>人机之间的接口</strong></li>
<li><strong>应用软件与硬件之间的接口</strong></li>
</ul>
<p><strong>&nbsp;</strong></p>
<p><strong>&nbsp;</strong></p>
<hr />
<p><strong>&nbsp;</strong></p>
<ul>
<li><strong>进程管理</strong></li>
<li><strong>【进程的状态 前趋图 PV操作 死锁问题】</strong></li>
<li><strong>存储管理</strong></li>
<li><strong>【段页式存储 页面置换算法】</strong></li>
<li><strong>文件管理</strong></li>
<li><strong>【索引文件 位示图】</strong></li>
<li><strong>作业管理</strong></li>
<li><strong>设备管理</strong></li>
<li><strong>微内核操作系统</strong></li>
<li><strong>【虚设备与SPOOLING技术】</strong></li>
</ul>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h3>进程管理-进程的状态</h3>
<p><strong>进程的状态</strong></p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><strong><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/e0a439c6534a43e5a2757123365bb391" alt="" data-ic="false" data-ic-uri="" data-height="383" data-width="551" /></strong>
<div class="editor-image-menu"><strong>&nbsp;</strong></div>
</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/992d85fe3a9f4fcdaeb258a4a61a2690" alt="" data-ic="false" data-ic-uri="" data-height="410" data-width="520" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>进程管理-前趋图</h3>
<p><strong>前趋图</strong></p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/333a2118dda840caad6e3fa91e9135c3" alt="" data-ic="false" data-ic-uri="" data-height="92" data-width="690" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/96472442fefd42e1ad8b7e8f7c506130" alt="" data-ic="false" data-ic-uri="" data-height="302" data-width="360" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<ul>
<li>A:绞肉</li>
<li>B:切葱末</li>
<li>C:其他调料</li>
<li>D:搅拌</li>
<li>E:包饺子</li>
</ul>
<h3>进程管理-进程的同步与互斥</h3>
<p><strong>互斥：如千军万马过独木桥</strong>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative" style="text-align: center;"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/3f21f3868b04437fa46e24ed85cbc56d" alt="" data-ic="false" data-ic-uri="" data-height="395" data-width="353" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><strong>同步：速度有差异，在一定情况停下等待</strong></p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/fb8fde050e55432c81750bafa27b3ba3" alt="" data-ic="false" data-ic-uri="" data-height="421" data-width="572" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>进程管理-进程的同步与互斥</h3>
<p><strong>生产者消费者问题</strong></p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/53a7fbd02df348518e3fda2f34622b1e" alt="" data-ic="false" data-ic-uri="" data-height="299" data-width="741" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>单缓冲区情况</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/acc2555f96734e109a3ec3c2f40d7ab3" alt="" data-ic="false" data-ic-uri="" data-height="152" data-width="594" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>多缓冲区情况</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative" style="text-align: center;"><img src="http://p9-tt.bytecdn.cn/large/pgc-image/f9495acddc8b4506b0e57a8e14d58006" alt="" data-ic="false" data-ic-uri="" data-height="125" data-width="552" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper" style="text-align: center;">&nbsp;</div>
</div>
<p style="text-align: center;">&nbsp;</p>
<h3>进程管理-PV操作</h3>
<p><strong>临界资源</strong>：诸进程间需要互斥方式对其进行共享的资源，如打印机、磁带机等</p>
<p><strong>临界区</strong>：每个进程中访问临界资源的那段代码称为临界区</p>
<p><strong>信号量</strong>：是一种特殊的变量</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/620abfec38bc4f2b84fb49e362f27720" alt="" data-ic="false" data-ic-uri="" data-height="349" data-width="838" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>单缓冲区生产者、消费者问题PV原语描述：</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/f45efc6dc1c9462280f558334fc44763" alt="" data-ic="false" data-ic-uri="" data-height="181" data-width="630" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>S1初值为1，S2初值为0</p>
<h3>PV操作例题</h3>
<ul>
<li>例题</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/2c1dcf5bfc0b4aa6b8e33cde4ef23266" alt="" data-ic="false" data-ic-uri="" data-height="600" data-width="1095" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<ul>
<li>1：（A）</li>
<li>2：（C）</li>
</ul>
<h3>进程管理-PV操作</h3>
<ul>
<li>PV操作</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/faeaeb52215f4420b30ba37ccad90f5b" alt="" data-ic="false" data-ic-uri="" data-height="581" data-width="843" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<blockquote>前一个进程需解锁后一个进程才可以进行</blockquote>
<h3>例题</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/233829f07a4f426abb84dc48de8dc0db" alt="" data-ic="false" data-ic-uri="" data-height="611" data-width="1096" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<ul>
<li>1：C</li>
<li>2：A</li>
<li>3：A</li>
</ul>
<h3>进程管理-死锁问题</h3>
<p><strong>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。</strong></p>
<blockquote>例：系统有3 个进程：A、B、C。这3个进程都需要5个系统资源。如果系统至少有多少个资源，则不可能发生死锁。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative" style="text-align: center;"><img src="http://p3-tt.bytecdn.cn/large/pgc-image/1db6d901f9f9445c85fce0e8ec84d3ad" alt="" data-ic="false" data-ic-uri="" data-height="261" data-width="343" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>死锁的预防与死锁的避免</h3>
<ul>
<li><strong>死锁的预防与死锁的避免</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/0304c8444ec64f9a9c863ce8e48ed6e4" alt="" data-ic="false" data-ic-uri="" data-height="621" data-width="1007" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>进程管理-银行家算法</h3>
<ul>
<li><strong>银行家算法:分配资源的原则</strong></li>
</ul>
<p>当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程进程可以分期请求资源，但请求的总数不能超过最大需求量</p>
<p>当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源</p>
<h3>银行家算法例子：</h3>
<ul>
<li>例子</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/58721a7c82174e93b37b879dc3820767" alt="" data-ic="false" data-ic-uri="" data-height="557" data-width="1016" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>首先求剩下的资源数：</p>
<p>R1=9-（1+2+2+1+1）=2</p>
<p>R2=8-（2+1+1+2+1)=1</p>
<p>R3=5-(1+1+3)=0</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/0bcef47e9c5e440e9b995796f4224159" alt="" data-ic="false" data-ic-uri="" data-height="282" data-width="714" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/d6d7632c7d9c4ac7a2eedf017bac105a" alt="" data-ic="false" data-ic-uri="" data-height="304" data-width="853" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/6714af19dba24d2abe67c28ad5fe3f91" alt="" data-ic="false" data-ic-uri="" data-height="397" data-width="1076" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>存储管理-分区存储组织</h3>
<blockquote>某计算机系统的内存大小为128K，采用可变分区分配方式进行内存分配，当前系统的内存分块情况如下图所示，现有作业4申请内存9k，几种不同的存储分配算法在分配中，会产生什么样的结果呢？</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/5f0fff5fc69b4bd9890feaa708c0a8e0" alt="" data-ic="false" data-ic-uri="" data-height="329" data-width="1129" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>存储管理-页式存储组织</h3>
<ul>
<li><strong>页式存储组织</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/fc932c99771f417980c0ac261801240b" alt="" data-ic="false" data-ic-uri="" data-height="469" data-width="454" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><strong>高级程序语言使用逻辑地址；运行状态，内存中使用物理地址。</strong></p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/1912d2614dec4f48b7e12064a7a3bdd6" alt="" data-ic="false" data-ic-uri="" data-height="348" data-width="555" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p><strong>优点：</strong>利用率高，碎片小，分配及管理简单</p>
<p><strong>缺点：</strong>增加了系统开销；可能产生抖动现象</p>
<h3>练习题</h3>
<blockquote>进程P有6个页面，页号分别为0~5,页面大小为4K,页面变换表如下所示。表中状态位等于1和0分别表示页面在内存和不在内存。假设系统给进程P分配了4个存储块，进程P要访问的逻辑地址为十六进制5A29H，那么该地址经过变换后，其物理地址应为十六进制_ (1)__;如果进程P要访问的页面4不在内存，那么应该淘汰页号为__ (2)_ 的页面。</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/82147cf47e364ed1b16d73ce7571c723" alt="" data-ic="false" data-ic-uri="" data-height="364" data-width="1031" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<ul>
<li></li>
<li>1：D</li>
<li>2：B</li>
</ul>
<h3>存储管理-段式存储组织</h3>
<ul>
<li><strong>段式存储组织</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><strong><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/533f4eff2ce140f5af2c1609b2245f59" alt="" data-ic="false" data-ic-uri="" data-height="138" data-width="654" /></strong>
<div class="editor-image-menu"><strong>&nbsp;</strong></div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/52e5a25903ef4862b9afc0f1a6d3618a" alt="" data-ic="false" data-ic-uri="" data-height="377" data-width="551" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/2aca4875e30a4b8593c0acca5209f927" alt="" data-ic="false" data-ic-uri="" data-height="395" data-width="560" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><strong>优点：</strong>多道程序共享内容，各段程序修改互不影响</p>
<p><strong>缺点：</strong>内存利用率低，内存碎片浪费大</p>
<h3>存储管理-段页式存储组织</h3>
<ul>
<li>段页式存储组织</li>
</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/ddc19e86f62d4861824d46c868b39f91" alt="" data-ic="false" data-ic-uri="" data-height="413" data-width="777" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p>优点:空间浪费小、存储共享容易、存储保护容易、能动态连接</p>
<p>缺点:由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降</p>
<h3>存储管理-块表</h3>
<p><strong>快表是一块小容量的相联存储器(Associative Memory) ，由高速缓存器组成，速度快，并且可以从硬件上保证按内容并行查找,般用来存放 当前访问最频繁的少数活动页面的页号。</strong></p>
<h3>存储管理-页面置换算法</h3>
<ul>
<li><strong>最优（Optimal，OPT)算法</strong></li>
<li><strong>随机（RAND）算法</strong></li>
<li><strong>先进先出（FIFO）算法：可能产生&ldquo;抖动&rdquo;。例如，432143543215序列，用3个页面，比4个缺页要少</strong></li>
<li><strong>最近最少使用（LRU）算法：不会&ldquo;抖动&rdquo;</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/c24ec224c0f94c04adb094050cd11c1c" alt="" data-ic="false" data-ic-uri="" data-height="236" data-width="977" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/052374ec290841cd8065112677465a72" alt="" data-ic="false" data-ic-uri="" data-height="278" data-width="971" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<h3>例题</h3>
<blockquote>在一个虚存系统中，进程的内存空间为3页，开始内存为空，有以下访问页序列：5 0 1 2 0 3 0 4...,分别计算缺页次数。（1）使用先进先出的页面淘汰算法（2）使用最佳适应算法（3）使用最近最少使用算法</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/1718e02b752e43edb60dc62a3f66ec8d" alt="" data-ic="false" data-ic-uri="" data-height="211" data-width="1073" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>练习题</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/6f0d028099a745d392972bc88cc72fc3" alt="" data-ic="false" data-ic-uri="" data-height="543" data-width="1021" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<ul>
<li>1：B</li>
<li>2：C</li>
</ul>
<h3>文件管理-索引文件结构</h3>
<ul>
<li>索引文件结构</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/69491868e7504279ae1580ba62fda25e" alt="" data-ic="false" data-ic-uri="" data-height="481" data-width="828" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>练习题</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/b9ff30b9126543f8a110e691d13db517" alt="" data-ic="false" data-ic-uri="" data-height="573" data-width="575" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/38ec0309c8dc4972aca51c3f45e5f880" alt="" data-ic="false" data-ic-uri="" data-height="509" data-width="549" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<ul>
<li>1：C</li>
<li>2：D</li>
</ul>
<h3>操作系统-文件和数型目录结构</h3>
<p><strong>文件属性</strong></p>
<ul>
<li>R 只读文件属性</li>
<li>A 存档属性</li>
<li>S 系统文件</li>
<li>H 隐藏文件</li>
</ul>
<p><strong>文件名的组成</strong></p>
<ul>
<li>驱动器号</li>
<li>路径</li>
<li>主文件名</li>
<li>扩展名</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/7617d6ce012740efa55cdf6de73f9e78" alt="" data-ic="false" data-ic-uri="" data-height="295" data-width="643" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><strong>绝对路径：是从盘符开始的路径</strong></p>
<p><strong>相对路径：是从当前路径开始的路径</strong></p>
<p><strong>若当前目前为：D1，要求F2路径，则：绝对路径：/D1/W2/F2,相对路径：W2/F2</strong></p>
<h3>文件管理-空闲存储空间的管理</h3>
<ul>
<li>空闲区表法（空闲文件目录）</li>
<li>空闲链表法</li>
<li>位示图法</li>
<li>成组链接法</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/ff4873e974f04265887716cc990dcaee" alt="" data-ic="false" data-ic-uri="" data-height="318" data-width="877" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<h3>文件管理-试题讲解</h3>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/ca42dc822f184d4092109e3692864cd6" alt="" data-ic="false" data-ic-uri="" data-height="520" data-width="1005" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/305f0e26d78a43e2a95fadd678a37ead" alt="" data-ic="false" data-ic-uri="" data-height="434" data-width="663" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/342e21ae706d4ed19e466fae992b8f78" alt="" data-ic="false" data-ic-uri="" data-height="177" data-width="1132" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<ul>
<li></li>
<li>1：D</li>
<li>2:B</li>
</ul>
<h3>设备管理-数据传输控制方式</h3>
<ul>
<li>程序控制方式</li>
<li>程序中断方式</li>
<li>DMA方式</li>
<li>通道</li>
<li>输入输出处理机</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p6-tt.bytecdn.cn/large/pgc-image/656980d71c0d49d1ae7d2494f382f6ff" alt="" data-ic="false" data-ic-uri="" data-height="490" data-width="514" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>设备管理-虚设备与SPOOLING技术</h3>
<ul>
<li>虚设备与SPOOLING技术</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9-tt.bytecdn.cn/large/pgc-image/cb082f5d7ee349eaabfe23c0712dd9aa" alt="" data-ic="false" data-ic-uri="" data-height="272" data-width="786" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<blockquote>思考：A、B、C、D共用一台打印机x,要进行资料打印时，很容易出现&ldquo;打印机正在使用！&rdquo;如何处理该问题？</blockquote>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/aa78d199aabb4b53b6071167c1905718" alt="" data-ic="false" data-ic-uri="" data-height="206" data-width="977" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<h3>微内核操作系统</h3>
<ul>
<li><strong>微内核操作系统</strong></li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3-tt.bytecdn.cn/large/pgc-image/3233e06fc72544caad04e6ac582c8e88" alt="" data-ic="false" data-ic-uri="" data-height="152" data-width="896" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper ttcore-relative"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1-tt.bytecdn.cn/large/pgc-image/7fd5e6653dd940ce812bee64589f71fd" alt="" data-ic="false" data-ic-uri="" data-height="428" data-width="1055" />
<div class="editor-image-menu">&nbsp;</div>
</div>
<div class="pgc-img-caption-wrapper">&nbsp;</div>
</div>]]></description></item><item><title>软考自查：计算机组成原理和体系结构</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/22/10420491.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 22 Feb 2019 12:19:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/22/10420491.html</guid><description><![CDATA[<h3>计算机组成原理与体系结构</h3>
<p><strong>内容提要</strong></p>
<ul>
<li><strong>数据的表示</strong></li>
<li><strong>计算机结构</strong></li>
<li><strong>Flynn分类法</strong></li>
<li><strong>CISC与RISC</strong></li>
<li><strong>流水线技术</strong></li>
<li><strong>存储系统</strong></li>
<li><strong>总线系统</strong></li>
<li><strong>可靠性</strong></li>
<li><strong>校验码</strong></li>
</ul>
<h3>数据的表示</h3>
<ul>
<li><strong>数据的表示</strong></li>
</ul>
<blockquote>R进制转十进制使用按权展开法，其具体操作方式为:将R进制数的每一位数值用Rk形式表示,即幂的底数是R ,指数为k , k与该位和小数点之间的距离有关。当该位位于小数点左边, k值是该位和小数点之间数码的个数,而当该位位于小数点右边, k值是负值，其绝对值是该位和小数点之间数码的个数加1。</blockquote>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/402e73b668cf44f78ebaf87affd649bf" alt="" data-ic="false" data-ic-uri="" data-height="198" data-width="934" /></div>
</div>
<h3>十进制转R进制使用短除法。</h3>
<ul>
<li>例如将94转换为二进制数。</li>
</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/a4a8f3afae664e4cb56b2664e87e7e64" alt="" data-ic="false" data-ic-uri="" data-height="392" data-width="557" /></div>
</div>
<h3>二进制转八进制与十六进制数。</h3>
<ul>
<li>例题</li>
</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper" style="text-align: center;"><img src="http://p1.pstatp.com/large/pgc-image/a6782f8c4e45424c8ccca7cc9563efd3" alt="" data-ic="false" data-ic-uri="" data-height="396" data-width="255" />&nbsp;</div>
</div>
<h3>数据的表示</h3>
<ul>
<li>原码</li>
<li>反码</li>
<li>补码</li>
<li>移码</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper" style="text-align: center;"><img src="http://p3.pstatp.com/large/pgc-image/5836c0b2608241ec9428485262a8189d" alt="" data-ic="false" data-ic-uri="" data-height="286" data-width="808" /></div>
</div>
<h3>数值表示范围</h3>
<ul>
<li>数值表示范围</li>
</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9.pstatp.com/large/pgc-image/c5ac065d2a7447878a7c844b7a4d1ca0" alt="" data-ic="false" data-ic-uri="" data-height="363" data-width="638" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<h3>数据的表示-浮点数运算</h3>
<ul>
<li>数据的表示-浮点数运</li>
</ul>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/23ab101a88e04230abae7fc46d9f05f6" alt="" data-ic="false" data-ic-uri="" data-height="327" data-width="928" />
<div class="editor-image-menu">&nbsp;</div>
</div>
</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><br />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<hr />
<h3>计算机结构</h3>
<ul>
<li>计算机结构</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/90d1cdcbd7ca4d8d9093aebf64a3bf77" alt="" data-ic="false" data-ic-uri="" data-height="533" data-width="1146" /></div>



</div>
<h3>计算机体系结构分类-Flynn</h3>
<ul>
<li>计算机体系结构分类-Flynn</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9.pstatp.com/large/pgc-image/cae44dc311ec450d867a7a67b25b4f74" alt="" data-ic="false" data-ic-uri="" data-height="476" data-width="926" /></div>



</div>
<h3>CISC与RISC</h3>
<ul>
<li>CISC与RISC</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/7c3f8372fcd448d18c1d9b442959bc15" alt="" data-ic="false" data-ic-uri="" data-height="344" data-width="1118" /></div>



</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><br />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<hr />
<h3>流水线-概念</h3>
<blockquote>流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各个部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。</blockquote>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/16106be6bfc944518319da13ad992dff" alt="" data-ic="false" data-ic-uri="" data-height="389" data-width="973" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<h3>流水线-流水线计算</h3>
<blockquote>例：若指令流水线把一条指令分为取指令、分析和执行三部分，且三部分的时间分别是取指ns分析ns执行ns。那么，流水线周期是多少？100条指令全部执行完毕需要的时间是多少？理论公式得：2+2+1=5(100-1）*2=1985+198=203实践公式：k=3のt=2</blockquote>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/f7b3f278cf46451b8b52bf23c0ceae4e" alt="" data-ic="false" data-ic-uri="" data-height="262" data-width="625" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/b191656ab9fa418ca9dae41b88e51081" alt="" data-ic="false" data-ic-uri="" data-height="255" data-width="425" /></div>



</div>
<h3>流水线-流水线吞吐率计算</h3>
<ul>
<li>流水线的吞吐率（Though Put rate，TP）是指在单位时间内流水线所完成的任务数量或输出的结果数量。计算流水线吞吐率的最基本的公式如下：</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/022942cefb2f481fa09ce4b5fa46b9c0" alt="" data-ic="false" data-ic-uri="" data-height="138" data-width="481" /></div>



</div>
<h3>流水线最大吞吐率：</h3>
<ul>
<li>流水线最大吞吐率</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/a379acd5c70a4e5182084ab2b27d5f22" alt="" data-ic="false" data-ic-uri="" data-height="156" data-width="519" />
<div class="editor-image-menu">&nbsp;</div>



</div>
<div class="pgc-img-caption-wrapper"><span style="font-size: 1.17em;">流水线-流水线的加速比</span></div>



</div>
<ul>
<li>完成同样的一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。计算流水线加速比的基本公式 如下：</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/e468309f425a43a9893a3abef15b1aa3" alt="" data-ic="false" data-ic-uri="" data-height="123" data-width="446" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<h3>流水线-流水线的效率</h3>
<ul>
<li>流水线的效率是指流水线的设备利用率。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水线段总的时空区之比。</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/9f120b1d79314c44844d4dc712060dfb" alt="" data-ic="false" data-ic-uri="" data-height="93" data-width="647" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/fd680741cbe340da9b5f1eb348068197" alt="" data-ic="false" data-ic-uri="" data-height="342" data-width="705" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<h3>计算流水线效率的公式为：</h3>
<ul>
<li>计算流水线效率的公式为</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/3d6bb7b855e54458a02a2ebe408dd3d7" alt="" data-ic="false" data-ic-uri="" data-height="106" data-width="394" /></div>



</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><br />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<hr />
<h3>层次化存储结构</h3>
<ul>
<li>层次化存储结构</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/8c71cc24a7d74aee93c6c1480e01873f" alt="" data-ic="false" data-ic-uri="" data-height="497" data-width="970" /><input class="pgc-img-caption-ipt" type="text" value="层次化存储结构" /></div>



</div>
<h3>Cache-概念</h3>
<ul>
<li>Cache的功能：提高CPU数据输入输出的速度，突破冯、诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。</li>
<li>在计算机的存储系统中，Cache是访问速度最快的层次。</li>
<li>使用Cache改善系统性能的依据是程序的局部性原理。</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/ee1323bae7d84513ad0daa1bad136be7" alt="" data-ic="false" data-ic-uri="" data-height="202" data-width="992" /></div>



</div>
<h3>局部性原理</h3>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
<li>工作集理论：工作集是进程运行时被频繁访问的页面集合</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/423e4cbc3a11432c89094c501c93a858" alt="" data-ic="false" data-ic-uri="" data-height="275" data-width="411" /></div>



</div>
<h3>主存-分类</h3>
<ul>
<li>随机存取存储器</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/8a25d02e4abf4a4791ca4fda1768263b" alt="" data-ic="false" data-ic-uri="" data-height="104" data-width="600" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<ul>
<li>只读存储器</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/45df06c286c547eb889b88f0d5e67a2c" alt="" data-ic="false" data-ic-uri="" data-height="212" data-width="592" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<h3>主存-编址</h3>
<ul>
<li>编址</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/0871787a89524e939d83717245306a75" alt="" data-ic="false" data-ic-uri="" data-height="456" data-width="1070" /></div>



</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p9.pstatp.com/large/pgc-image/00be4b109bfb4d22a8416244b53de439" alt="" data-ic="false" data-ic-uri="" data-height="205" data-width="1094" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<ul>
<li>B：112</li>
<li>A：4</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper">&nbsp;</div>



</div>
<hr />
<h3>磁盘结构与参数</h3>
<ul>
<li>磁盘结构</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/23c3003e0f2c4d14b0e6b4dd439ddaa0" alt="" data-ic="false" data-ic-uri="" data-height="240" data-width="808" /></div>



</div>
<ul>
<li>存取时间=寻道时间+等待时间（平均定位时间+转动延迟）</li>



</ul>
<p>注意：寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁头下方所用的时间。</p>
<ul>
<li>试题</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/4673235d7e6f42bc8d57bf9203d6d19d" alt="" data-ic="false" data-ic-uri="" data-height="520" data-width="1103" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper">&nbsp;</div>



</div>
<hr />
<h3>总线</h3>
<p>根据总线所处的位置不同，总线通常被分为三种类型，分别是：</p>
<ul>
<li>内部总线</li>
<li>系统总线（数据总线 地址总线 控制总线</li>
<li>外部总线</li>



</ul>
<h3>系统可靠性分析-串联系统与并联系统</h3>
<ul>
<li>串联：</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/56ec385051264a41beaa1dfa628bd3fd" alt="" data-ic="false" data-ic-uri="" data-height="204" data-width="804" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<ul>
<li>并联：</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/3e129651f45b45ba929141852e09b318" alt="" data-ic="false" data-ic-uri="" data-height="254" data-width="977" /></div>



</div>
<h3>系统可靠性分析-模冗余系统与混合系统</h3>
<ul>
<li>模冗余系统</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/d6d1647fd2e34556bd239b578831b0bc" alt="" data-ic="false" data-ic-uri="" data-height="246" data-width="981" /></div>



</div>
<ul>
<li>混合系统</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p3.pstatp.com/large/pgc-image/29ce6a6f6a8c4803a5b8530cdc770078" alt="" data-ic="false" data-ic-uri="" data-height="237" data-width="967" /></div>



</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper">&nbsp;</div>



</div>
<hr />
<h4>差错控制-CRC与海明校验码</h4>
<p>什么是检错和纠错？</p>
<ul>
<li>检错是检查错误</li>
<li>纠错家检查错误并纠正错误</li>



</ul>
<p>什么是码距?</p>
<ul>
<li>一个编码系统的码距是整个编码系统中任意(所有)两个码字的最小距离。</li>



</ul>
<p>例:</p>
<blockquote>若用1位长度的二进制编码。若A=1, B-0。这样A, B之间的最小码距为1。若用2位长度的二进制编码，若以A=11, B :00为例，A、B之间的最小码距为2。若用3位长度的二进制编码，可选用111, 000作为合法编码。A, B之间的最小码距为3.</blockquote>
<p>码距与检错、纠错有何关系?</p>
<blockquote>1.在一个码组内为了检测e个误码，要求最小码距d应该满足: d&gt;=e+12.在一个码组内为了纠正t个误码，要求最小码距d应该满足: d&gt; =2t+1</blockquote>
<h3>校验码-循环校验码CRC</h3>
<p>什么是模2除法，它和普通的除法有何区别?</p>
<ul>
<li>模２除法是指在做除数运算的过程中不计其进位的除法。</li>



</ul>
<p>例如，10111对110进行模２除法为：</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/d975c30ccd3f47609187661cb8a498f7" alt="" data-ic="false" data-ic-uri="" data-height="357" data-width="807" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<h3>校验码－循环校验码CRC</h3>
<ul>
<li>循环校验码CRC</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/06048761f5fd4410a16e7f6923bc937f" alt="" data-ic="false" data-ic-uri="" data-height="140" data-width="515" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/0a828dad6b674e5bb0afced205528dce" alt="" data-ic="false" data-ic-uri="" data-height="584" data-width="513" />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>
<h3>校验码－海明校验码</h3>
<ul>
<li>海明校验码</li>



</ul>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><img style="display: block; margin-left: auto; margin-right: auto;" src="http://p1.pstatp.com/large/pgc-image/2a586504b2694eb8947150137f1720f1" alt="" data-ic="false" data-ic-uri="" data-height="598" data-width="1094" /></div>



</div>
<p>&nbsp;</p>
<div class="pgc-image pgc-card-fixWidth">
<div class="pgc-img-wrapper"><br />
<div class="editor-image-menu">&nbsp;</div>



</div>



</div>]]></description></item><item><title>软考自查：面向对象设计</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/22/10418787.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Fri, 22 Feb 2019 07:44:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/22/10418787.html</guid><description><![CDATA[<h2 style="text-align: center;">需求开发&mdash; 需求分析&mdash;相关概念</h2>
<h3>对象</h3>
<p>【对象建模的目的就是描述对象】</p>
<h3>类</h3>
<p>【通过将对象抽象成类，我们可以使问题抽象化，抽象增强了模型的归纳能力】（（数据类）实体类,（边界和外界相连交互）边界类，（做衔接作用）控制类）</p>
<h3>抽象</h3>
<p>【抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关】</p>
<h3>封装</h3>
<p>【封装性是保证软件部件具有优良的模块性的基础】</p>
<h3>继承与泛化</h3>
<p>【继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容】（继承：子类继承父类）（泛化：把共性抽出成一个上层的类）</p>
<h3>多态</h3>
<p>【多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性】</p>
<h3>接口</h3>
<p>【描述对操作规范的说明，其只说明操作应该做什么，并没有定义操作如何做。可以将接口理解成为类的一个特例，它规定了实现此接口的类的操作方法，把真正的实现细节交由实现该接口的类去完成】（是一种特殊的类 只有方法的定义没有方法的实现）</p>
<h3>消息</h3>
<p>【体现对象间的交互，通过它向目标对象发送操作请求】</p>
<h3>组件</h3>
<p>【表示软件系统可替换的、物理的组成部分，封装了模块功能的实现。组件应当是内聚的，并具有相对稳定的公开接口】</p>
<h3>模式和复用</h3>
<p>【复用：指将已有的软件及其有效成分用于构造新的软件或系统。组件技术是软件复用实现的关键。</p>
<p>模式：描述了一个不断重复发生的问题，以及该问题的解决方案。其包括特定环境、问题和解决方案3个组成部分。应用设计模式可以更加简单和方便地去复用成功的软件设计和架构，从而帮助设计者更快更好地完成系统设计。】</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2 style="text-align: center;">面向对象设计-设计原则</h2>
<p><strong>单一职责原则</strong>：设计目的单一的类</p>
<p><strong>开发-封闭原则</strong>：对扩展开放，对修改封闭</p>
<p><strong>李氏（Liskov）替换原则</strong>：子类可以替换父类</p>
<p><strong>依赖倒置原则</strong>：要依赖于抽象，而不是具体实现；针对接口编程，不要针对接口编程，不要针对实现编程</p>
<p><strong>接口隔离原则</strong>：使用多个专门的接口比使用单一的总接口要好</p>
<p><strong>组合重用原则</strong>：要尽量使用组合，而不是继承关系达到重用目的</p>
<p><strong>迪米特（Demeter）原则（最少知识法则）</strong>：一个对象应当对其他对象有尽可能少的了解&nbsp;&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2 style="text-align: center;"><strong>面向对象设计-设计模式的概念</strong></h2>
<p><strong>架构模式</strong>：软件设计中的高层决策，例如C/S架构就属于架构模式，架构模式反映了开发软件系统过程中所有的基本设计决策</p>
<p><strong>设计模式</strong>：主要关注软件系统的设计，与具体的实现语言无关</p>
<p><strong>惯用法</strong>：是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构建与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2 style="text-align: center;">面向对象设计-设计模式的分类</h2>
<p><strong>创建型模式</strong></p>
<p><strong>结构型模式</strong></p>
<p><strong>行为型模式</strong></p>
<h3>结构型模式</h3>
<p>适配器(_adapter）模式</p>
<p>桥接（bridge）模式</p>
<p>组合（composite）模式</p>
<p>装饰（decorator）模式</p>
<p>外观（facade）模式</p>
<p>享元（flyweight）模式</p>
<p>代理（proxy）模式</p>
<h3>创建型模式</h3>
<p>工厂方法（_factory method）模式</p>
<p>抽象工厂（abstract factory）模式</p>
<p>原型（prototype）模式</p>
<p>单例（singleton）模式</p>
<p>构建器（builder）模式</p>
<h3>行为型模式</h3>
<p>职责链（chain of responsibility）模式</p>
<p>命令（command）模式</p>
<p>解释器（_interpreter）模式</p>
<p>迭代器（iterator）模式</p>
<p>中介者（mediator）模式</p>
<p>备忘录（memento）模存储</p>
<p>观察者（observer）模式</p>
<p>状态（state）模式</p>
<p>策略（strategy）模式</p>
<p>模板方法（_template method）模式</p>
<p>访问者（visitor）模式</p>
<blockquote>有下划线的表示既可以是类模式，也可以是对象模式；无下划线的表示只是对象模式</blockquote>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<h2 style="text-align: center;">面向对象设计-创建型模式</h2>
<ul>
<li><strong>设计模式名称&nbsp;</strong></li>
<li><strong>&nbsp;简要说明</strong></li>
</ul>
<h3>Abstract Factory 抽象工厂模式</h3>
<p>提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类</p>
<h3>Builder 构建器模式</h3>
<p>将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示</p>
<h3>Factory Method 工厂方法模式</h3>
<p>定义一个创建对象的接口，但由于类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟</p>
<h3>Prototype 原型模式</h3>
<p>用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象</p>
<h3>Singleton 单例模式</h3>
<p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p>
<h2 style="text-align: center;">面向对象设计-结构型模式</h2>
<ul>
<li>设计模式名称&nbsp;&nbsp;&nbsp;</li>
<li>简要说明&nbsp;</li>
<li>速记关键字</li>
</ul>
<h3>Adapter 适配器模式</h3>
<p>将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作</p>
<p>转换接口</p>
<h3>Bridge 桥接模式</h3>
<p>将类的抽象部分和它的实现部分分离开来，使它们可以独立的变化</p>
<p>继承树拆分</p>
<h3>Composite 组合模式</h3>
<p>将对象组合成树型结构以表示&ldquo;整体-部分&rdquo;的层次结构，使得用户对单个对象和组合对象的使用具有一致性</p>
<p>树形目录结构</p>
<h3>Decorator 装饰模式</h3>
<p>动态地给一个对象添加一些额外的指责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活</p>
<p>附加职能</p>
<h3>Facade 外观模式</h3>
<p>定义一个高层次接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用</p>
<p>对外统一接口</p>
<h3>Flyweight 享元模式</h3>
<p>提供支持大量细粒度对象的有效方法</p>
<h3>Proxy 代理模式】</h3>
<p>为其它对象提供一种代理以控制这个对象的访问</p>
<h2 style="text-align: center;">面向对象设计-行为型模式</h2>
<ul>
<li>设计模式名称</li>
<li>简要说明</li>
<li>速记关键字</li>
</ul>
<h3>Chain of responsibility　职责链模式</h3>
<p>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接受对象链接起来，在链中传递请求，直到有一个对象处理这个请求</p>
<p>传递职责</p>
<h3>Command　命令模式</h3>
<p>将一个请求封装为一个对象，从而可以用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</p>
<p>日志记录，可撤销</p>
<h3>Interpreter　解释器模式</h3>
<p>给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</p>
<h3>Iterator　迭代器模式</h3>
<p>提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示</p>
<h3>Mediator　中介者模式</h3>
<p>用一个中介对象来封装一系列的对象交互。它使各对象不需要显示的相互调用，从而达到低耦合，还可以独立的改变对象间的交互</p>
<h3>Memento　备忘录模式</h3>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态</p>
<h3>Observer　观察者模式</h3>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</p>
<h3>State　状态模式</h3>
<p>允许一个对象在其内部状态改变时改变它的行为</p>
<p>状态变成类</p>
<h4>Strategy　策略模式</h4>
<p>定义一系列算法，把它们一个个封装起来，并且使他们之间可互相替换，从而让算法可以独立于使用它们的用户而变化</p>
<p>多方案切换</p>
<h3>Template method　模板方法模式</h3>
<p>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构既可以重新定义算法的某些特定的步骤</p>
<h3>Visitor　访问者模式</h3>
<p>表示一个作用于某对象结构中的各个元素的操作，使得在不改变各个元素的类的前提下定义作用于这些元素的新操作</p>
<p>&nbsp;</p>]]></description></item><item><title>软考知识分析</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/18/10396585.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Mon, 18 Feb 2019 09:03:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2019/02/18/10396585.html</guid><description><![CDATA[<p>软件设计介绍</p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201902/1444343-20190218174444104-1457186895.png" alt="" /></p>
<p>考试的历史：从日本引进</p>
<p>策略：先建体系，后整理知识点 目标明确 明确自己的薄弱点&nbsp;把时间集中在短板上</p>
<p>方法：教材只是工具书 遇到知识点不懂得勤百度</p>
<p>特点：广泛 知识点多 知识广度大</p>
<p>&nbsp;</p>
<p>上午部分 ：计算机与软件工程知识考试</p>
<p>知识点&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 说明</p>
<p><strong>软件工程基础知识</strong> <br /> 开发模型 设计原则 测试方法 质量特征 CMM pert图 风险管理</p>
<p><strong>面向对象</strong><br /> 面向对象基本概念 面向对象分析与设计 UML 设计模式</p>
<p><strong>数据结构与算法</strong><br /> 数组 栈 队列 树与二叉树 图 查找与排序 常见算法</p>
<p><strong>程序设计语言</strong><br /> 文法 有限自动机 正规式 语句的作用 语句的语义 程序的控制结构<br /> 函数调用的参数传递 各种程序语言的特点比较</p>
<p><strong>计算机硬件基础</strong><br /> 浮点数运算 溢出 算术 逻辑运算 计算机体系结构分类 指令系统基础<br /> CISC与RISC 流水线 Cache存储器可靠性分析 校验方法 </p>
<p><strong>操作系统</strong><br /> 进程状态转换图 信号量与PV操作 思索问题 银行家算法 段页式存储 页面置换算法 磁盘调度 树形文件系统</p>
<p><strong>数据库系统</strong><br /> E-R模型 关系代数 元组演算 规范化理论（键 范式 模式分解）<br />并发控制</p>
<p><strong>计算机网络</strong><br /> OSI模型 TCP/IP协议族 子网划分 常用的网络命令</p>
<p><strong>信息安全知识</strong><br /> 加密解密技术 网络安全 计算机病毒</p>
<p><strong>多媒体基础</strong><br />多媒体基本概念 计算声音 图像 视频文件的容量 JPEG　MPEG</p>
<p><strong>知识产权与标准化</strong><br />作品保护时间　侵权判定　知识产权归属　标准的分类　标准代号</p>
<p>&nbsp;</p>
<p>下午部分：软件设计</p>
<p><strong>数据流图　</strong><br />补充数据流图的缺失部分（补充数据流　补充外部实体　补充数据存储）　数据流图的改错（包括修正数据流名称　数据流的起点与终点　删除多余数据流）　与数据流图相关的概念简单题<br />　　<br /><strong>数据库设计　</strong>E-R模型　关系模式　主键　外键　SQL语言</p>
<p><strong>UML建模</strong>　用例图　类图与对象图　顺序图　活动图　状态图</p>
<p><strong>C语言算法</strong>　链表　栈　二叉树　图基本操作的程序实现　动态规划法<br />分治发　回溯法　递归法　贪心法</p>
<p>选答题　<strong>C++语言程序设计</strong>　C++语法　＋　设计模式<br />　　　　<strong>JAVA语言程序设计</strong>　JAVA语法　＋　设计模式</p>
<p>&nbsp;<img src="https://img2018.cnblogs.com/blog/1444343/201902/1444343-20190218174357353-1529421920.png" alt="" /></p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201902/1444343-20190218174413396-2056319127.png" alt="" /></p>
<p><img src="https://img2018.cnblogs.com/blog/1444343/201902/1444343-20190218174424747-199184920.png" alt="" /></p>
<p>注意事项： <br />1、系统集成项目管理工程师的考试大纲以2016年新版大纲为准；系统分析师、软件设计师、网络工程师、程序员、网络管理员的考试大纲以2009年新版大纲为准；其余各考试项目的考试大纲、指定用书和辅导用书将根据2004年大纲使用最新版教材。2013年工业和信息化部教育与考试中心对信息处理技术员、嵌入式系统设计师、数据库系统工程师、电子商务设计师等专业资格的考试大纲和教材进行了修编，2016年对软件设计师、网络工程师、程序员、系统集成项目管理工程师教材进行了修编。</p>
<p>2、信息处理技术员应用技术科目采用分批机考，其他考试科目均采用笔试。</p>
<p>3、各科目考试均及格才能合格。</p>
<p>报考条件 ： <br />1、遵纪守法，恪守职业道德； <br />2、具有一定计算机技术应用能力。 <br />报考任何级别都不限学历和资历条件。 <br />报名手续 ：登录报名系统进行网上报名 </p>]]></description></item><item><title>大数据的行业与技术趋势</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2018/08/12/9463342.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Sun, 12 Aug 2018 08:18:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2018/08/12/9463342.html</guid><description><![CDATA[<ul>
<li>大数据时代</li>
<li>大数据的应用领域</li>
<li>大数据时代企业所面临的机遇和挑战</li>
<li>基于华为大数据解决方案</li>
</ul>
<p>　　<strong>1.各国都将大数据作为国家战略</strong></p>
<p>　　全球各主要经济体都已将数据开放作为国家战略，促进未来经济发展。中国在顶层设计 上已经开始布局大数据产业r</p>
<p>　　<strong>2.中国实施国家大数据战略</strong></p>
<p>　　实施国家大数据战略 加快建设数字中国</p>
<ol>
<li>要推动大数据技术产业创新发展</li>
<li>要构建以大数据为关键要素的数字经济</li>
<li>要运用大数据提升国家治理现代化水平</li>
<li>要运用大数据促进保障和改善民生</li>
<li>要切实保障国家数据安全</li>
</ol>
<p>　　2017年12月8日，国家主席在中共中央政治局第二次集体学习时强调，审时度势精心 谋划超前布局力争主动，实施国家大数据战略加快建设数字中国。&nbsp;</p>
<p>　　<strong>3.大数据时代</strong></p>
<p>　　维基百科的定义：</p>
<p>　　大数据是指利用常用软件工具捕获，管理和处理数据所耗时间超过可容忍时间的数据集。</p>
<p><img src="https://images2018.cnblogs.com/blog/1444343/201808/1444343-20180812152231054-1285854596.png" alt="" /></p>
<p>&nbsp;</p>
<p>在3V的基础上，业界对4V的定义加上了价值密度低（Value），而IBM对4V的定义加上 了真实准确（Veracity）。&nbsp;</p>
<p>目前对大数据尚未有一个公认的定义，不同的定义基本上是从特征出发，试图给出大数 据的定义。　</p>
<p>　　<strong>4.数据的产生</strong></p>
<p>　　&nbsp;Google 上每天需要处理24PB的数据 ，全球每秒钟发送 2.9 百万封电子邮件，每天会有 2.88 万个小时的视频上传到Youtube，足够一个人昼夜不息的观看3.3 年&hellip;推特上每天 发布 5 千万条消息，假设10 秒钟浏览一条信息，这些消息足够一个人昼夜不息的浏览 16 年&hellip;每天亚马逊上将产生 6.3 百万笔订单&hellip;每个月网民在Facebook 上要花费7 千亿 分钟，被移动互联网使用者发送和接收的数据高达1.3EB。RFID是一种非接触式的自动 识别技术，可识别高速运动物体并可同时识别多个电子目标。在超市中运用很多</p>
<p>　<strong>　5.所有生意都是数据生意</strong></p>
<p>　　不管你现在做什么行业，你做的生意都是数据生意。你关于客户的这些数据，其实跟你 的客户对于你来说是同样重要的。数据可以通过网络流转，从一个格式变成另一个格式。 数据不应该以它的存储而定义，应该由它的流转来定义。 过去的数据时代，我们使用文件、文件夹、桌面这些东西。进入网络时代之后，数据就 出现在网页上、链接里。今天我们用云，用标签、流来比喻数据。对现在来说，文件夹、 网页什么的就不是最重要的数据。所有的东西都在我们的数据流里，有信息、有新闻。 过去的关键词是我，现在的关健词是我们;过去的关键词是项目，现在的关健词是数据。 我们处于整个互联网新时代的第一天，此时此刻最重要的。接下来我们就需要了解如何 量化自己，我也一直在参与这样的项目，把我们自身的一些信息去数据化。&nbsp;</p>
<p>　　我们使用很多设备去进行自我量化。我认识的一些人，会在身上装40多个传感器，不停 地检测自己的数据。我曾经跟一个人打赌说，任何一个只要是人类用工具可以测量的数 据，都一定在被测量。我们为什么要跟踪这些数据?有健康的原因，社交的原因，提高 工作效率的原因。还有很多非常前沿的数据测量工具，比如说有一种工具可以去分析我 们呼吸气体里面的化合物，通过分析呼吸来判断你的血液情况。苹果推出的手表也是不 停采集你的数据，通过APP进行处理。通过数据分析，我们可以看到哪天的工作效率较 高，在那天我们吃了什么，做了哪些事情来提高效率。我们就可以通过这样的方式更好 地了解自己，提高生产效率。&nbsp;</p>
<p>　　<strong>6.大数据时代与传统数据处理的差异</strong></p>
<table style="height: 287px; width: 514px;" border="3"><caption>&nbsp;</caption>
<tbody>
<tr>
<td>&nbsp;</td>
<td>数据库</td>
<td>大数据</td>
</tr>
<tr>
<td>
<p>数据规模</p>
</td>
<td>
<p>小（以MB为处理单位）</p>
</td>
<td>
<p>大(以GB，TB，PB，为处理单</p>
<p>位）</p>
</td>
</tr>
<tr>
<td>
<p>数据类型</p>
</td>
<td>单一（结构化为主）</td>
<td>
<p>繁多（结构化，半结构化，非</p>
<p>结构化）</p>
</td>
</tr>
<tr>
<td>
<p>模式和数据</p>
<p>的关系</p>
</td>
<td>
<p>现有模式后有数据</p>
</td>
<td>
<p>先有数据后又模式，模式随数</p>
<p>据增多不断演变</p>
</td>
</tr>
<tr>
<td>
<p>处理对象</p>
</td>
<td>数据（池塘中的鱼）</td>
<td>
<p>（鱼通过某些鱼判断</p>
<p>其他种类的鱼是否存在</p>
</td>
</tr>
<tr>
<td>
<p>处理工具</p>
</td>
<td>one size fits all</td>
<td>no size fits all</td>
</tr>
</tbody>
</table>
<p>　　<strong>7.大数据的时代已经到来</strong></p>
<p>　　大数据时代的&ldquo;破坏性创新&rdquo; &ldquo;破坏性创新&rdquo;是克里斯坦森教授那本著名的《创新者的 窘境》书中提到的概念。他告诉我们，创新在一个既已成功的主体中是多么难以发生。 1800年代，当时世界上最盈利的企业是那些经营帆船的公司，它们已经成为全球性企业。 随后蒸汽船被发明了，没有帆，靠蒸汽轮机发动。蒸汽船出现伊始，是一种体验很糟的 交通工具&mdash;&mdash;跟大帆船相比又小又短，制造价格非常昂贵，可靠性也很差。当时的大船 运公司都没有把它放在眼里。&nbsp;</p>
<p>　　然而，尽管种种的不靠谱，但蒸汽船有一个优势，就是可以逆流前进，这改变了人类几 千年只能&ldquo;顺流而下&rdquo;的历史。随着技术的发展，蒸汽船就变得越来越便宜，可靠性也 越来越高，体积也变得越来越大。最后，蒸汽船的技术成熟了，不但消灭了大帆船，也 消灭了那些依赖大帆船做航运的海运公司。&nbsp;</p>
<p>　　破坏性创新技术最初都是个笑话&nbsp;</p>
<p>　　总结起来：破坏性创新的技术都有一个模式：刚开始出现的时候都是不起眼的东西，被 人忽略。可以看到这三条线：上面一条线是在市场上表现非常好的业界领袖，有一个很 平稳的发展曲线;下面一条曲线就是消费者的较低满意度，最下面那个点，是当时出现的 破坏性创新企业。最初的时候，破坏性创新的技术远比客户的要求差，是一个笑话。然 而，当它以更快的速度发展，突然有一天碰到了消费者的需求点，就会产生很快的发展 势头，成为市场上的统治者。&nbsp;</p>
<p>　　<strong>8.大数据和人的关系</strong></p>
<p>　　大数据只是一种处理问题的新型工具，社会的主题还是人自己本身。&nbsp;</p>
<p>　<strong>　9.大数据应用的领域</strong></p>
<p>　　社交网络和物联网技术拓展了数据采集技术渠道。</p>
<p>　　分布式存储和计算技术夯实了大数据处理的技术基础。</p>
<p>　　深度神经网络等新兴技术开辟大数据分析技术的新时代。&nbsp;</p>
<p>　<strong>　10.大数据应用的实例 1 金融</strong></p>
<p>　　沃尔玛第一个利用Hadoop数据的应用节省捕手&mdash;&mdash;只要周边竞争对手降低了客户已经 购买的产品的价格，该应用程序就会提醒客户。然后这个应用程序会向客户发送一个礼 券补偿差价。&nbsp;</p>
<p>　　沃尔玛通过关联规则学习,发现草莓果的销售量在飓风之前增长了7倍。沃尔玛通过数据 挖掘确认飓风和草莓果之间的联系,使得它所有的草莓果在飓风前签出。 沃尔玛单独地 跟踪每个消费者。沃尔玛拥有详尽的将近1.45亿美国客户数据，大约是美国成年人的 60%数据。沃尔玛通过店内WiFi收集关于客户购买的物品、他们住的地方，他们喜欢的 产品等信息。沃尔玛实验室的大数据团队分析用户在Walmart.com的点击行为，消费者 在店内和线上购买的物品,推特上的趋势,当地的活动（如旧金山巨人队赢得世界大赛）, 当地天气偏差如何影响购买模式,等等。所有的活动都是在由大数据算法捕获和分析从而 识别有意义的大数据洞察力，而这可帮助数百万客户享受个性化的购物体验。&nbsp;</p>
<p>　　<strong>11.大数据应用的实例 2 教育</strong></p>
<p>　　教育改革</p>
<p>　　大数据为基础教育和高等教育提供技术支持，分析从学生的心理活动、学习行为、 考试分数到职业规划等所有重要的信息。现有许多教学数据已经被诸如美国国家 教育统计中心之类的政府机构储存起来用于统计和分析。大数据分析最终目的是 为了改善学生的学习成绩。并利用它们为改善学生的成绩提供个性化的服务。与 此同时，它还能改善学生期末考试的成绩、平时的出勤率、辍学率、升学率等， 还可以促进教育领域方面的均衡化发展。&nbsp;</p>
<p>　　&nbsp;学习分析</p>
<p>　　现今的老师通过大数据得到的不再是过去那种只展示学生分数与作业的结果，而 是通过监控学生浏览数字化学习资源次数、提交电子版的作业完成度、在线师生 和生生互动指数、考试与测验完成度，就能让其系统持续和精确分析每个学生参 与教学活动的数据。比如阅读材料的时间长短和次数等这样更为详细的重要信息， 这样老师就能及时诊断问题的所在，提出改进的建议，并预测学生的期末考试成 绩。&nbsp;</p>
<p>　　考试评价</p>
<p>　　大数据要求教育工作者必须更新和超越传统观念，不能只追求正确的答案，学生 是如何完成整个教学过程的行为过程也同样重要。在一次考试中，学生在每道题 上花费了多少时间？最长的是多少？最短的是多少？平均又是多少？哪些此前已 经出现过的问题学生答对或答错了？哪些问题的线索让学生获益了？通过监测这 些信息，通过学习自适应系统，为学生提供个性化的学习方案和学习路径，形成 个人学习数据档案，能够帮助教育工作者理解学生为了掌握学习内容而进行学习 的全过程，并有助于向他们进行&ldquo;因材施教&rdquo;。&nbsp;</p>
<p>　　<strong>12.大数据应用的实例 3 出行</strong></p>
<p>　　国内有2亿手机用户使用百度地图，用户每次位置变化，百度都能得到数据。把手机 网民的定位信息汇总成大数据进行分析，就能勾勒出人们的迁徙轨迹。 <br />　　此次百度图景化地展示春运情况，是基于LBS(基于地理位置的服务)技术的一次创新。 它的数据每8小时更新一次，囊括了全国铁路、公路和航空在内的线路。</p>
<p>　　<strong>14.大数据应用的实例&nbsp; 4 旅游</strong></p>
<p>　　针对游客不同的年龄，爱好，经济能力等等特征，给出适合的旅游套餐，以及规避潜在 的旅游风险。&nbsp;</p>
<p>　<strong>　15.大数据应用的实例&nbsp; 5 政府公共安全</strong></p>
<p>　　用云计算以及大量数据定位那些最易受到不法份子侵扰片区，利用大量数据创建一张犯 罪高发地区热点图。在研究某一片区的犯罪率时，将相邻片区的各种因素列为考虑的对 象，为警方更具针对性的锁定犯罪易发点、抓获逃犯提供支持。&nbsp;</p>
<p>&nbsp;　　等等。。。。。。。。。。。。。。。。</p>
<p>　　<strong>16.从批量处理到实时分析</strong></p>
<p>　　<img src="https://images2018.cnblogs.com/blog/1444343/201808/1444343-20180812160246504-1267769746.png" alt="" /></p>
<p><strong>　　17.Hadoop业界参考实践</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1444343/201808/1444343-20180812160424291-189991556.png" alt="" /></p>
<p>　　Intel Hadoop利用SSD、CPU指令优化等技术，比开源HBase查询速度快10倍。</p>
<p>　　在Hadoop之外，Intel独立维护一个开源项目Project Panthera，包括即时分析、文档存 储、分析SQL引擎等。</p>
<p>　　MapR采用新架构重写HDFS，比开源Hadoop性能快3倍，自带快照功能，而且无单点 故障，API兼容。主要合作伙伴为EMC。 <br /> </p>
<p>&nbsp;<strong>　　18.内存计算机业界参考实践</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1444343/201808/1444343-20180812160622656-963411047.png" alt="" /></p>
<p><strong>　　19.流计算业界参考实践</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1444343/201808/1444343-20180812160728831-1356408048.png" alt="" /></p>
<p>　　实时处理发展趋势：通过流计算能力实现海量事件的实时分析和处理， 支撑实时决策和实时推荐等实时应用。&nbsp;</p>
<p><strong>　　20.大数据时代的机遇</strong></p>
<p>　　机遇-大数据蓝海成为企业竞争的新焦点</p>
<p>　　在今天的大数据时代，商业的生态环境在不经意间发生了巨大的变化：网民和消费者的 界限正在变得模糊，无处不在的智能终端，随时在线的网络传输，互动频繁的社交网络 让以往只是网页浏览者的网民的面孔从模糊变得清晰，对于企业来说，他们第一次有机 会进行大规模的精准化的消费者行为研究：主动地拥抱这种变化，从战略到战术层而开 始自我的蜕变和进化将会让他们更加适应这个新的时代，大数据蓝海成为未来竞争的制 高点。&nbsp;</p>
<p><strong>　　21.大数据发展所需要的人才类型</strong></p>
<ul>
<li>大数据系统研发工程师</li>
<li>大数据应用开发工程师</li>
<li>大数据分析师</li>
<li>数据可视化工程师</li>
<li>数据安全研发工程师</li>
<li>数据科学研究人才</li>





</ul>
<p><strong>　　22.华为大数据平台架构框架</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1444343/201808/1444343-20180812161311987-316807077.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>思考</p>
<p>　　1.大数据从什么地方来？这些数据有哪些特点？</p>
<p>　　大数据存在于社交平台、销售记录、政府信息等生活方方面面中。大数据的特点： </p>
<p>　　1、数据规模大；2、数据类型繁多；3、先有数据后有模式；4、数据对象存在联系。&nbsp;</p>
<p>　　2.大数据可以应用到哪些社会领域？</p>
<p>　　政治、金融、教育、出行、旅游、政府公共安全、交通规划、体育。&nbsp;</p>]]></description></item><item><title>python第一阶段总结（2）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2018/08/02/9407219.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 02 Aug 2018 07:05:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2018/08/02/9407219.html</guid><description><![CDATA[<h2 style="text-align: center;">&nbsp;<span style="font-size: 14pt;">python3第一阶段的总结　<strong>　</strong></span></h2>
<p>&nbsp;</p>
<ul>
<li><strong>python3的简介</strong></li>
<li><strong>python3安装及环境变量的操作</strong></li>
<li><strong>python3 基础语法</strong></li>
<li><strong>python3基本数据类型</strong></li>
<li><strong>python3运算符</strong></li>
<li><strong>python3数字</strong></li>
<li><strong>python3字符串</strong></li>
<li><strong>python3 列表</strong></li>
<li><strong>python3元组</strong></li>
<li><strong>python3字典</strong></li>
<li><strong>python3集合</strong></li>
<li><strong>python3条件控制</strong></li>
<li><strong>python3循环语句</strong></li>
<li><strong>python3迭代器与生成器</strong></li>
<li><strong>python3函数</strong></li>
<li><strong>python3数据结构</strong></li>
<li><strong>python3模块</strong></li>
</ul>
<p>&nbsp;</p>
<h2><strong>基础数据类型的分类的详细解释：</strong></h2>
<p><span style="font-size: 18px;">python3中有六个标准的数据类型</span></p>
<ul>
<li><span style="font-size: 18px;">Number(数字)</span></li>
<li><span style="font-size: 18px;">String(字符串)</span></li>
<li><span style="font-size: 18px;">List(列表)</span></li>
<li><span style="font-size: 18px;">Tuple(元组)</span></li>
<li><span style="font-size: 18px;">Sets(集合)</span></li>
<li><span style="font-size: 18px;">Dictionary(字典)</span></li>
</ul>
<p><span style="font-size: 18px;">Python3的六个标准数据类型中：</span></p>
<ul>
<li><span style="font-size: 18px;">不可变数据类型（四个）：Number、String、Tuple、Sets</span></li>
<li><span style="font-size: 18px;">可变数据类型（两个）：List、Dictionary</span></li>
</ul>
<h2><span style="font-size: 14pt;"><strong>*.python3数字</strong></span></h2>
<h3><strong>概念</strong>:<strong><br /></strong></h3>
<p>　　Python3支持int、float、bool、complex（复数）</p>
<p>　　在Python3里，只有一种整数类型int，表示为长整型，没有python2中的Long。</p>
<p>　　内置的type()函数可以用来查询变量所指的对象类型　</p>
<div class="cnblogs_code">
<pre>&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j
　　&gt;&gt;&gt; <span style="color: #0000ff;">print</span><span style="color: #000000;">(type(a), type(b), type(c), type(d))
　　</span>&lt;<span style="color: #0000ff;">class</span> <span style="color: #800000;">'</span><span style="color: #800000;">int</span><span style="color: #800000;">'</span>&gt; &lt;<span style="color: #0000ff;">class</span> <span style="color: #800000;">'</span><span style="color: #800000;">float</span><span style="color: #800000;">'</span>&gt; &lt;<span style="color: #0000ff;">class</span> <span style="color: #800000;">'</span><span style="color: #800000;">bool</span><span style="color: #800000;">'</span>&gt; &lt;<span style="color: #0000ff;">class</span> <span style="color: #800000;">'</span><span style="color: #800000;">complex</span><span style="color: #800000;">'</span>&gt;
　　---------------------------------------------------------------<span style="color: #000000;">
注意：

在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 </span>1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1<span style="color: #000000;"> 和 0，它们可以和数字相加。
Python可以同时为多个变量赋值，如a,b </span>= 1,2<span style="color: #000000;">
一个变量可以通过赋值指向不通类型的对象
数值的除法（</span>/）总是返回一个浮点数，要获取证书使用//<span style="color: #000000;">操作符。
在混合计算时，Python会把整型转换成浮点数
Python还支持复数，复数可以用a</span>+bj，或者complex(a,b)表示，a和b都是浮点数</pre>
</div>
<h2><span style="font-size: 14pt;"><strong>*.python3字符串</strong></span></h2>
<h3><strong>概念：</strong></h3>
<p><em>　　</em>Python中的字符串是以单引号（&rsquo;）或者双引号（&ldquo;）引起来的</p>
<p>　　1，截取字符串格式为：<span class="pun">变量[头下标:尾下标]</span></p>
<div class="cnblogs_code">
<pre>　str = <span style="color: #800000;">'</span><span style="color: #800000;">Yehewudi</span><span style="color: #800000;">'</span>

　　<span style="color: #0000ff;">print</span> (str)　　　　　　 <span style="color: #008000;">#</span><span style="color: #008000;"> 输出字符串</span>
　　<span style="color: #0000ff;">print</span> (str[0:-1])　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出第一个到倒数第二个的所有字符</span>
　　<span style="color: #0000ff;">print</span> (str[0])　　 　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出字符串第一个字符</span>
　　<span style="color: #0000ff;">print</span> (str[2:5])　　　 <span style="color: #008000;">#</span><span style="color: #008000;"> 输出从第三个开始到第五个的字符</span>
　　<span style="color: #0000ff;">print</span> (str[2:])　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出从第三个开始的后的所有字符</span>
　　<span style="color: #0000ff;">print</span> (str * 2)　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出字符串两次</span>
　　<span style="color: #0000ff;">print</span> (str + <span style="color: #800000;">"</span><span style="color: #800000;">TEST</span><span style="color: #800000;">"</span>)　<span style="color: #008000;">#</span><span style="color: #008000;"> 连接字符串</span>
　　---------------------------------------------------------------<span style="color: #000000;">
　　Python使用反斜杠（\）转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符

　　例子：

　　</span>---------------------------------------------------------------
　　&gt;&gt;&gt; <span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">Ye\he</span><span style="color: #800000;">'</span><span style="color: #000000;">)
　　Ye
　　he
　　</span>&gt;&gt;&gt; <span style="color: #0000ff;">print</span>(r<span style="color: #800000;">'</span><span style="color: #800000;">Ye\he</span><span style="color: #800000;">'</span><span style="color: #000000;">)
　　Ye\he
　　</span>&gt;&gt;&gt;
　　---------------------------------------------------------------<span style="color: #000000;">
　　另外，反斜杠（\）可以作为续行符，表示下一行是上一行的延续。也可以使用</span><span style="color: #800000;">"""</span><span style="color: #800000;">...</span><span style="color: #800000;">"""</span>或者<span style="color: #800000;">'''</span><span style="color: #800000;">...</span><span style="color: #800000;">'''</span>跨越多行</pre>
</div>
<h3><strong>常用用法：</strong></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">count　　　　通即字符串里某个字符出现的次数，支持切片

　　语法：str.count(sub, start</span>= 0, end=<span style="color: #000000;">len(string))

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"cainiao chuanqi</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span>(a.count(<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span> 2 -1<span style="color: #000000;">))
　　
　　</span>4
　　---------------------------------------------------------------<span style="color: #000000;">
　　encode　　指定编码格式字符串

　　语法：str.encode(encodeing</span>=<span style="color: #800000;">'</span><span style="color: #800000;">UTF-8</span><span style="color: #800000;">'</span>,errors = <span style="color: #800000;">'</span><span style="color: #800000;">strict</span><span style="color: #800000;">'</span><span style="color: #000000;">)

encoding  要使用的编码
errors  设置不通错误的处理方案
 

　　find　　判断字符串中是否包含自字符串，如果在返回索引值，如果不再返回</span>-<span style="color: #000000;">1支持切片

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">" cainioa chuanqi</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span>(a.find(<span style="color: #800000;">"chuan</span><span style="color: #800000;">"</span><span style="color: #000000;">))
　　
　　</span>7
　　---------------------------------------------------------------<span style="color: #000000;">
　　format　　格式化输出

　　例子：

　　</span>---------------------------------------------------------------
　　<span style="color: #0000ff;">print</span>(<span style="color: #800000;">"</span><span style="color: #800000;">姓名:{name}, 年龄:{age}</span><span style="color: #800000;">"</span>.format(name = <span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, age = 22<span style="color: #000000;">))
　　姓名 蔡，年龄：22</span>
　　---------------------------------------------------------------<span style="color: #000000;">
　　index　　查找字符串是否包含子字符串，如果存在返回索引，不存在报错

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">caichuan</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span>(a.index(<span style="color: #800000;">"a</span><span style="color: #800000;">"</span><span style="color: #000000;">))
　　
　　</span>1
　　---------------------------------------------------------------<span style="color: #000000;">
　　isdigit　　　　判断字符串是否只由数字组成，是返回True，否返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">11</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isdigit())
　　
　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字

　　False: 汉字数字

　　Error: 无

　　isidentifier　　判断字符串是否由字母开头，是返回True，否返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"xiaochen</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isidentifier())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　islower　　　 判断字符串是否由小写字母组成，是返回True，否返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"xiaochen</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.islower())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　isupper　　　判断字符串中所有的字母是否都为大写，是返回True，否则返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">XIAOCHEN</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isupper())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　isspace　　判断字符串是否只由空格组成，是返回True，否则返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">  \t  </span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isspace())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　isalpha　　判断字符串是否只由字母组成，是返回True，否则返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"xiaochen</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isalpha())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
 　　isalnum　　判断字符串是否由字母和数字组成，是返回True，否则返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">xiaochen1234</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isalnum())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
 　　join　　讲序列中的元素以指定的字符连接生成一个新的字符串

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">-</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span>(a.join(<span style="color: #800000;">"xiao</span><span style="color: #800000;">"</span><span style="color: #000000;">))

　x-i-a-0</span><span style="color: #000000;">
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　lower　　将字符串中所有大写字符转为小写

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">AAA</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.lower())

　　aaa
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　replace　　将字符串中的字旧符替换成新字符，替换不超过max次

　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">My name is xiaochen</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span>(a.replace(<span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"chuanqi</span><span style="color: #800000;">"</span><span style="color: #000000;">))

　　My name </span><span style="color: #0000ff;">is</span><span style="color: #000000;"> chuanqi
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　split　　通过指定分隔符对字符串进行分隔，已分割后的字符串为元素组成列表

　　语法：str.split(str</span>=<span style="color: #800000;">""</span>, num=<span style="color: #000000;">string.count(str)).

 str　　分隔符，默认为空格
num　  分隔次数
　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"cai chuan qi</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.split())

　　[</span><span style="color: #800000;">'cai</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">chuan</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">qi</span><span style="color: #800000;">'</span><span style="color: #000000;">]
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　upper　　将字符串中的小写字母转为大写字母

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">aaa</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.upper())

　　AAA
　　</span>---------------------------------------------------------------<span style="color: #000000;">
 

 

不常用的用法：
　　capitalize　　将字符串的第一个字母变成大写,其他字母变小写

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">cai CHUAN qi</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.capitalize())

　Cai chuan qi
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　casefold　　与lower相似

　　两者的区别是：lower() 方法只对ASCII编码，也就是&lsquo;A</span>-<span style="color: #000000;">Z&rsquo;有效，对于其他语言（非汉语或英文）中把大写转换为小写的情况只能用 casefold() 方法

 

　　center　　返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格

　　语法：str.center(width[, fillchar])

width　　字符串的总宽度

fillchar　  填充字符
　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"xiaochen</span><span style="color: #800000;">"</span><span style="color: #000000;">
　　
　　a.center(22</span>, <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">)
　　</span>********yehe********
　　---------------------------------------------------------------<span style="color: #000000;">
　　expandtabs　　将字符串中的tab符号(</span><span style="color: #800000;">'</span><span style="color: #800000;">\t</span><span style="color: #800000;">'</span><span style="color: #000000;">)转为空格，tab为8个空格

 

　　endswith　　　判断字符串自否以指定字符结尾，是返回True，否则返回False，支持切片

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span><span style="color: #000000;">
　　
　　a.endswith(</span><span style="color: #800000;">"chen</span><span style="color: #800000;">"</span><span style="color: #000000;">)
　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　format_map（不清楚）

 

 

　　isnumeric　　判断字符串是否只由数字组成，是返回True，否返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isnumeric())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　True: Unicode数字，全角数字（双字节），罗马数字，汉字数字

　　False: 无

　　Error: byte数字（单字节）

 

　　isdecimal　　判断字符串是否只包含十进制字符返回True，否则返回False

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isdecimal())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　True: Unicode数字，，全角数字（双字节）

　　False: 罗马数字，汉字数字

　　Error: byte数字（单字节）

　　isprintable　　判断字符串中所有字符是否都属于可打印字符

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">123\t</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.isprintable())

　　False
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　istitle　　　　判断字符串中所有的单词首字母为大写，其他字母为小写，是返回True，否则返回Flase

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">This Is A xiaochen!</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span><span style="color: #000000;">(a.istitle())

　　True
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　ljust　　返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串

　　lstrip　  截掉字符串左边的空格或指定字符

　　maketrans　　????

　　partition　　根据指定的分隔符讲字符串进行分隔

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a</span>=<span style="color: #800000;">"</span><span style="color: #800000;">chuanxqi!</span><span style="color: #800000;">"</span>
　　<span style="color: #0000ff;">print</span>(a.partition(<span style="color: #800000;">"x</span><span style="color: #800000;">"</span><span style="color: #000000;">))

　　(</span><span style="color: #800000;">"</span><span style="color: #800000;">chuan</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"x</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"qi</span><span style="color: #800000;">!</span><span style="color: #800000;">"</span><span style="color: #000000;">)
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　rsplit　　通过指定分隔符对字符串进行切片，类似于 split() 方法，只不过是从字符串最后面开始分割。

　　rfind　　返回字符串最后一次出现的位置(从右向左查询)，如果没有匹配项则返回</span>-1<span style="color: #000000;">

　　rindex　 返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，你可以指定可选参数

　　rjust　　返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串

 

　　rpartition　　与partition类似，从后往前。

　　rstrip　  删除 string 字符串末尾的指定字符（默认为空格）.

　　startswith　　用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False，支持切片

　　splitlines　　按照行(</span><span style="color: #800000;">'</span><span style="color: #800000;">\r</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">\r\n</span><span style="color: #800000;">'</span>, \n<span style="color: #800000;">'</span><span style="color: #800000;">)分隔，返回一个包含各行作为元素的列表</span>
<span style="color: #000000;">
　　swapcase　　对字符串的大小写字母进行转换

　　title　　返回</span><span style="color: #800000;">"</span><span style="color: #800000;">标题化</span><span style="color: #800000;">"</span><span style="color: #000000;">的字符串,就是说所有单词都是以大写开始，其余字母均为小写

　　translate　　根据参数table给出的表(包含 </span>256 个字符)转换字符串的字符, 要过滤掉的字符放到 <span style="color: #0000ff;">del</span><span style="color: #000000;"> 参数中

　　zfill　　返回指定长度的字符串，原字符串右对齐，前面填充0

注意：   

Python没有单独的字符类型，一个字符就是长度为1的字符串
反斜杠可以用来转义，使用r可以让反斜杠不发生转义
字符串可以用</span>+<span style="color: #000000;">运算符进行字符串的拼接操作
Python中的字符串有两种索引方式，从左往右以0开始，从右往左以</span>-<span style="color: #000000;">1开始
Python中的字符串不能改变　　　　</span></pre>
</div>
<h2><span style="font-size: 14pt;"><strong>*.python3列表</strong></span></h2>
<h3><strong>概念：</strong></h3>
<p>&nbsp;　　List是Python中使用最频繁的数据烈性。</p>
<p>　　列表可以完成大多数集合类的数据结构实现。列表中元素的类型不相同，它支持数字，字符串甚至可以包含列表（嵌套）。</p>
<p>　　列表是写在方括号&ldquo;[]&rdquo;之间、用逗号分隔的元素列表。</p>
<p>　　和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>　　列表的截取格式为：变量[头下标:尾下标]　　</p>
<div class="cnblogs_code">
<pre>　　list = [ <span style="color: #800000;">'</span><span style="color: #800000;">abcd</span><span style="color: #800000;">'</span>, 786 , 2.23, <span style="color: #800000;">'</span><span style="color: #800000;">cai</span><span style="color: #800000;">'</span>, 70.2<span style="color: #000000;"> ] 
　　tinylist </span>= [123, <span style="color: #800000;">'</span><span style="color: #800000;">cai</span><span style="color: #800000;">'</span><span style="color: #000000;">] 

　　</span><span style="color: #0000ff;">print</span> (list)　　　　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出完整列表 </span>
　　<span style="color: #0000ff;">print</span> (list[0])　　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出列表第一个元素 </span>
　　<span style="color: #0000ff;">print</span> (list[1:3])　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 从第二个开始输出到第三个元素 </span>
　　<span style="color: #0000ff;">print</span> (list[2:])　　　　 <span style="color: #008000;">#</span><span style="color: #008000;"> 输出从第三个元素开始的所有元素 </span>
　　<span style="color: #0000ff;">print</span> (tinylist * 2)　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出两次列表 </span>
　　<span style="color: #0000ff;">print</span> (list + tinylist) <span style="color: #008000;">#</span><span style="color: #008000;"> 连接列表</span></pre>
</div>
<h3><strong>常用用法：</strong></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">append　　在列表末尾添加新的元素

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　a.append(</span><span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span><span style="color: #000000;">)
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)

　　[</span><span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123, <span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span><span style="color: #000000;">]
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　count　　用于统计某个元素在列表中出现的次数。

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123, 123<span style="color: #000000;">]
　　</span><span style="color: #0000ff;">print</span>(a.count(123<span style="color: #000000;">))

　　</span>2
　　---------------------------------------------------------------<span style="color: #000000;">
　　clear　　清空列表

　　extend　　用于在列表末尾一次性追加另一个序列中的多个值

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　b </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">xiao</span><span style="color: #800000;">"</span>, <span style="color: #800000;">chen</span><span style="color: #000000;">]
　　a.extend(b)
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)

　　[</span><span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123, <span style="color: #800000;">"</span><span style="color: #800000;">xiao</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">chen</span><span style="color: #800000;">"</span><span style="color: #000000;">]
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　index　　从列表中找出某个值第一个匹配项的索引位置

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　</span><span style="color: #0000ff;">print</span>(a.index(<span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span><span style="color: #000000;">))

　　</span>1
　　---------------------------------------------------------------<span style="color: #000000;">
 　　insert　　将指定对象插入列表的指定位置

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　a.insert(</span>1, <span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span><span style="color: #000000;">)
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)

　　[</span><span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　</span>---------------------------------------------------------------<span style="color: #000000;">
 　　pop　　删除列表中的一个元素（默认为最后一个），并且返回值为该元素，没有则会报错

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">chuanqi</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　a.pop(</span>1<span style="color: #000000;">)
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)

　　[</span><span style="color: #800000;">"</span><span style="color: #800000;">chuanqi</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　</span>---------------------------------------------------------------<span style="color: #000000;">
 　　remove　　删除列表中某个元素的第一个匹配项，没有则会报错

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">chuanqi</span><span style="color: #800000;">"</span>, 123， <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　a.remove(</span>123<span style="color: #000000;">)
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)

　　[</span><span style="color: #800000;">"</span><span style="color: #800000;">chuanqi</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　</span>---------------------------------------------------------------<span style="color: #000000;">
 　　sort　　对列表进行排序

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [3, 2， 4, 1<span style="color: #000000;">]
　　a.sort()
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)

　　[</span>1, 2, 3, 4<span style="color: #000000;">]
　　</span>---------------------------------------------------------------<span style="color: #000000;">

不常用用法：
 　　reverse　　用于反向列表中元素

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">chuanqi</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, 123<span style="color: #000000;">]
　　a.reverse()
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)

　　[</span>123, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">chuanqi</span><span style="color: #800000;">"</span><span style="color: #000000;">]
　　</span>---------------------------------------------------------------
 </pre>
</div>
<p><br /><strong>注意：</strong></p>
<p>List卸载方括号之间，元素用逗号分隔<br />和字符串一样，list可以被索引和切片<br />List可以用+操作符进行拼接<br />List中的元素是可以改变的</p>
<h2><span style="font-size: 14pt;"><strong>*.python3元组</strong></span></h2>
<h3><strong>概念：</strong></h3>
<p>　　元组与列表类似，不用之处在于元组不能修改。元组卸载小括号里&ldquo;（）&rdquo;，元素之间用逗号分隔</p>
<p><strong>用法：</strong></p>
<p>　　与列表类似，只是不能修改</p>
<p>　　只有count与index函数</p>
<p><strong>注意：</strong></p>
<ul>
<li>和字符串一样，元组可以被索引和切片</li>
<li>元组也可以被索引和切片，方法一样</li>
<li>注意构造包含0或1个元素的元组的特殊语法规则</li>
<li>元组也可以使用+操作符进行拼接</li>








</ul>
<h2><span style="font-size: 14pt;"><strong>python3字典</strong></span></h2>
<h3><strong>概念：</strong></h3>
<p>　　字典是Python中另一个非常游泳的内置数据类型。</p>
<p>　　列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过索引存取。</p>
<p>　　字典是一种映射类型，字典用大括号&ldquo;{}&rdquo;表示，它是一个无序的键(key):值(value)对集合。</p>
<p>　　键(key)必须使用不可变类型。</p>
<p>　　在同一个字典中，键(key)必须是唯一的。</p>
<div class="cnblogs_code">
<pre>　　dict =<span style="color: #000000;"> {} 
　　dict[</span><span style="color: #800000;">'</span><span style="color: #800000;">one</span><span style="color: #800000;">'</span>] = <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">
　　dict[</span>2] = <span style="color: #800000;">"</span><span style="color: #800000;">2</span><span style="color: #800000;">"</span><span style="color: #000000;">

　　testdict </span>= {<span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">code</span><span style="color: #800000;">'</span>:1, <span style="color: #800000;">'</span><span style="color: #800000;">site</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">www.777.com</span><span style="color: #800000;">'</span><span style="color: #000000;">}

　　</span><span style="color: #0000ff;">print</span> (dict[<span style="color: #800000;">'</span><span style="color: #800000;">one</span><span style="color: #800000;">'</span>]) 　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出键为 'one' 的值</span>
　　<span style="color: #0000ff;">print</span> (dict[2]) 　　　　 　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出键为 2 的值</span>
　　<span style="color: #0000ff;">print</span> (testdict) 　　　　　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出完整的字典</span>
　　<span style="color: #0000ff;">print</span> (testdict.keys()) 　　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出所有键 </span>
　　<span style="color: #0000ff;">print</span> (testdict.values()) 　<span style="color: #008000;">#</span><span style="color: #008000;"> 输出所有值</span></pre>
</div>
<h3><span style="font-size: 18pt;"><strong>常用用法：</strong></span></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">clear　　删除字典内所有元素

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: xiaochen<span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">}
　　a.clear
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　fromkeys　　创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>=<span style="color: #000000;"> {}
　　b </span>= [<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span><span style="color: #000000;">]
　　</span><span style="color: #0000ff;">print</span>(a.fromkeys(b, 10<span style="color: #000000;">))

　　{</span><span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>: 10, <span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span>: 10, <span style="color: #800000;">'</span><span style="color: #800000;">test</span><span style="color: #800000;">'</span>: 10<span style="color: #000000;">}
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　get　　函数返回指定键的值，如果值不在字典中返回默认值

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">}
　　</span><span style="color: #0000ff;">print</span>(a.get(<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span><span style="color: #000000;">))
　　
　　yehe
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　items　　以列表返回可遍历的(键, 值) 元组数组(列表转元组)

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">}
　　b </span>=<span style="color: #000000;"> a.items()
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(b)
　　
　　dict_items([(</span><span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">'</span>), (<span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span>, 18<span style="color: #000000;">)])
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　keys　　已列表的形式返回一个字典所有的键　

　　pop　　删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">}
　　a.pop(</span><span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span><span style="color: #000000;">)
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)
　　
　　{</span><span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span>: 18<span style="color: #000000;">}
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　popitem　　随机返回并删除字典中的一对键和值(一般删除末尾对)，如果字典为空则报错

　　setdefault　　和get()方法类似, 如果键不存在于字典中，将会添加键并将值设为默认值

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">}
　　</span><span style="color: #0000ff;">print</span>(a.setdefault(<span style="color: #800000;">"</span><span style="color: #800000;">test</span><span style="color: #800000;">"</span><span style="color: #000000;">))
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)
　　
　　{</span><span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span>: 18, <span style="color: #800000;">'</span><span style="color: #800000;">test</span><span style="color: #800000;">'</span><span style="color: #000000;">: None}
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　update　　把字典dict2的键</span>/<span style="color: #000000;">值对更新到dict里

　　例子：

　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　a1 </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">}
　　a2 </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">hobby</span><span style="color: #800000;">"</span>:<span style="color: #800000;">"</span><span style="color: #800000;">men</span><span style="color: #800000;">"</span><span style="color: #000000;">}
　　a1.update(a2)
　　</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a1)
　　
　　{</span><span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">xiaochen</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">age</span><span style="color: #800000;">'</span>: 18, <span style="color: #800000;">'</span><span style="color: #800000;">hobby</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">men</span><span style="color: #800000;">'</span><span style="color: #000000;">}
　　</span>---------------------------------------------------------------<span style="color: #000000;">
　　values　　已列表的形式返回字典中的所有值</span></pre>
</div>
<p><strong>注意：</strong></p>
<ul>
<li>字典是一种映射类型，它的元素是键值对。</li>
<li>字典的关键字必须为不可变类型，且不能重复。</li>
<li>创建空字典使用{}。&nbsp;</li>
</ul>
<h2><span style="font-size: 14pt;"><strong>*.python3集合</strong></span></h2>
<h3><strong><strong>概念</strong>：</strong></h3>
<p>　　集合是一个无序不重复元素的序列。</p>
<p>　　基本功能是进行成员关系测试和删除重复元素。</p>
<p>　　可以使用大括号{ }或者set()函数创建集合，但是创建一个空集合必须用set()</p>
<div class="cnblogs_code">
<pre>parame =<span style="color: #000000;"> {value01,value02,...}
　　或者
　　set(value)</span></pre>
</div>
<h3><span style="font-size: 18pt;"><strong>常用用法：</strong></span></h3>
<div class="cnblogs_code">
<pre>　a = set(<span style="color: #800000;">'</span><span style="color: #800000;">abracadabra</span><span style="color: #800000;">'</span><span style="color: #000000;">)

　　b </span>= set(<span style="color: #800000;">'</span><span style="color: #800000;">alacazam</span><span style="color: #800000;">'</span><span style="color: #000000;">)

　　</span>1<span style="color: #000000;">，差集

　　　　</span><span style="color: #0000ff;">print</span>(a -<span style="color: #000000;"> b)

　　</span>2<span style="color: #000000;">，并集

　　　　</span><span style="color: #0000ff;">print</span>(a |<span style="color: #000000;"> b)

　　</span>3<span style="color: #000000;">，交集

　　　　</span><span style="color: #0000ff;">print</span>(a &amp;<span style="color: #000000;"> b)

　　</span>4<span style="color: #000000;">，反交集

　　　　</span><span style="color: #0000ff;">print</span>(a ^<span style="color: #000000;"> b)

　　</span>5<span style="color: #000000;">，增

　　　　a.add(</span><span style="color: #800000;">'</span><span style="color: #800000;">666</span><span style="color: #800000;">'</span><span style="color: #000000;">)　　　 增加一个元素

　　　　a.update(</span><span style="color: #800000;">'</span><span style="color: #800000;">abc</span><span style="color: #800000;">'</span><span style="color: #000000;">)　　迭代增加 

　　</span>6<span style="color: #000000;">，删

　　　　a.remove　　　　 删除一个元素　

　　　　a.pop　　　　　　随机删除一个元素

　　　　a.clear　　　　　  清空集合

　　　　</span><span style="color: #0000ff;">del</span> a　　　　　　  删除集合</pre>
</div>
<p>&nbsp;</p>
<h2><span style="font-size: 14pt;">*<strong>.python3字符串</strong></span></h2>
<p><strong>字符串是 Python 中最常用的数据类型。我们可以使用引号('或")来创建字符串。</strong></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>%[(name)][flags][width].[precision]typecode</pre>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>tpl = <span style="color: #800000;">"</span><span style="color: #800000;">i am %s</span><span style="color: #800000;">"</span> % <span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span><span style="color: #000000;">
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am %s age %d</span><span style="color: #800000;">"</span> % (<span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, 18<span style="color: #000000;">)
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am %(name)s age %(age)d</span><span style="color: #800000;">"</span> % {<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">cai</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">}
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">percent %.2f</span><span style="color: #800000;">"</span> % 99.97623<span style="color: #000000;">
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am %(pp).2f</span><span style="color: #800000;">"</span> % {<span style="color: #800000;">"</span><span style="color: #800000;">pp</span><span style="color: #800000;">"</span>: 123.425556<span style="color: #000000;">, }
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am %.2f %%</span><span style="color: #800000;">"</span> % {<span style="color: #800000;">"</span><span style="color: #800000;">pp</span><span style="color: #800000;">"</span>: 123.425556, }</pre>
</div>
<h3>&nbsp;常用用法</h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">(name)      可选，用于选择指定的key
flags          可选，可供选择的值有:
</span>+<span style="color: #000000;">       右对齐；正数前加正好，负数前加负号；
</span>-<span style="color: #000000;">        左对齐；正数前无符号，负数前加负号；
空格    右对齐；正数前加空格，负数前加负号；
0        右对齐；正数前无符号，负数前加负号；用0填充空白处
width         可选，占有宽度
.precision   可选，小数点后保留的位数
typecode    必选
s，获取传入对象的__str__方法的返回值，并将其格式化到指定位置
r，获取传入对象的__repr__方法的返回值，并将其格式化到指定位置
c，整数：将数字转换成其unicode对应的值，10进制范围为 0 </span>&lt;= i &lt;= 1114111（py27则只支持0-255<span style="color: #000000;">）；字符：将字符添加到指定位置
o，将整数转换成 八  进制表示，并将其格式化到指定位置
x，将整数转换成十六进制表示，并将其格式化到指定位置
d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置
e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e）
E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E）
f， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位）
F，同上
g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；）
G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；）
</span>%，当字符串中存在格式化标志时，需要用 %%<span style="color: #000000;">表示一个百分号
注：Python中百分号格式化是不存在自动将整数转换成二进制表示的方式</span></pre>
</div>
<p>&nbsp;</p>
<h2><span style="font-size: 14pt;"><strong>*、Format方式</strong></span></h2>
<div class="cnblogs_code">
<pre>[[fill]align][sign][<span style="color: #008000;">#</span><span style="color: #008000;">][0][width][,][.precision][type]</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">fill           【可选】空白处填充的字符
align        【可选】对齐方式（需配合width使用）
</span>&lt;<span style="color: #000000;">，内容左对齐
</span>&gt;<span style="color: #000000;">，内容右对齐(默认)
＝，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号</span>+填充物+<span style="color: #000000;">数字
</span>^<span style="color: #000000;">，内容居中
sign         【可选】有无符号数字
</span>+<span style="color: #000000;">，正号加正，负号加负；
 </span>-<span style="color: #000000;">，正号不变，负号加负；
空格 ，正号空格，负号加负；
</span><span style="color: #008000;">#</span><span style="color: #008000;">            【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示</span>
，            【可选】为数字添加分隔符，如：1,000,000<span style="color: #000000;">
width       【可选】格式化位所占宽度
.precision 【可选】小数位保留精度
type         【可选】格式化类型
传入&rdquo; 字符串类型 &ldquo;的参数
s，格式化字符串类型数据
空白，未指定类型，则默认是None，同s
传入&ldquo; 整数类型 &rdquo;的参数
b，将10进制整数自动转换成2进制表示然后格式化
c，将10进制整数自动转换为其对应的unicode字符
d，十进制整数
o，将10进制整数自动转换成8进制表示然后格式化；
x，将10进制整数自动转换成16进制表示然后格式化（小写x）
X，将10进制整数自动转换成16进制表示然后格式化（大写X）
传入&ldquo; 浮点型或小数类型 &rdquo;的参数
e， 转换为科学计数法（小写e）表示，然后格式化；
E， 转换为科学计数法（大写E）表示，然后格式化;
f ， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；
F， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；
g， 自动在e和f中切换
G， 自动在E和F中切换
</span>%，显示百分比（默认显示小数点后6位）</pre>
</div>
<div class="cnblogs_code">
<pre>tpl = <span style="color: #800000;">"</span><span style="color: #800000;">i am {}, age {}, {}</span><span style="color: #800000;">"</span>.format(<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, 18, <span style="color: #800000;">'</span><span style="color: #800000;">alex</span><span style="color: #800000;">'</span><span style="color: #000000;">)
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {}, age {}, {}</span><span style="color: #800000;">"</span>.format(*[<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, 18, <span style="color: #800000;">'</span><span style="color: #800000;">alex</span><span style="color: #800000;">'</span><span style="color: #000000;">])
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {0}, age {1}, really {0}</span><span style="color: #800000;">"</span>.format(<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, 18<span style="color: #000000;">)
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {0}, age {1}, really {0}</span><span style="color: #800000;">"</span>.format(*[<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, 18<span style="color: #000000;">])
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {name}, age {age}, really {name}</span><span style="color: #800000;">"</span>.format(name=<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, age=18<span style="color: #000000;">)
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {name}, age {age}, really {name}</span><span style="color: #800000;">"</span>.format(**{<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">})
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {0[0]}, age {0[1]}, really {0[2]}</span><span style="color: #800000;">"</span>.format([1, 2, 3], [11, 22, 33<span style="color: #000000;">])
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {:s}, age {:d}, money {:f}</span><span style="color: #800000;">"</span>.format(<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, 18, 88888.1<span style="color: #000000;">)
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {:s}, age {:d}</span><span style="color: #800000;">"</span>.format(*[<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, 18<span style="color: #000000;">])
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {name:s}, age {age:d}</span><span style="color: #800000;">"</span>.format(name=<span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, age=18<span style="color: #000000;">)
   
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">i am {name:s}, age {age:d}</span><span style="color: #800000;">"</span>.format(**{<span style="color: #800000;">"</span><span style="color: #800000;">name</span><span style="color: #800000;">"</span>: <span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">age</span><span style="color: #800000;">"</span>: 18<span style="color: #000000;">})
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">numbers: {:b},{:o},{:d},{:x},{:X}, {:%}</span><span style="color: #800000;">"</span>.format(15, 15, 15, 15, 15, 15.87623, 2<span style="color: #000000;">)
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">numbers: {:b},{:o},{:d},{:x},{:X}, {:%}</span><span style="color: #800000;">"</span>.format(15, 15, 15, 15, 15, 15.87623, 2<span style="color: #000000;">)
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">numbers: {0:b},{0:o},{0:d},{0:x},{0:X}, {0:%}</span><span style="color: #800000;">"</span>.format(15<span style="color: #000000;">)
  
tpl </span>= <span style="color: #800000;">"</span><span style="color: #800000;">numbers: {num:b},{num:o},{num:d},{num:x},{num:X}, {num:%}</span><span style="color: #800000;">"</span>.format(num=15)</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>python第一阶段总结（1）</title><link>http://www.cnblogs.com/cainiao-chuanqi/archive/2018/08/02/9406421.html</link><dc:creator>菜鸟-传奇</dc:creator><author>菜鸟-传奇</author><pubDate>Thu, 02 Aug 2018 06:03:00 GMT</pubDate><guid>http://www.cnblogs.com/cainiao-chuanqi/archive/2018/08/02/9406421.html</guid><description><![CDATA[<h2 style="text-align: center;"><span style="font-size: 14pt;"><strong>python3第一阶段的总结　　</strong></span></h2>
<ul>
<li>
<p><span style="font-size: 12px;"><strong>python3的简介</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3安装及环境变量的操作</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3 基础语法</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3基本数据类型</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3运算符</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3数字</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3字符串</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3 列表</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3元组</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3字典</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3集合</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3条件控制</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3循环语句</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3迭代器与生成器</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3函数</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3数据结构</strong></span></p>
</li>
<li>
<p><span style="font-size: 12px;"><strong>python3模块</strong></span></p>
</li>
</ul>
<h2><span style="font-size: 14pt;">1.</span><span style="font-size: 14pt;">python3的简介</span></h2>
<p style="text-align: left;"><span style="font-size: 14pt;"><strong><strong>　</strong></strong>　Python的3.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下兼容。</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('09203482-d9b6-490f-8346-238cf743c650')"><img id="code_img_closed_09203482-d9b6-490f-8346-238cf743c650" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_09203482-d9b6-490f-8346-238cf743c650" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('09203482-d9b6-490f-8346-238cf743c650',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_09203482-d9b6-490f-8346-238cf743c650" class="cnblogs_code_hide">
<pre>Python的3.0版本，常被称为Python 3000<span style="color: #000000;">，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。


为了不带入过多的累赘，Python </span>3<span style="color: #000000;">.0在设计的时候没有考虑向下相容。


许多针对早期Python版本设计的程式都无法在Python </span>3<span style="color: #000000;">.0上正常执行。


为了照顾现有程式，Python </span>2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3<span style="color: #000000;">.0的语法与函数。


新的Python程式建议使用Python </span>3<span style="color: #000000;">.0版本的语法。


除非执行环境无法安装Python </span>3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3<span style="color: #000000;">.0的第三方库有Twisted, py2exe, PIL等。


大多数第三方库都正在努力地相容Python </span>3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2<span style="color: #000000;">.7来执行。


 </span></pre>
</div>
<span class="cnblogs_code_collapse">python2和python3的区别</span></div>
<h2 style="text-align: left;">&nbsp;<span style="font-size: 14pt;">2.python3安装及环境变量的操作</span></h2>
<p style="text-align: left;"><span style="font-size: 14pt;"><strong>　　</strong>我用的是pycharm,这个还是比较全的。建议学python的人使用。安装过程不难，大家可以在官网上查找。</span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('ede0fa8a-2c71-46f2-9218-e29f706a87c0')"><img id="code_img_closed_ede0fa8a-2c71-46f2-9218-e29f706a87c0" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_ede0fa8a-2c71-46f2-9218-e29f706a87c0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('ede0fa8a-2c71-46f2-9218-e29f706a87c0',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_ede0fa8a-2c71-46f2-9218-e29f706a87c0" class="cnblogs_code_hide">
<pre><span style="color: #000000;">python下载地址  www.python.org

Python 分为2.7和3.3两个版本，</span>3<span style="color: #000000;">.3有些库不兼容，因此用2.7版本

Python解释型语言  代码量小，可移植性高，执行速度慢

配置环境变量 Path   ;C:\Python27;

对缩进要求严格，四个空格，不建议用Tab，不同平台上缩进不一样

要输出中文在开头写上  </span><span style="color: #008000;">#</span><span style="color: #008000;"> -*- coding: utf-8 -*-</span>
我使用的IDE为Pycharm，注释为ctrl + /<span style="color: #000000;">
其他快捷键就不一一赘述了。</span></pre>
</div>
<span class="cnblogs_code_collapse">python下载</span></div>
<h2><span style="font-size: 14pt;"><strong>3.python3 基础语法</strong></span></h2>
<h3><strong><span style="font-size: 14pt;">1.编码</span></strong></h3>
<p>　　默认情况下，Python 3 源码文件以&nbsp;UTF-8&nbsp;编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> -*- coding: cp-1252 -*-</span></pre>
</div>
<h3><span style="font-size: 14pt;"><strong>2.标识符</strong></span></h3>
<p>&nbsp;</p>
<ul>
<li>第一个字符必须是字母表中字母或下划线&nbsp;<span class="marked">_&nbsp;。</span></li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>&nbsp;</p>
<p>在 Python 3 中，非 ASCII 标识符也是允许的了。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8dce19df-5ffd-4eba-b4e3-50f795d50872')"><img id="code_img_closed_8dce19df-5ffd-4eba-b4e3-50f795d50872" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_8dce19df-5ffd-4eba-b4e3-50f795d50872" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8dce19df-5ffd-4eba-b4e3-50f795d50872',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_8dce19df-5ffd-4eba-b4e3-50f795d50872" class="cnblogs_code_hide">
<pre><span style="color: #800000;">'</span><span style="color: #800000;">False</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">None</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">True</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">and</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">as</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">assert</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">break</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">class</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">continue</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">def</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">del</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">elif</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">else</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">except</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">finally</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">for</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">from</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">global</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">if</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">import</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">in</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">is</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">lambda</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">nonlocal</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">not</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">or</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">pass</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">raise</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">return</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">try</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">while</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">with</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">yield</span><span style="color: #800000;">'</span></pre>
</div>
<span class="cnblogs_code_collapse">python保留字</span></div>
<h3><span style="font-size: 14pt;">3.注释</span></h3>
<p>Python中单行注释以&nbsp;<strong>#</strong>&nbsp;开头，实例如下：</p>
<p>多行注释可以用多个&nbsp;<span class="marked">#&nbsp;号，还有&nbsp;<span class="marked">'''&nbsp;和&nbsp;<span class="marked">"""：。</span></span></span></p>
<h3><span style="font-size: 14pt;">4.行与缩进</span></h3>
<p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号&nbsp;<span class="marked">{}&nbsp;。</span></p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span><span style="color: #000000;"> True:
    </span><span style="color: #0000ff;">print</span> (<span style="color: #800000;">"</span><span style="color: #800000;">True</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">else</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">print</span> (<span style="color: #800000;">"</span><span style="color: #800000;">False</span><span style="color: #800000;">"</span>)</pre>
</div>
<h3><span style="font-size: 14pt;">5.多行语句</span></h3>
<p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠(\)来实现多行语句。</p>
<h3><span style="font-size: 14pt;">6.数字(Number)类型</span></h3>
<p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li><strong>int</strong>&nbsp;(整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li><strong>bool</strong>&nbsp;(布尔), 如 True。</li>
<li><strong>float</strong>&nbsp;(浮点数), 如 1.23、3E-2</li>
<li><strong>complex</strong>&nbsp;(复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<h3><span style="font-size: 14pt;">7.字符串(String)</span></h3>
<ul>
<li>python中单引号和双引号使用完全相同。</li>
<li>使用三引号('''或""")可以指定一个多行字符串。</li>
<li>转义符 '\'</li>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r"this is a line with \n" 则\n会显示，并不是换行。</li>
<li>按字面意义级联字符串，如"this " "is " "string"会被自动转换为this is string。</li>
<li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li>
<li>Python中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：<span class="marked">变量[头下标:尾下标]。</span></li>
</ul>
<div class="cnblogs_code">
<pre>str=<span style="color: #800000;">'</span><span style="color: #800000;">Runoob</span><span style="color: #800000;">'</span>
 
<span style="color: #0000ff;">print</span>(str)                 <span style="color: #008000;">#</span><span style="color: #008000;"> 输出字符串</span>
<span style="color: #0000ff;">print</span>(str[0:-1])           <span style="color: #008000;">#</span><span style="color: #008000;"> 输出第一个到倒数第二个的所有字符</span>
<span style="color: #0000ff;">print</span>(str[0])              <span style="color: #008000;">#</span><span style="color: #008000;"> 输出字符串第一个字符</span>
<span style="color: #0000ff;">print</span>(str[2:5])            <span style="color: #008000;">#</span><span style="color: #008000;"> 输出从第三个开始到第五个的字符</span>
<span style="color: #0000ff;">print</span>(str[2:])             <span style="color: #008000;">#</span><span style="color: #008000;"> 输出从第三个开始的后的所有字符</span>
<span style="color: #0000ff;">print</span>(str * 2)             <span style="color: #008000;">#</span><span style="color: #008000;"> 输出字符串两次</span>
<span style="color: #0000ff;">print</span>(str + <span style="color: #800000;">'</span><span style="color: #800000;">你好</span><span style="color: #800000;">'</span>)        <span style="color: #008000;">#</span><span style="color: #008000;"> 连接字符串</span>
 
<span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">------------------------------</span><span style="color: #800000;">'</span><span style="color: #000000;">)
 
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hello\nrunoob</span><span style="color: #800000;">'</span>)      <span style="color: #008000;">#</span><span style="color: #008000;"> 使用反斜杠(\)+n转义特殊字符</span>
<span style="color: #0000ff;">print</span>(r<span style="color: #800000;">'</span><span style="color: #800000;">hello\nrunoob</span><span style="color: #800000;">'</span>)     <span style="color: #008000;">#</span><span style="color: #008000;"> 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></pre>
</div>
<h3><span style="font-size: 14pt;">8.空行</span></h3>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<div class="col middle-column">
<div class="article">
<div class="article-body">
<div id="content" class="article-intro">
<h3><span style="font-size: 14pt;">9.同一行显示多条语句</span></h3>
<h1><span style="font-size: 13px;"><strong>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割。</strong></span></h1>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span> sys; x = <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>; sys.stdout.write(x + <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span>)</pre>
</div>
<h3><span style="font-size: 14pt;"><strong>10.多个语句构成代码组</strong></span></h3>
<p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span><span style="color: #000000;"> expression : 
   suite
</span><span style="color: #0000ff;">elif</span><span style="color: #000000;"> expression : 
   suite 
</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> : 
   suite</span></pre>
</div>
<h3><span style="font-size: 14pt;">11.Print 输出</span></h3>
<p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上&nbsp;<strong>end=""。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"> 
x</span>=<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span><span style="color: #000000;">
y</span>=<span style="color: #800000;">"</span><span style="color: #800000;">b</span><span style="color: #800000;">"</span>
<span style="color: #008000;">#</span><span style="color: #008000;"> 换行输出</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;">( x )
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">( y )
 
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">---------</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #008000;">#</span><span style="color: #008000;"> 不换行输出</span>
<span style="color: #0000ff;">print</span>( x, end=<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;"> )
</span><span style="color: #0000ff;">print</span>( y, end=<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;"> )
</span><span style="color: #0000ff;">print</span>()</pre>
</div>
<h3><span style="font-size: 14pt;">12.import 与 from...import</span></h3>
<p>在 python 用&nbsp;<span class="marked">import&nbsp;或者&nbsp;<span class="marked">from...import&nbsp;来导入相应的模块。</span></span></p>
<p>将整个模块(somemodule)导入，格式为：&nbsp;<span class="marked">import somemodule</span></p>
<p>从某个模块中导入某个函数,格式为：&nbsp;<span class="marked">from somemodule import somefunction</span></p>
<p>从某个模块中导入多个函数,格式为：&nbsp;<span class="marked">from somemodule import firstfunc, secondfunc, thirdfunc</span></p>
<p>将某个模块中的全部函数导入，格式为：&nbsp;<span class="marked">from somemodule import *</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">import</span><span style="color: #000000;"> sys
</span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">================Python import mode==========================</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">print</span> (<span style="color: #800000;">'</span><span style="color: #800000;">命令行参数为:</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> sys.argv:
    </span><span style="color: #0000ff;">print</span><span style="color: #000000;"> (i)
</span><span style="color: #0000ff;">print</span> (<span style="color: #800000;">'</span><span style="color: #800000;">\n python 路径为</span><span style="color: #800000;">'</span>,sys.path)</pre>
</div>
<h3><span style="font-size: 14pt;">13.命令行参数</span></h3>
<p>很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：</p>
<div class="cnblogs_code">
<pre>-c cmd : program passed <span style="color: #0000ff;">in</span><span style="color: #000000;"> as string (terminates option list)
</span>-d     : debug output <span style="color: #0000ff;">from</span> parser (also PYTHONDEBUG=<span style="color: #000000;">x)
</span>-<span style="color: #000000;">E     : ignore environment variables (such as PYTHONPATH)
</span>-h     : <span style="color: #0000ff;">print</span> this help message <span style="color: #0000ff;">and</span> exit</pre>
</div>
<h2><span style="font-size: 14pt;">&nbsp;4.<strong>python3基本数据类型</strong></span></h2>
<p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。</p>
<p>等号（=）用来给变量赋值。</p>
<p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。</p>
<h2><span style="font-size: 14pt;">标准数据类型</span></h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Python3 中有六个标准的数据类型：

Number（数字）
String（字符串）
List（列表）
Tuple（元组）
Set（集合）
Dictionary（字典）
Python3 的六个标准数据类型中：

不可变数据（</span>3<span style="color: #000000;"> 个）：Number（数字）、String（字符串）、Tuple（元组）；
可变数据（</span>3 个）：List（列表）、Dictionary（字典）、Set（集合）。</pre>
</div>
<h3><span style="font-size: 14pt;">Number（数字）</span></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Python3 支持 int、float、bool、complex（复数）。
在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。
像大多数语言一样，数值类型的赋值和计算都是很直观的。
内置的 type() 函数可以用来查询变量所指的对象类型。

区别就是:
type()不会认为子类是一种父类类型。
isinstance()会认为子类是一种父类类型。

注意：在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 </span>1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。</pre>
</div>
<h3>数值运算</h3>
<div class="cnblogs_code">
<pre>&gt;&gt;&gt;5 + 4  <span style="color: #008000;">#</span><span style="color: #008000;"> 加法</span>
9
&gt;&gt;&gt; 4.3 - 2 <span style="color: #008000;">#</span><span style="color: #008000;"> 减法</span>
2.3
&gt;&gt;&gt; 3 * 7  <span style="color: #008000;">#</span><span style="color: #008000;"> 乘法</span>
21
&gt;&gt;&gt; 2 / 4  <span style="color: #008000;">#</span><span style="color: #008000;"> 除法，得到一个浮点数</span>
0.5
&gt;&gt;&gt; 2 // 4 <span style="color: #008000;">#</span><span style="color: #008000;"> 除法，得到一个整数</span>
<span style="color: #000000;">0
</span>&gt;&gt;&gt; 17 % 3 <span style="color: #008000;">#</span><span style="color: #008000;"> 取余 </span>
2
&gt;&gt;&gt; 2 ** 5 <span style="color: #008000;">#</span><span style="color: #008000;"> 乘方</span>
32<span style="color: #000000;">
注意：

</span>1、Python可以同时为多个变量赋值，如a, b = 1, 2<span style="color: #000000;">。
</span>2<span style="color: #000000;">、一个变量可以通过赋值指向不同类型的对象。
</span>3、数值的除法包含两个运算符：/ 返回一个浮点数，//<span style="color: #000000;"> 返回一个整数。
</span>4、在混合计算时，Python会把整型转换成为浮点数。</pre>
</div>
<h3><span style="font-size: 14pt;">String（字符串）</span></h3>
<div class="cnblogs_code">
<pre>Python中的字符串用单引号 <span style="color: #800000;">'</span><span style="color: #800000;"> 或双引号 " 括起来，同时使用反斜杠 \ 转义特殊字符。</span>
<span style="color: #000000;">
加号 </span>+ 是字符串的连接符， 星号 *<span style="color: #000000;"> 表示复制当前字符串，紧跟的数字为复制的次数。

Python 使用反斜杠(\)转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串：

另外，反斜杠(\)可以作为续行符，表示下一行是上一行的延续。也可以使用 </span><span style="color: #800000;">"""</span><span style="color: #800000;">...</span><span style="color: #800000;">"""</span> 或者 <span style="color: #800000;">'''</span><span style="color: #800000;">...</span><span style="color: #800000;">'''</span><span style="color: #000000;"> 跨越多行。

注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。

与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">m</span><span style="color: #800000;">'</span><span style="color: #000000;">会导致错误。

注意：

</span>1<span style="color: #000000;">、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。
</span>2、字符串可以用+运算符连接在一起，用*<span style="color: #000000;">运算符重复。
</span>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-<span style="color: #000000;">1开始。
</span>4、Python中的字符串不能改变。</pre>
</div>
<h3><span style="font-size: 14pt;">List（列表）</span></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">List（列表） 是 Python 中使用最频繁的数据类型。

列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。

列表是写在方括号 [] 之间、用逗号分隔开的元素列表。

和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。

加号 </span>+ 是列表连接运算符，星号 *<span style="color: #000000;"> 是重复操作。

ist内置了有很多方法，例如append()、pop()等等，这在后面会讲到。

注意：

</span>1<span style="color: #000000;">、List写在方括号之间，元素用逗号隔开。
</span>2<span style="color: #000000;">、和字符串一样，list可以被索引和切片。
</span>3、List可以使用+<span style="color: #000000;">操作符进行拼接。
</span>4、List中的元素是可以改变的。</pre>
</div>
<h3><span style="font-size: 14pt;">Tuple（元组）</span></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。

元组中的元素类型也可以不相同：
 
tuple </span>= ( <span style="color: #800000;">'</span><span style="color: #800000;">abcd</span><span style="color: #800000;">'</span>, 786 , 2.23, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>, 70.2<span style="color: #000000;">  )
tinytuple </span>= (123, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span><span style="color: #000000;">)
 
</span><span style="color: #0000ff;">print</span> (tuple)             <span style="color: #008000;">#</span><span style="color: #008000;"> 输出完整元组</span>
<span style="color: #0000ff;">print</span> (tuple[0])          <span style="color: #008000;">#</span><span style="color: #008000;"> 输出元组的第一个元素</span>
<span style="color: #0000ff;">print</span> (tuple[1:3])        <span style="color: #008000;">#</span><span style="color: #008000;"> 输出从第二个元素开始到第三个元素</span>
<span style="color: #0000ff;">print</span> (tuple[2:])         <span style="color: #008000;">#</span><span style="color: #008000;"> 输出从第三个元素开始的所有元素</span>
<span style="color: #0000ff;">print</span> (tinytuple * 2)     <span style="color: #008000;">#</span><span style="color: #008000;"> 输出两次元组</span>
<span style="color: #0000ff;">print</span> (tuple + tinytuple) <span style="color: #008000;">#</span><span style="color: #008000;"> 连接元组</span>
<span style="color: #000000;">
以上实例输出结果：
(</span><span style="color: #800000;">'</span><span style="color: #800000;">abcd</span><span style="color: #800000;">'</span>, 786, 2.23, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>, 70.2<span style="color: #000000;">)
abcd
(</span>786, 2.23<span style="color: #000000;">)
(</span>2.23, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>, 70.2<span style="color: #000000;">)
(</span>123, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>, 123, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span><span style="color: #000000;">)
(</span><span style="color: #800000;">'</span><span style="color: #800000;">abcd</span><span style="color: #800000;">'</span>, 786, 2.23, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>, 70.2, 123, <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span><span style="color: #000000;">)

元组与字符串类似，可以被索引且下标索引从0开始，</span>-1<span style="color: #000000;"> 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。

其实，可以把字符串看作一种特殊的元组。

实例
</span>&gt;&gt;&gt;tup = (1, 2, 3, 4, 5, 6<span style="color: #000000;">)
</span>&gt;&gt;&gt; <span style="color: #0000ff;">print</span><span style="color: #000000;">(tup[0])
</span>1
&gt;&gt;&gt; <span style="color: #0000ff;">print</span>(tup[1:5<span style="color: #000000;">])
(</span>2, 3, 4, 5<span style="color: #000000;">)
</span>&gt;&gt;&gt; tup[0] = 11  <span style="color: #008000;">#</span><span style="color: #008000;"> 修改元组元素的操作是非法的</span>
<span style="color: #000000;">Traceback (most recent call last):
  File </span><span style="color: #800000;">"</span><span style="color: #800000;">&lt;stdin&gt;</span><span style="color: #800000;">"</span>, line 1, <span style="color: #0000ff;">in</span> &lt;module&gt;<span style="color: #000000;">
TypeError: </span><span style="color: #800000;">'</span><span style="color: #800000;">tuple</span><span style="color: #800000;">'</span> object does <span style="color: #0000ff;">not</span><span style="color: #000000;"> support item assignment
</span>&gt;&gt;&gt;<span style="color: #000000;">

string、list和tuple都属于sequence（序列）。

注意：

</span>1<span style="color: #000000;">、与字符串一样，元组的元素不能修改。
</span>2<span style="color: #000000;">、元组也可以被索引和切片，方法一样。
</span>3<span style="color: #000000;">、注意构造包含0或1个元素的元组的特殊语法规则。
</span>4、元组也可以使用+操作符进行拼接。</pre>
</div>
<h3><span style="font-size: 14pt;">Set（集合）</span></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">集合（set）是一个无序不重复元素的序列。

基本功能是进行成员关系测试和删除重复元素。

可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
parame </span>=<span style="color: #000000;"> {value01,value02,...}
或者
set(value)
实例
</span><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/python3</span>
<span style="color: #000000;"> 
student </span>= {<span style="color: #800000;">'</span><span style="color: #800000;">Tom</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Jim</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Mary</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Tom</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Jack</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Rose</span><span style="color: #800000;">'</span><span style="color: #000000;">}
 
</span><span style="color: #0000ff;">print</span>(student)   <span style="color: #008000;">#</span><span style="color: #008000;"> 输出集合，重复的元素被自动去掉</span>
 
<span style="color: #008000;">#</span><span style="color: #008000;"> 成员测试</span>
<span style="color: #0000ff;">if</span> <span style="color: #800000;">'</span><span style="color: #800000;">Rose</span><span style="color: #800000;">'</span> <span style="color: #0000ff;">in</span><span style="color: #000000;"> student :
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">Rose 在集合中</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> :
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">Rose 不在集合中</span><span style="color: #800000;">'</span><span style="color: #000000;">)
 
 
</span><span style="color: #008000;">#</span><span style="color: #008000;"> set可以进行集合运算</span>
a = set(<span style="color: #800000;">'</span><span style="color: #800000;">abracadabra</span><span style="color: #800000;">'</span><span style="color: #000000;">)
b </span>= set(<span style="color: #800000;">'</span><span style="color: #800000;">alacazam</span><span style="color: #800000;">'</span><span style="color: #000000;">)
 
</span><span style="color: #0000ff;">print</span><span style="color: #000000;">(a)
 
</span><span style="color: #0000ff;">print</span>(a - b)     <span style="color: #008000;">#</span><span style="color: #008000;"> a和b的差集</span>
 
<span style="color: #0000ff;">print</span>(a | b)     <span style="color: #008000;">#</span><span style="color: #008000;"> a和b的并集</span>
 
<span style="color: #0000ff;">print</span>(a &amp; b)     <span style="color: #008000;">#</span><span style="color: #008000;"> a和b的交集</span>
 
<span style="color: #0000ff;">print</span>(a ^ b)     <span style="color: #008000;">#</span><span style="color: #008000;"> a和b中不同时存在的元素</span>
<span style="color: #000000;">以上实例输出结果：

{</span><span style="color: #800000;">'</span><span style="color: #800000;">Mary</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Jim</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Rose</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Jack</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">Tom</span><span style="color: #800000;">'</span><span style="color: #000000;">}
Rose 在集合中
{</span><span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">r</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span><span style="color: #000000;">}
{</span><span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">r</span><span style="color: #800000;">'</span><span style="color: #000000;">}
{</span><span style="color: #800000;">'</span><span style="color: #800000;">l</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">r</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">m</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span><span style="color: #000000;">}
{</span><span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">c</span><span style="color: #800000;">'</span><span style="color: #000000;">}
{</span><span style="color: #800000;">'</span><span style="color: #800000;">l</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">r</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">m</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">b</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">d</span><span style="color: #800000;">'</span>}</pre>
</div>
<h3><span style="font-size: 14pt;">Dictionary（字典）</span></h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">字典（dictionary）是Python中另一个非常有用的内置数据类型。

列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

字典是一种映射类型，字典用</span><span style="color: #800000;">"</span><span style="color: #800000;">{ }</span><span style="color: #800000;">"</span><span style="color: #000000;">标识，它是一个无序的键(key) : 值(value)对集合。

键(key)必须使用不可变类型。

在同一个字典中，键(key)必须是唯一的。

实例1
</span><span style="color: #008000;">#</span><span style="color: #008000;">!/usr/bin/python3</span>
<span style="color: #000000;"> 
dict </span>=<span style="color: #000000;"> {}
dict[</span><span style="color: #800000;">'</span><span style="color: #800000;">one</span><span style="color: #800000;">'</span>] = <span style="color: #800000;">"</span><span style="color: #800000;">1 - 菜鸟教程</span><span style="color: #800000;">"</span><span style="color: #000000;">
dict[</span>2]     = <span style="color: #800000;">"</span><span style="color: #800000;">2 - 菜鸟工具</span><span style="color: #800000;">"</span><span style="color: #000000;">
 
tinydict </span>= {<span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">code</span><span style="color: #800000;">'</span>:1, <span style="color: #800000;">'</span><span style="color: #800000;">site</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">www.runoob.com</span><span style="color: #800000;">'</span><span style="color: #000000;">}
 
 
</span><span style="color: #0000ff;">print</span> (dict[<span style="color: #800000;">'</span><span style="color: #800000;">one</span><span style="color: #800000;">'</span>])       <span style="color: #008000;">#</span><span style="color: #008000;"> 输出键为 'one' 的值</span>
<span style="color: #0000ff;">print</span> (dict[2])           <span style="color: #008000;">#</span><span style="color: #008000;"> 输出键为 2 的值</span>
<span style="color: #0000ff;">print</span> (tinydict)          <span style="color: #008000;">#</span><span style="color: #008000;"> 输出完整的字典</span>
<span style="color: #0000ff;">print</span> (tinydict.keys())   <span style="color: #008000;">#</span><span style="color: #008000;"> 输出所有键</span>
<span style="color: #0000ff;">print</span> (tinydict.values()) <span style="color: #008000;">#</span><span style="color: #008000;"> 输出所有值</span>
<span style="color: #000000;">以上实例输出结果：
{</span><span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">site</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">www.runoob.com</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">code</span><span style="color: #800000;">'</span>: 1<span style="color: #000000;">}
dict_keys([</span><span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">site</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">code</span><span style="color: #800000;">'</span><span style="color: #000000;">])
dict_values([</span><span style="color: #800000;">'</span><span style="color: #800000;">runoob</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">www.runoob.com</span><span style="color: #800000;">'</span>, 1<span style="color: #000000;">])

实例2
</span>&gt;&gt;&gt;dict([(<span style="color: #800000;">'</span><span style="color: #800000;">Runoob</span><span style="color: #800000;">'</span>, 1), (<span style="color: #800000;">'</span><span style="color: #800000;">Google</span><span style="color: #800000;">'</span>, 2), (<span style="color: #800000;">'</span><span style="color: #800000;">Taobao</span><span style="color: #800000;">'</span>, 3<span style="color: #000000;">)])
{</span><span style="color: #800000;">'</span><span style="color: #800000;">Taobao</span><span style="color: #800000;">'</span>: 3, <span style="color: #800000;">'</span><span style="color: #800000;">Runoob</span><span style="color: #800000;">'</span>: 1, <span style="color: #800000;">'</span><span style="color: #800000;">Google</span><span style="color: #800000;">'</span>: 2<span style="color: #000000;">}
 
</span>&gt;&gt;&gt; {x: x**2 <span style="color: #0000ff;">for</span> x <span style="color: #0000ff;">in</span> (2, 4, 6<span style="color: #000000;">)}
{</span>2: 4, 4: 16, 6: 36<span style="color: #000000;">}
 
</span>&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3<span style="color: #000000;">)
{</span><span style="color: #800000;">'</span><span style="color: #800000;">Taobao</span><span style="color: #800000;">'</span>: 3, <span style="color: #800000;">'</span><span style="color: #800000;">Runoob</span><span style="color: #800000;">'</span>: 1, <span style="color: #800000;">'</span><span style="color: #800000;">Google</span><span style="color: #800000;">'</span>: 2<span style="color: #000000;">}
另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。

注意：

</span>1<span style="color: #000000;">、字典是一种映射类型，它的元素是键值对。
</span>2<span style="color: #000000;">、字典的关键字必须为不可变类型，且不能重复。
</span>3、创建空字典使用 { }。</pre>
</div>
<h2><span style="font-size: 14pt;">Python数据类型转换</span></h2>
<div class="cnblogs_code">
<pre><span style="color: #000000;">函数    描述    
int(x [,base])                         将x转换为一个整数
            
float(x)                               将x转换到一个浮点数

complex(real [,imag])                  创建一个复数

str(x)                                 将对象 x 转换为字符串

repr(x)                                将对象 x 转换为表达式字符串

eval(str)                              用来计算在字符串中的有效Python表达式,并返回一个对象

tuple(s)                               将序列 s 转换为一个元组

list(s)                                将序列 s 转换为一个列表

set(s)                                 转换为可变集合

dict(d)                                创建一个字典。d 必须是一个序列 (key,value)元组。

frozenset(s)                           转换为不可变集合

chr(x)                                 将一个整数转换为一个字符

ord(x)                                 将一个字符转换为它的整数值

hex(x)                                 将一个整数转换为一个十六进制字符串

oct(x)                                 将一个整数转换为一个八进制字符串                                                </span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</div>
</div>
</div>]]></description></item></channel></rss>